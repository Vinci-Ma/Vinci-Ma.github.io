<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Vinci-Ma.github.io</id>
    <title>Vinci-Ma</title>
    <updated>2020-08-14T15:00:40.504Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Vinci-Ma.github.io"/>
    <link rel="self" href="https://Vinci-Ma.github.io/atom.xml"/>
    <subtitle>Stay cooool!</subtitle>
    <logo>https://Vinci-Ma.github.io/images/avatar.png</logo>
    <icon>https://Vinci-Ma.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Vinci-Ma</rights>
    <entry>
        <title type="html"><![CDATA[JSP学习]]></title>
        <id>https://Vinci-Ma.github.io/post/jsp-xue-xi/</id>
        <link href="https://Vinci-Ma.github.io/post/jsp-xue-xi/">
        </link>
        <updated>2020-08-14T14:56:20.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#jsp">JSP</a></li>
<li><a href="#jsp%E5%87%BA%E7%8E%B0%E5%8E%9F%E5%9B%A0">JSP出现原因</a></li>
<li><a href="#jsp%E4%B8%AD%E5%A6%82%E4%BD%95%E5%B5%8C%E5%A5%97java%E4%BB%A3%E7%A0%81">JSP中如何嵌套Java代码</a></li>
<li><a href="#jsp%E5%8E%9F%E7%90%86">JSP原理</a></li>
<li><a href="#jsp%E7%9A%849%E4%B8%AA%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E9%87%8D%E7%82%B9">JSP的9个内置对象【重点】</a>
<ul>
<li><a href="#1-request%E5%AF%B9%E8%B1%A1">1、request对象！</a></li>
<li><a href="#2-response%E5%AF%B9%E8%B1%A1">2、response对象！</a></li>
<li><a href="#3-session%E5%AF%B9%E8%B1%A1">3、session对象！</a></li>
<li><a href="#4-application%E5%AF%B9%E8%B1%A1">4、application对象！</a></li>
<li><a href="#5-out-%E5%AF%B9%E8%B1%A1">5、out 对象</a></li>
<li><a href="#6-pagecontext-%E5%AF%B9%E8%B1%A1">6、pageContext 对象</a></li>
<li><a href="#7-config-%E5%AF%B9%E8%B1%A1">7、config 对象</a></li>
<li><a href="#8-page-%E5%AF%B9%E8%B1%A1">8、page 对象</a></li>
<li><a href="#9-exception-%E5%AF%B9%E8%B1%A1">9、exception 对象</a></li>
</ul>
</li>
<li><a href="#jsp%E7%9A%84%E4%B8%89%E5%A4%A7%E6%8C%87%E4%BB%A4">JSP的三大指令</a>
<ul>
<li><a href="#page-%E6%8C%87%E4%BB%A4">Page 指令</a></li>
<li><a href="#include%E6%8C%87%E4%BB%A4">include指令</a></li>
<li><a href="#taglib%E6%8C%87%E4%BB%A4">Taglib指令</a></li>
</ul>
</li>
<li><a href="#jsp%E5%87%BA%E7%8E%B0%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81">JSP出现的状态码</a></li>
<li><a href="#el%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%B8%B8%E7%94%A8">EL表达式【常用】</a></li>
<li><a href="#jstl">JSTL</a>
<ul>
<li><a href="#%E7%AE%80%E4%BB%8B">简介：</a></li>
<li><a href="#jatl%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F">JATL的作用和语法格式</a></li>
<li><a href="#%E6%A0%B8%E5%BF%83%E6%A0%87%E7%AD%BE">核心标签</a></li>
<li><a href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%A0%87%E7%AD%BE">格式化标签</a></li>
</ul>
</li>
</ul>
</p>
<h1 id="jsp">JSP</h1>
<p>JSP全名为Java Server Pages，中文名叫java服务器页面，其根本是一个简化的Servlet设计，它 是由Sun Microsystems公司倡导、许多公司参与一起建立的一种动态网页技术标准。JSP技术有点类似ASP技术，它是在传统的网页HTML文件(<em>.htm,</em>.html)中插入Java程序段(Scriptlet)和JSP标记(tag)，从而形成JSP文件，后缀名为(*.jsp)。 用JSP开发的Web应用是跨平台的，既能在Linux下运行，也能在其他操作系统上运行。</p>
<p>JSP将网页逻辑与网页设计的显示分离，支持可重用的基于组件的设计，使基于Web的应用程序的开发变得迅速和容易。</p>
<p>*.html 静态页面(包含固定的页面内容)</p>
<p>*.jsp 动态页面(页面数据可以动态更新,支持嵌套java代码和html代码)</p>
<h1 id="jsp出现原因">JSP出现原因</h1>
<ol>
<li>servlet显示信息不方便，引入了JSP</li>
<li>JSP本质上也是一个servlet</li>
<li>JSP就是在HTML页面中嵌套了java代码</li>
</ol>
<h1 id="jsp中如何嵌套java代码">JSP中如何嵌套Java代码</h1>
<pre><code class="language-java">声明标签 &lt;%!变量或者方法声明%&gt;
表达式标签 &lt;%= 表达式%&gt; 在页面上显示的效果
程序代码标签 &lt;%java代码%&gt; 页面上动态展示内容

page指令:(用于设置当前代码中的一些编码方式、语言、导的包……)
	&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot;pageEncoding=&quot;UTF-8&quot;%&gt;
    
&lt;body&gt;
&lt;%! int i=10;%&gt;&lt;!--成员变量--&gt;
&lt;%! public void show(){}%&gt; &lt;!--成员方法--&gt;
&lt;%=i%&gt; &lt;!--输出变量值--&gt;
&lt;/body&gt;
 
注释：
    &lt;!-- html注释内容,查看源码时能看到 --&gt;
    &lt;%-- jsp注释,查看页面源码时看不到 --%&gt;
</code></pre>
<h1 id="jsp原理">JSP原理</h1>
<p>当浏览器访问http://localhost:8080/day9_1/index.jsp。服务器发现后缀为.jsp，它会根据路径找到index.jsp文件，会将index.jsp翻译成index_jsp.java文件，对这个java文件进行编译，产生一个index_jsp.class文件，将class文件加载运行。</p>
<p>将JSP翻译成java文件，它是将JSP中的所有的HTML代码通过流进行输出，也就是说最终翻译成class，被虚拟机加载，它本质是servlet，它就会往回响应，响应回去就是把JSP中的HTML代码以流的方式写回浏览器。所以在JSP中展示出了HTML代码。</p>
<h1 id="jsp的9个内置对象重点">JSP的9个内置对象【重点】</h1>
<p>JSP中一共预先定义了9个这样的对象，分别为：request、response、session、application、out、pagecontext、config、page、exception</p>
<h2 id="1-request对象">1、request对象！</h2>
<p>request 对象是 javax.servlet.httpServletRequest类型的对象。 该对象代表了<strong>客户端的请求信息</strong>，主要用于接受通过HTTP协议传送到服务器的数据。（包括头信息、系统信息、请求方式以及请求参数等）。<strong>request对象的作用域为一次请求。</strong></p>
<h2 id="2-response对象">2、response对象！</h2>
<p>response 代表的是<strong>对客户端的响应</strong>，主要是将JSP容器处理过的对象传回到客户端。response对象也具有作用域，它只在JSP页面内有效。所属类型: HttpServletResponse。</p>
<h2 id="3-session对象">3、session对象！</h2>
<p>session 对象是由服务器自动创建的与用户请求相关的对象。服务器为每个用户都生成一个session对象，用于保存该用户的信息，跟踪用户的操作状态。session对象内部使用Map类来保存数据，因此保存数据的格式为“Key/value”。 session对象的value可以使复杂的对象类型，而不仅仅局限于字符串类型。<strong>作用域为会话期间</strong>，所属类型: HttpSession。</p>
<h2 id="4-application对象">4、application对象！</h2>
<p><strong>application 对象可将信息保存在服务器中，直到服务器关闭，否则application对象中保存的信息会在整个应用中都有效</strong>。<br>
与session对象相比，application对象生命周期更长，类似于系统的“全局变量” ServletContext。<br>
<strong><mark>区别：</mark></strong><br>
request:单次请求<br>
session:浏览器访问期间(会话期间)<br>
application:服务器启动期间,所存的数据可以跨浏览器</p>
<h2 id="5-out-对象">5、out 对象</h2>
<p><strong>out 对象用于在Web浏览器内输出信息</strong>，并且管理应用服务器上的输出缓冲区。在使用 out 对象输出数据时，可以对数据缓冲区进行操作，及时清除缓冲区中的残余数据，为其他的输出让出缓冲空间。待数据输出完毕后，要及时关闭输出流。</p>
<pre><code class="language-java">//可以用于弹出弹窗
out.print(&quot;&lt;script type='text/javascript'&gt;alert('用户名不存在');location.href='index.jsp'&lt;/script&gt;&quot;);
</code></pre>
<h2 id="6-pagecontext-对象">6、pageContext 对象</h2>
<p><strong>pageContext 对象的作用是取得任何范围的参数</strong>，通过它可以获取 JSP页面的out、request、reponse、session、application 等对象。pageContext对象的创建和初始化都是由容器来完成的，在JSP页面中可以直接使用pageContext对象。</p>
<h2 id="7-config-对象">7、config 对象</h2>
<p>config 对象的主要作用是<strong>取得服务器的配置信息</strong>。通过 pageConext对象的 getServletConfig() 方法可以获取一个config对象。当一个Servlet 初始化时，容器把某些信息通过config对象传递给这个 Servlet。 开发者可以在web.xml 文件中为应用程序环境中的Servlet程序和JSP页面提供初始化参数。</p>
<pre><code class="language-java">//将image路径转换成服务器端的路径
String url= config.getServletContext().getRealPath(&quot;/image&quot;);
&lt;h1&gt;url=&lt;%=url %&gt;&lt;/h1&gt;
</code></pre>
<h2 id="8-page-对象">8、page 对象</h2>
<p>page 对象代表JSP本身，只有在JSP页面内才是合法的。 page隐含对象本质上包含当前 Servlet接口引用的变量，<strong>类似于Java编程中的 this 指针</strong>。</p>
<h2 id="9-exception-对象">9、exception 对象</h2>
<p>exception 对象的作用是<strong>显示异常信息</strong>，只有在包含 isErrorPage=&quot;true&quot; 的页面中才可以被使用，在一般的JSP页面中使用该对象将无法编译JSP文件。excepation对象和Java的所有对象一样，都具有系统提供的继承结构。<br>
exception 对象几乎定义了所有异常情况。在Java程序中，可以使用try/catch关键字来处理异常情况； 如果在JSP页面中出现没有捕获到的异常，就会生成exception 对象，并把 exception 对象传送到在page指令中设定的错误页面中，然后在错误页面中处理相应的 exception 对象。</p>
<p>(1)先在可能发生错误的页面中添加errorPage属性:</p>
<pre><code class="language-java">&lt;%@ page pageEncoding=&quot;utf-8&quot;
errorPage=&quot;error.jsp&quot;
contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
</code></pre>
<p>(2) 在error.jsp页面中设置isErrorPage=&quot;true&quot; 的属性<br>
(使用exception对象之前，需要先将当前页面设置成错误页面）</p>
<pre><code class="language-java">&lt;%@ page language=&quot;java&quot; isErrorPage=&quot;true&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt;
</code></pre>
<p>jsp存值的作用域:<br>
pageContext   -&gt;  request     -&gt; session       -&gt; application<br>
当前页面       单次请求有效  当前会话期间     服务器运行期间有效</p>
<h1 id="jsp的三大指令">JSP的三大指令</h1>
<p>JSP指令用来设置整个JSP页面相关的属性，如网页的编码方式和脚本语言。</p>
<pre><code class="language-java">语法格式如下：
    &lt;%@ directive attribute=&quot;value&quot; %&gt;
	directive：指令名称 attribute 属性名 value:属性值
</code></pre>
<table>
<thead>
<tr>
<th>指令名称</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>page</td>
<td style="text-align:left">定义网路依赖性，比如脚本语言、error页面、缓存需求等</td>
</tr>
<tr>
<td>include</td>
<td style="text-align:left">包含其他文件</td>
</tr>
<tr>
<td>include</td>
<td style="text-align:left">引入标签库的定义</td>
</tr>
</tbody>
</table>
<h2 id="page-指令">Page 指令</h2>
<pre><code class="language-java">Page指令为容器提供当前页面的使用说明
一个JSP页面可以包含多个page指令
Page指令的语法格式：
	&lt;%@ page attribute=&quot;value&quot; %&gt;
</code></pre>
<table>
<thead>
<tr>
<th>属性名</th>
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>language</td>
<td>java</td>
<td>解释该JSP文件时采用的语言，一般为java语言，默认为java</td>
</tr>
<tr>
<td>extends</td>
<td>任何类的全名</td>
<td>编译该JSP文件时继承哪个类，JSP为Servlet，因此当指明继承普通类时需要实现Servlet的init、destroy等方法</td>
</tr>
<tr>
<td>import</td>
<td>任何包名、类名</td>
<td>引入该JSP中用到的类、包等，import是唯一可以声明多次的page指令属性，一个import可以引用uogelei，中间用英文逗号隔开&lt;%@ page import=包名.类名，包名.类名%&gt;</td>
</tr>
<tr>
<td>session</td>
<td>true、false</td>
<td>该JSP内是否内置Session对象，如果为true，则内置Session对象，可直接使用，否则反之，默认为true</td>
</tr>
<tr>
<td>autoFlush</td>
<td>true、false</td>
<td>是否运行缓存，如果为true，则使用out.println()等方法输出的字符串并不是立刻到达客户端服务器的，而是暂时存到缓存里，缓存满了或者程序行完毕或者执行out.flush()操作时才到客户端，默认为true。</td>
</tr>
<tr>
<td>buffer</td>
<td>none或者数字KB</td>
<td>指定缓存大小，当autoFlush设为true时有效，例如&lt;%@ page buffer=10kb%&gt;</td>
</tr>
<tr>
<td>isThreadSafe</td>
<td>true、false</td>
<td>是否线程安全，如果为true，则运行多个线程同时运行该jsp程序，否则只运行一个线程，其余线程等待，默认为false</td>
</tr>
<tr>
<td>isErrorPage</td>
<td>true、false</td>
<td>指定该页面是否为错误显示页面，如果为true，则该JSP内置有一个Exception对象exception，可直接使用，否则没有，默认为false</td>
</tr>
<tr>
<td>errorPage</td>
<td>某个JSP页面的相对路径</td>
<td>指明一个错误页面，如果该JSP程序抛出一个未捕捉的异常，则转到errorPage指定的页面，errorPage指定的页面通</td>
</tr>
<tr>
<td>contentType</td>
<td>有效的文档类型</td>
<td>客户端浏览器根据该属性判断文档类型，例如 HTML格式为text/html、纯文本格式为text/plain、JPG图像为image/jpeg、GIF图像为image/gifWORD文档为application/msword，该属性常跟着charset设置编码一起，作用是通知服务器和浏览器都使用同一个码表</td>
</tr>
<tr>
<td>contentType</td>
<td>UTF-8,ISO-8859-</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="include指令">include指令</h2>
<p>JSP可以通过include指令来包含其他文件。被包含的文件可以是JSP文件、HTML文件或文本文件。包含的文件就好像是该JSP文件的一部分，会被同时编译执行。</p>
<pre><code class="language-java">Include指令的语法格式如下：
   &lt;%@ include file=&quot;文件相对 url 地址&quot; %&gt; 
</code></pre>
<p>include 指令中的文件名实际上是一个相对的 URL 地址。<br>
如果您没有给文件关联一个路径，JSP编译器默认在当前路径下寻找。</p>
<h2 id="taglib指令">Taglib指令</h2>
<p>JSP API允许<strong>用户自定义标签</strong>，一个自定义标签库就是自定义标签的集合。<br>
Taglib指令引入一个自定义标签集合的定义，包括库路径、自定义标签。</p>
<pre><code class="language-java">&lt;%@ taglib uri=&quot;uri&quot; prefix=&quot;&quot; %&gt;
uri属性确定标签库的位置，prefix属性指定标签库的前缀(可自定义)
</code></pre>
<h1 id="jsp出现的状态码">JSP出现的状态码</h1>
<figure data-type="image" tabindex="1"><img src="https://Vinci-Ma.github.io/post-images/1597417114112.png" alt="" loading="lazy"></figure>
<h1 id="el表达式常用">EL表达式【常用】</h1>
<p>EL表达式定义：Expression Language，表示语言，只负责取值</p>
<p>EL表达式语法：</p>
<ul>
<li>语法格式：<strong>${需要展示信息的名字}</strong></li>
<li>语法（想要跳过默认顺序获取时）: <strong>${requestScope.key}</strong></li>
</ul>
<p><strong><mark>注意：</mark></strong></p>
<p>当表达式没有指定变量或者对象的范围时，</p>
<p>那么容器会依次从pageContext—&gt;request—&gt;session—&gt;application中查找该变量或对象,我们可以通过隐含对象获得指定作用域的值:</p>
<p>pageScope对象，用于获取当前页面的属性值<br>
requestScope对象，用于获取请求范围的属性值<br>
sessionScope对象，用于获取会话范围的属性值<br>
applicationScope对象，用于获取程序范围的属性值</p>
<p><strong>EL中基础操作符：</strong><br>
<img src="https://Vinci-Ma.github.io/post-images/1597417100590.png" alt="" loading="lazy"></p>
<h1 id="jstl">JSTL</h1>
<h2 id="简介">简介：</h2>
<p>JSP标准标签库（JSTL）是一个JSP标签集合，它封装了JSP应用的通用核心功能。</p>
<p>JSTL支持通用的、结构化的任务，比如迭代，条件判断，XML文档操作，国际化标签，SQL标签。 除了这些，它还提供了一个框架来使用集成JSTL的自定义标签。</p>
<p>根据JSTL标签所提供的功能，可以将其分为5个类别。核心标签 格式化标签 sql标签 xml标签 jstl函数。</p>
<h2 id="jatl的作用和语法格式">JATL的作用和语法格式</h2>
<p><strong>作用：简化jsp页面编写代码</strong></p>
<p>语法格式：1、配置standard.jar 和 jstl.jar 到 /WEB-INF/lib/ 下</p>
<p>2、在JSP页面中引入&lt;%@ taglib prefix=”页面使用的名称” uri=”功能范围的路径”%&gt;</p>
<table>
<thead>
<tr>
<th>功能范围</th>
<th>url</th>
<th>前缀</th>
</tr>
</thead>
<tbody>
<tr>
<td>core</td>
<td>http://java.sun.com/jsp/jstl/core</td>
<td>c</td>
</tr>
<tr>
<td>i18n</td>
<td>http://java.sun.com/jsp/jstl/fmt</td>
<td>fmt</td>
</tr>
<tr>
<td>sql</td>
<td>http://java.sun.com/jsp/jstl/sql</td>
<td>sql</td>
</tr>
<tr>
<td>xml</td>
<td>http://java.sun.com/jsp/jstl/xml</td>
<td>x</td>
</tr>
<tr>
<td>functions</td>
<td>http://java.sun.com/jsp/jstl/function</td>
<td>fn</td>
</tr>
</tbody>
</table>
<h2 id="核心标签">核心标签</h2>
<p>核心标签是最常用的 JSTL标签。引用核心标签库的语法如下：</p>
<pre><code class="language-java">&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;
</code></pre>
<p>核心标签的分类：</p>
<p>表达式操作 ：out、set、remove、catch</p>
<p>流程控制 ：if、choose、when、otherwise</p>
<p>迭代操作： forEach、forTokens</p>
<p>URL操作： import、param、url、redirect</p>
<p><strong>Set标签</strong><br>
<img src="https://Vinci-Ma.github.io/post-images/1597417065005.png" alt="" loading="lazy"><br>
<img src="https://Vinci-Ma.github.io/post-images/1597417073508.png" alt="" loading="lazy"></p>
<h2 id="格式化标签">格式化标签</h2>
<p><strong>1、fmt:formatDate 作用：将日期类型格式化为指定模式的字符串</strong></p>
<p>属性</p>
<p>value：将要被格式化的数据</p>
<p>pattern：格式化的模式，与SimpleDateFormat的参数设置一样</p>
<p>var：格式化后的字符串所要存放的变量，若不指定var，则会将格式化的结果直接显示在页面</p>
<p>scope：变量存放的域属性空间，默认page</p>
<p>type：其取值为date、time、both，表示给出的value是日期、时间、还是两者都包含，默认是date</p>
<p><strong>2、fmt:parseDate 作用：用于将指定字符串转化为日期类型</strong></p>
<p>&lt;fmt:parseDate value=&quot;$(now)&quot; pattern=&quot;yyyy-MM-dd&quot; var=&quot;today&quot;/&gt;</p>
<p>Value：服务器获取的时间</p>
<p>Pattern：转换的格式</p>
<p>Var：页面显示的变量</p>
<p><strong>3、fmt:formatNumber 按照指定格式对数字进行格式化</strong></p>
<p>属性</p>
<p>maxIntegerDigits：整数部分最多的位数</p>
<p>minIntegerDigits：整数部分最少的位数</p>
<p>maxFrctionDigits：小数部分最多的位数</p>
<p>minFrctionDigits：小数部分最少的位数</p>
<p>var：存储格式化结果的变量</p>
<p>scope：var属性的作用域</p>
<p>integerOnly：是否只解析整型数true或者浮点数false</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Servlet学习]]></title>
        <id>https://Vinci-Ma.github.io/post/servlet-xue-xi/</id>
        <link href="https://Vinci-Ma.github.io/post/servlet-xue-xi/">
        </link>
        <updated>2020-08-14T14:54:35.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#servlet%E4%BB%8B%E7%BB%8D">Servlet介绍</a></li>
<li><a href="#servlet-api">Servlet API</a></li>
<li><a href="#servlet%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">Servlet工作原理</a></li>
<li><a href="#servlet%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">Servlet的生命周期</a></li>
<li><a href="#%E8%AF%B7%E6%B1%82">请求</a>
<ul>
<li><a href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95">常用方法</a></li>
</ul>
</li>
<li><a href="#%E5%93%8D%E5%BA%94">响应</a></li>
<li><a href="#%E4%BC%9A%E8%AF%9D">会话</a></li>
<li><a href="#%E8%8E%B7%E5%BE%97%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%82%E6%95%B0">获得初始化参数</a></li>
<li><a href="#servlet30">servlet3.0</a></li>
</ul>
</p>
<h1 id="servlet介绍">Servlet介绍</h1>
<ul>
<li>
<p>1、Servlet（Server Applet），全称Java Servlet。==是用Java编写的服务器端程序，其主要功能在于交互式地浏览和修改数据，生成动态Web内容。==狭义的Servlet是指Java语言实现的一个接口，广义的Servlet是指任何实现了这个Servlet接口的类，一般情况下，人们将Servlet理解为后者。</p>
</li>
<li>
<p>2、 Servlet运行于支持Java的应用服务器中。从实现上讲，Servlet可以响应任何类型的请求，但绝大多数情况下Servlet只用来<mark>扩展基于HTTP协议的Web服务器</mark>。</p>
</li>
<li>
<p>3、Servlet工作模式：</p>
<ul>
<li>客户端发送请求至服务器。</li>
<li>服务器启动大概并调用Servlet，Servlet根据客户端请求生成响应内容并将其传给服务器。</li>
<li>服务器将响应并返回客户端。</li>
</ul>
</li>
</ul>
<h1 id="servlet-api">Servlet API</h1>
<ul>
<li>javax.serv letinterface Servlet
<ul>
<li>1.init()</li>
<li>2.service()</li>
<li>3.destroy()</li>
<li>4.getServletConfig()</li>
<li>5.getServletInfo()</li>
</ul>
</li>
<li>javax.servlet abstract GenericServlet（除了实现或继承Servlet接口中的五个方法外还提供了额外方法）
<ul>
<li>1.getInitParameter()</li>
<li>2.getServletName()</li>
<li>3.getServletContext()</li>
</ul>
</li>
<li>javax.servlet.http abstract HttpServlet（重载service()方法）
<ul>
<li>1.doGet()</li>
<li>2.doPost()</li>
</ul>
</li>
</ul>
<h1 id="servlet工作原理">Servlet工作原理</h1>
<p>(1) Servlet接口定义了Servlet与servlet容器之间的契约。这个契约是：Servlet容器将Servlet类载入内存，并产生<br>
Servlet实例和调用它具体的方法。但是要注意的是，在一个应用程序中，每种Servlet类型只能有一个实例。<br>
(2)用户请求致使Servlet容器调用Servlet的Service（）方法，并传入一个ServletRequest对象和一个<br>
ServletResponse对象。ServletRequest对象和ServletResponse对象都是由Servlet容器（例如TomCat）封<br>
装好的，并不需要程序员去实现，程序员可以直接使用这两个对象。<br>
(3)ServletRequest中封装了当前的Http请求，因此，开发人员不必解析和操作原始的Http数据。ServletResponse<br>
表示当前用户的Http响应，程序员只需直接操作ServletResponse对象就能把响应轻松的发回给用户。<br>
(4)对于每一个应用程序，Servlet容器还会创建一个ServletContext对象。这个对象中封装了上下文（应用程序）<br>
的环境详情。每个应用程序只有一个ServletContext。每个Servlet对象也都有一个封装Servlet配置的<br>
ServletConfig对象。</p>
<h1 id="servlet的生命周期">Servlet的生命周期</h1>
<p>当客户端首次发送第一次请求后，由容器(web服务器(tomcat))去解析请求, 根据请求找到对应的servlet,判断该类的对象是否存在，不存在则创建servlet实例，调取init()方法 进行初始化操作,初始化完成后调取service()方法,由service()判断客户端的请求方式，如果是get，则执行doGet(),如果是post则执行doPost().处理方法完成后,作出相应结果给客户端.单次请求处理完毕。<br>
当用户发送第二次以后的请求时,会判断对象是否存在,但是不再执行init()，而直接执行service方法,调取doGet()/doPost()方法。<br>
当服务器关闭时调取destroy()方法进行销毁。<br>
四个过程:<br>
(1)实例化 --先创建servlet实例<br>
(2)初始化 --init()<br>
(3)处理请求 ---service()<br>
(4)服务终止 --destory()</p>
<h1 id="请求">请求</h1>
<p>HttpServletRequest表示Http环境中的Servlet请求。它扩展于javax.servlet.ServletRequest接口)</p>
<h2 id="常用方法">常用方法</h2>
<ul>
<li>1、String getParameter(String name) 根据表单组件名称获取提交数据，返回值是String<br>
注：服务器在接收数据时使用字符串统一接收</li>
<li>2、String[ ] getParameterValues(String name) 获取表单组件对应多个值时的请求数据</li>
<li>3、void setCharacterEncoding(String charset) 指定每个请求的编码(针对post请求才起作用)</li>
<li>4、RequestDispatcher getRequestDispatcher(String path) --跳转页面</li>
</ul>
<p>返回一个RequestDispatcher对象，该对象的forward( )方法用于转发请求</p>
<pre><code class="language-java">示例：request.getRequestDispatcher(&quot;../success.jsp&quot;).forward(request,response);
</code></pre>
<ul>
<li>5、存值 request.setAttribute(&quot;key&quot;,value);</li>
<li>6、取值 request.getAttribute(&quot;key&quot;);//取值后需要向下转型</li>
</ul>
<h1 id="响应">响应</h1>
<p>在Service API中，定义了一个HttpServletResponse接口，它继承自ServletResponse接口，专门用来封装HTTP响应消息。 在HttpServletResponse接口中定义了向客户端发送响应状态码，响应消息头，响应消息体的方法。</p>
<p><strong>常用方法：</strong></p>
<p>void addCookie(Cookie var1)：给这个响应添加一个cookie</p>
<p>void sendRedirect(String var1) ：发送一条响应码，将浏览器跳转到指定的位置</p>
<p>PrintWriter getWriter() ：获得字符流，通过字符流的write(String s)方法可以将字符串设置到response 缓冲区中，随后Tomcat会将response缓冲区中的内容组装成Http响应返回给浏览器端。</p>
<p>setContentType() ：设置响应内容的类型。</p>
<p><strong>重定向和转发的对比：</strong></p>
<p>重定向:response.sendRedirect()</p>
<p>转发:request.getRequestDispatcher(&quot;../success.jsp&quot;).forward(request,response);</p>
<p>相同点:都用来跳转页面。</p>
<p>不同点:</p>
<ul>
<li>重定向时地址栏会改变,request中存储的数据会丢失.转发时地址栏显示的是请求页面的地址,request数据可以保存。</li>
<li>转发属于一次请求一次响应,重定向属于两次请求(地址栏修改了两次)两次响应。</li>
</ul>
<p>补充:使用out对象往页面中输出js或html,css</p>
<pre><code class="language-java">out.print(&quot;&lt;script type='text/javascript'&gt;alert('登录失败');location='../login.jsp'&lt;/script&gt;&quot;);
</code></pre>
<p>注:使用js跳转页面，也会丢失request中的数据</p>
<h1 id="会话">会话</h1>
<p>**会话（session）的概念:**从打开浏览器到关闭浏览器,期间访问服务器就称为一次会话</p>
<p><strong>request &amp; session区别和联系：</strong></p>
<ul>
<li>
<p>request存的值只能在单次请求中保存，保存的数据不能跨页面,当重定向时,request存的值会丢失。</p>
</li>
<li>
<p>session的数据可以在多个页面中共享,即使重定向页面,数据不会丢失。</p>
</li>
<li>
<p>session中可以包含n个request。</p>
</li>
</ul>
<p><strong>常用方法：</strong></p>
<ul>
<li>
<p>void setAttribute(String key,Object value) ：以key/value的形式保存对象值,将数据存储在服务器端</p>
</li>
<li>
<p>Object getAttribute(String key) ：通过key获取对象值</p>
</li>
<li>
<p>void invalidate() ：设置session对象失效</p>
</li>
<li>
<p>String getId() ：获取sessionid,当第一次登录成功后，session会产生一个唯一的id，浏览器之后访问时如果发现id值还是之前id，那么说明当前访问的属于同一个会话</p>
</li>
<li>
<p>void setMaxInactiveInterval(int interval) ：设定session的非活动时间</p>
<ul>
<li>方式一：</li>
</ul>
<pre><code class="language-java">session.setMaxInactiveInterval(10*60);//设置有效时间为10分钟
</code></pre>
<ul>
<li>方式二：</li>
</ul>
<pre><code class="language-java">&lt;session-config&gt;
&lt;session-timeout&gt;10&lt;/session-timeout&gt;//单位:分钟
&lt;/session-config&gt;
</code></pre>
</li>
<li>
<p>int getMaxInactiveInterval() ：获取session的有效非活动时间(以秒为单位)，默认的有效时间:30分钟.</p>
</li>
<li>
<p>void removeAttribute(String key)：从session中删除指定名称(key)所对应的对象</p>
</li>
<li>
<p>小结 :让session失效的方式<br>
（1）invalidate() （2）removeAttribute(&quot;key&quot;) （3）直接关闭浏览器。<br>
示例:使用session验证用户是否登录<br>
补充:<br>
自动刷新到某页面:<br>
注:在head标签中添加该标签，单位:秒</p>
</li>
</ul>
<h1 id="获得初始化参数">获得初始化参数</h1>
<p>request.setCharacterEncoding(&quot;utf-8&quot;);代码的耦合度太高，不便于后期维护修改。可以通过初始化参数实现。</p>
<p><strong>实现方式:</strong></p>
<p><strong>一、方式一</strong>：</p>
<ul>
<li>1、web.xml中先定义初始化参数</li>
</ul>
<pre><code class="language-java">&lt;servlet&gt;
&lt;servlet-name&gt;&lt;/servlet-name&gt;
&lt;servlet-class&gt;&lt;/servlet-class&gt;
&lt;init-param&gt;
&lt;param-name&gt;encoding&lt;/param-name&gt;
&lt;param-value&gt;utf-8&lt;/param-value&gt;
&lt;/init-param&gt;
&lt;/servlet&gt;
</code></pre>
<ul>
<li>2、servlet中获得初始化参数，重写init()方法</li>
</ul>
<pre><code class="language-jav">public void init(ServletConfig config) throws ServletException {
encoding= config.getInitParameter(&quot;encoding&quot;);
}
</code></pre>
<p>注意:这种方式的初始化参数仅限于当前servlet中使用。</p>
<p><strong>二、方式二全局初始化参数</strong></p>
<ul>
<li>1、定义，context-param是和servlet标签同级别</li>
</ul>
<pre><code class="language-java">&lt;context-param&gt;
&lt;param-name&gt;bianma&lt;/param-name&gt;
&lt;param-value&gt;utf-8&lt;/param-value&gt;
&lt;/context-param&gt;
</code></pre>
<h1 id="servlet30">servlet3.0</h1>
<p>从Servlet3.0开始，配置Servlet支持注解方式，但还是保留了配置web.xml方式，所有使用Servlet有两种方式：</p>
<p>（1）Servlet类上使用@WebServlet注解进行配置</p>
<p>（2）web.xml文件中配置<br>
<img src="https://Vinci-Ma.github.io/post-images/1597416954401.png" alt="" loading="lazy"></p>
<p><mark>注意</mark></p>
<ul>
<li>.loadOnStartup属性：标记容器是否在启动应用时就加载Servlet，默认不配置或数值为负数时表示客户端第一次请求Servlet时再加载；0或正数表示启动应用就加载，正数情况下，数值越小，加载该Servlet的优先级越高；</li>
</ul>
<pre><code class="language-java">@WebServlet(value=&quot;/test1&quot;,loadOnStartup=1)
</code></pre>
<ul>
<li>
<p>.name属性：可以指定也可以不指定，通过getServletName()可以获取到，若不指定，则为Servlet的完整类名，如：cn.edu.njit.servlet.UserServlet</p>
</li>
<li>
<p>.urlPatterns/value属性： String[]类型，可以配置多个映射，如：urlPatterns={&quot;/user/test&quot;, &quot;/user/example&quot;}</p>
</li>
<li>
<p>.在使用注解方式时，需要注意：<br>
根元素中不能配置属性metadata-complete=&quot;true&quot;，否则无法加载Servlet。metadata-complete属性表示通知<br>
Web容器是否寻找注解，默认不写或者设置false，容器会扫描注解，为Web应用程序构建有效的元数据；metadata-complete=&quot;true&quot;，会在启动时不扫描注解（annotation）。如果不扫描注解的话，用注解进行的配置就无法生效，例如：@WebServlet</p>
</li>
<li>
<p>.urlPatterns的常用规则：</p>
<ul>
<li>/*或者/：拦截所有</li>
<li>*.do：拦截指定后缀</li>
<li>/user/test：拦截路径</li>
<li>/user/.do、/.do、test*.do都是非法的，启动时候会报错</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[AJAX学习]]></title>
        <id>https://Vinci-Ma.github.io/post/ajax-xue-xi/</id>
        <link href="https://Vinci-Ma.github.io/post/ajax-xue-xi/">
        </link>
        <updated>2020-08-14T14:49:10.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#ajax%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%8E%9F%E7%90%86">Ajax技术与原理</a>
<ul>
<li><a href="#1-ajax%E7%AE%80%E4%BB%8B">1、Ajax简介</a></li>
<li><a href="#2-ajax%E6%89%80%E5%8C%85%E5%90%AB%E7%9A%84%E6%8A%80%E6%9C%AF">2、Ajax所包含的技术</a></li>
<li><a href="#3-ajax%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">3、Ajax的工作原理</a>
<ul>
<li><a href="#1-%E6%A8%A1%E5%9E%8B">1、模型</a></li>
<li><a href="#2-%E4%BA%A4%E4%BA%92%E6%96%B9%E5%BC%8F">2、交互方式</a></li>
</ul>
</li>
<li><a href="#4-xmlhttprequest%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7">4、XMLHttpRequest常用属性</a>
<ul>
<li><a href="#1-onreadystatechange-%E5%B1%9E%E6%80%A7%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0">1、onreadystatechange 属性（回调函数）</a></li>
<li><a href="#2-readystate-%E5%B1%9E%E6%80%A7">2、readyState 属性</a></li>
<li><a href="#3-responsetext-%E5%B1%9E%E6%80%A7">3、responseText 属性</a></li>
</ul>
</li>
<li><a href="#5-xmlhttprequest%E6%96%B9%E6%B3%95">5、XMLHttpRequest方法</a>
<ul>
<li><a href="#1-open-%E6%96%B9%E6%B3%95">1、open() 方法</a></li>
<li><a href="#2-send-%E6%96%B9%E6%B3%95">2、send() 方法</a></li>
<li><a href="#3-%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95">3、其他方法</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#ajax%E7%BC%96%E7%A8%8B%E6%AD%A5%E9%AA%A4%E5%9F%BA%E4%BA%8Ejs%E5%AE%9E%E7%8E%B0ajax">Ajax编程步骤（基于js实现ajax）</a>
<ul>
<li><a href="#1-%E5%88%9B%E5%BB%BAxmlhttprequest%E5%AF%B9%E8%B1%A1">1、创建XMLHttpRequest对象</a></li>
<li><a href="#2-%E8%AE%BE%E7%BD%AE%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F">2、设置请求方式</a></li>
<li><a href="#3-%E8%B0%83%E7%94%A8%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0">3、调用回调函数</a></li>
<li><a href="#4-%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82">4、发送请求</a></li>
</ul>
</li>
<li><a href="#jquery%E7%9A%84ajax%E6%93%8D%E4%BD%9C">jquery的ajax操作*</a><br>
*
<ul>
<li><a href="#1-%E4%BC%A0%E7%BB%9F%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0ajax%E7%9A%84%E4%B8%8D%E8%B6%B3">1、传统方式实现Ajax的不足</a></li>
<li><a href="#2-ajax%E6%96%B9%E6%B3%95">2、ajax()方法</a></li>
<li><a href="#3-get-%E6%96%B9%E6%B3%95%E9%80%9A%E8%BF%87%E8%BF%9C%E7%A8%8B-http-get-%E8%AF%B7%E6%B1%82%E8%BD%BD%E5%85%A5%E4%BF%A1%E6%81%AF">3、get() 方法通过远程 HTTP GET 请求载入信息</a></li>
<li><a href="#4-post-%E6%96%B9%E6%B3%95%E9%80%9A%E8%BF%87%E8%BF%9C%E7%A8%8B-http-get-%E8%AF%B7%E6%B1%82%E8%BD%BD%E5%85%A5%E4%BF%A1%E6%81%AF">4、post() 方法通过远程 HTTP GET 请求载入信息</a></li>
</ul>
</li>
<li><a href="#json">JSON</a>
<ul>
<li><a href="#1-json%E6%A6%82%E5%BF%B5">1、JSON概念</a></li>
<li><a href="#2-json%E5%AF%B9%E8%B1%A1%E5%AE%9A%E4%B9%89%E5%92%8C%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8">2、JSON对象定义和基本使用</a>
<ul>
<li><a href="#1-%E5%AE%9A%E4%B9%89">1、定义</a></li>
<li><a href="#2-json%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE">2、JSON对象的访问</a></li>
</ul>
</li>
<li><a href="#3-json%E5%9C%A8java%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8">3、JSON在java中的使用*</a>
<ul>
<li><a href="#java%E5%AF%B9%E8%B1%A1%E5%92%8Cjson%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2">java对象和json之间的转换</a>
<ul>
<li><a href="#1-%E5%8D%95%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%88%96map%E9%9B%86%E5%90%88">1、单个对象或map集合</a></li>
<li><a href="#2-%E5%AF%B9%E8%B1%A1%E9%9B%86%E5%90%88%E5%92%8Cjson%E7%9A%84%E8%BD%AC%E6%8D%A2">2、对象集合和json的转换</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<h1 id="ajax技术与原理">Ajax技术与原理</h1>
<h2 id="1-ajax简介">1、Ajax简介</h2>
<p>AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。</p>
<p>AJAX 不是新的编程语言，而是一种使用现有标准的新方法。</p>
<p>AJAX 是与服务器交换数据并更新部分网页的艺术，在不重新加载整个页面的情况下。</p>
<h2 id="2-ajax所包含的技术">2、Ajax所包含的技术</h2>
<p>Ajax并非一种新的技术，而是几种原有技术的结合体。它由下列技术组合而成。</p>
<pre><code class="language-java">1.使用CSS和XHTML来表示。
2.使用DOM模型来交互和动态显示。
3.使用XMLHttpRequest来和服务器进行异步通信。
4.使用javascript来绑定和调用。
</code></pre>
<p>AJAX 的核心是 XMLHttpRequest 对象</p>
<p>不同的浏览器创建 XMLHttpRequest 对象的方法是有差异的。</p>
<p><strong>IE 浏览器使用 ActiveXObject，而其他的浏览器使用名为 XMLHttpRequest 的 JavaScript 内建对象</strong></p>
<h2 id="3-ajax的工作原理">3、Ajax的工作原理</h2>
<p>Ajax的工作原理相当于在用户和服务器之间加了—个<strong>中间层(AJAX引擎)</strong>，使用户操作与服务器响应<strong>异步化</strong>。</p>
<p>并不是所有的用户请求都提交给服务器。像—些数据验证和数据处理等都交给Ajax引擎自己来做,，只有确定需要从服务器读取新数据时再由Ajax引擎代为向服务器提交请求。</p>
<p><strong>两者区别：</strong></p>
<h3 id="1-模型">1、模型</h3>
<p>1、传统的Web模型<br>
<img src="https://Vinci-Ma.github.io/post-images/1597416658095.png" alt="" loading="lazy"><br>
2、Ajax模型<br>
<img src="https://Vinci-Ma.github.io/post-images/1597416689051.png" alt="" loading="lazy"></p>
<h3 id="2-交互方式">2、交互方式</h3>
<p>1、浏览器的普通交互方式</p>
<figure data-type="image" tabindex="1"><img src="https://Vinci-Ma.github.io/post-images/1597416712107.jpg" alt="" loading="lazy"></figure>
<p>2、浏览器的Ajax交互方式</p>
<figure data-type="image" tabindex="2"><img src="https://Vinci-Ma.github.io/post-images/1597416723665.jpg" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://Vinci-Ma.github.io/post-images/1597416744223.png" alt="" loading="lazy"></figure>
<h2 id="4-xmlhttprequest常用属性">4、XMLHttpRequest常用属性</h2>
<h3 id="1-onreadystatechange-属性回调函数">1、onreadystatechange 属性（回调函数）</h3>
<p>onreadystatechange 属性存有处理服务器响应的函数。 下面的代码定义一个空的函数，可同时对onreadystatechange 属性进行设置：</p>
<pre><code class="language-java">xmlHttp.onreadystatechange = function() { //我们需要在这写一些代码}
</code></pre>
<h3 id="2-readystate-属性">2、readyState 属性</h3>
<p>readyState 属性<strong>存有服务器响应的状态信息</strong>。每当 readyState 改变时，onreadystatechange 函数就会被执行。<br>
readyState 属性可能的值：</p>
<h3 id="3-responsetext-属性">3、responseText 属性</h3>
<p>可以通过 responseText 属性来取回由服务器返回的数据。 在我们的代码中，我们将把时间文本框的值设置为等于responseText：</p>
<pre><code class="language-java">xmlHttp.onreadystatechange = function() {
if (xmlHttp.readyState == 4) {
document.myForm.time.value = xmlHttp.responseText;
}
}
</code></pre>
<h2 id="5-xmlhttprequest方法">5、XMLHttpRequest方法</h2>
<h3 id="1-open-方法">1、open() 方法</h3>
<p>open() 有三个参数。第一个参数定义发送请求所使用的方法，第二个参数规定服务器端脚本的URL，第三个参数规定应当对请求进行异步地处理。</p>
<pre><code class="language-java">xmlHttp.open(&quot;GET&quot;,&quot;test.php&quot;,true);
</code></pre>
<h3 id="2-send-方法">2、send() 方法</h3>
<p>send() 方法将请求送往服务器。如果我们假设 HTML 文件和 PHP 文件位于相同的目录，那么代码是这样的：</p>
<pre><code class="language-java">xmlHttp.send(null);
</code></pre>
<h3 id="3-其他方法">3、其他方法</h3>
<figure data-type="image" tabindex="4"><img src="https://Vinci-Ma.github.io/post-images/1597416761579.png" alt="" loading="lazy"></figure>
<h1 id="ajax编程步骤基于js实现ajax">Ajax编程步骤（基于js实现ajax）</h1>
<pre><code class="language-java">1. 创建XMLHttpRequest对象。
2. 设置请求方式。
3. 调用回调函数。
4. 发送请求。
</code></pre>
<h2 id="1-创建xmlhttprequest对象">1、创建XMLHttpRequest对象</h2>
<pre><code class="language-java">var xmlHttp=new XMLHttpRequest();
如果是IE5或者IE6浏览器，则使用ActiveX对象，创建方法是：
var xmlHttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
一般我们手写AJAX的时候，首先要判断该浏览器是否支持XMLHttpRequest对象，如果支持则创建该对象，如果不支持则创建ActiveX对象。JS代码如下：
    //第一步：创建XMLHttpRequest对象
var xmlHttp;
if (window.XMLHttpRequest) {
    //非IE
    xmlHttp = new XMLHttpRequest();
} else if (window.ActiveXObject) {
    //IE
    xmlHttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;)
}
</code></pre>
<h2 id="2-设置请求方式">2、设置请求方式</h2>
<pre><code class="language-java">//第二步：设置和服务器端交互的相应参数，向路径http://localhost:8080/JsLearning3/getAjax准备发送数据
var url = &quot;http://localhost:8080/JsLearning3/getAjax&quot;;
xmlHttp.open(&quot;POST&quot;, url, true);
</code></pre>
<h2 id="3-调用回调函数">3、调用回调函数</h2>
<pre><code class="language-java">//第三步：注册回调函数
xmlHttp.onreadystatechange = function() {
    //判断状态
    if (xmlHttp.readyState == 4) {
        //接收返回的内容
        if (xmlHttp.status == 200) {
            var obj = document.getElementById(id);
            obj.innerHTML = xmlHttp.responseText;
        } else {
        	alert(&quot;AJAX服务器返回错误！&quot;);
        }
    }
}
</code></pre>
<h2 id="4-发送请求">4、发送请求</h2>
<pre><code class="language-java">//第四步：设置发送请求的内容和发送报送。然后发送请求
var uname= document.getElementsByName(&quot;userName&quot;)[0].value;
var upass= document.getElementsByName(&quot;userPass&quot;)[0].value ;
var params = &quot;userName=&quot; + uname+ &quot;&amp;userPass=&quot; +upass+ &quot;&amp;time=&quot; + Math.random();
// 增加time随机参数，防止读取缓存
xmlHttp.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded;charset=UTF-8&quot;);

// 向请求添加 HTTP 头，POST如果有数据一定加加！！！！
xmlHttp.send(params);
</code></pre>
<h1 id="jquery的ajax操作">jquery的ajax操作*</h1>
<h3 id="1-传统方式实现ajax的不足">1、传统方式实现Ajax的不足</h3>
<p>步骤繁琐，方法、属性、常用值较多不好记忆</p>
<h3 id="2-ajax方法">2、ajax()方法</h3>
<p>可以通过发送 HTTP请求加载远程数据，是 jQuery 最底层的 Ajax 实现，具有较高灵活性。</p>
<p>$.ajax([settings]);//参数settings是方法的参数列表，用于配置Ajax请求的键值对集合；</p>
<pre><code class="language-java">$.ajax({
    url:请求地址
    type:&quot;get | post | put | delete &quot; 默认是get,
    data:请求参数 {&quot;id&quot;:&quot;123&quot;,&quot;pwd&quot;:&quot;123456&quot;},
    dataType:请求数据类型&quot;html | text | json | xml | script | jsonp &quot;,
    success:function(data,dataTextStatus,jqxhr){ },//请求成功时
error:function(jqxhr,textStatus,error)//请求失败时
})
</code></pre>
<h3 id="3-get-方法通过远程-http-get-请求载入信息">3、get() 方法通过远程 HTTP GET 请求载入信息</h3>
<p>这是一个简单的 GET 请求功能以取代复杂 $.ajax</p>
<pre><code class="language-java">$.get(url,data,function(result) {
//省略将服务器返回的数据显示到页面的代码
});
url:请求的路径
data:发送的数据
success:成功函数
datatype 返回的数据
</code></pre>
<h3 id="4-post-方法通过远程-http-get-请求载入信息">4、post() 方法通过远程 HTTP GET 请求载入信息</h3>
<pre><code class="language-java">$.post(url,data,function(result) {
//省略将服务器返回的数据显示到页面的代码
});
url:请求的路径
data:发送的数据
success:成功函数
datatype 返回的数据
</code></pre>
<h1 id="json">JSON</h1>
<h2 id="1-json概念">1、JSON概念</h2>
<p>JSON (JavaScript Object Notation) 是一种轻量级的数据交换格式。 易于人阅读和编写。同时也易于机器解析和生成。</p>
<h2 id="2-json对象定义和基本使用">2、JSON对象定义和基本使用</h2>
<h3 id="1-定义">1、定义</h3>
<pre><code class="language-java">var 变量名 = {
“key” : value , // Number类型
“key2” : “value” , // 字符串类型
“key3” : [] , // 数组类型
“key4” : {}, // json 对象类型
“key5” : [{},{}] // json 数组
};
</code></pre>
<h3 id="2-json对象的访问">2、JSON对象的访问</h3>
<p>son对象，顾名思义，就知道它是一个对象。里面的key就是对象的属性。我们要访问一个对象的属性，只需要使用【对象名.属性名】的方式访问即可</p>
<pre><code class="language-java">&lt;script type=&quot;text/javascript&quot;&gt;
// json的定义
var jsons = {
&quot;key1&quot;:&quot;abc&quot;, // 字符串类型
&quot;key2&quot;:1234, // Number
&quot;key3&quot;:[1234,&quot;21341&quot;,&quot;53&quot;], // 数组
&quot;key4&quot;:{ // json类型
    &quot;key4_1&quot; : 12,
    &quot;key4_2&quot; : &quot;kkk&quot;
    },
&quot;key5&quot;:[{ // json数组
    &quot;key5_1_1&quot; : 12,
    &quot;key5_1_2&quot; : &quot;abc&quot;
    },{
        &quot;key5_2_1&quot; : 41,
            &quot;key5_2_2&quot; : &quot;bbj&quot;
        }]
};
// 访问json的属性
alert(jsons.key1); // &quot;abc&quot;
// 访问json的数组属性
alert(jsons.key3[1]); // &quot;21341&quot;
// 访问json的json属性
alert(jsons.key4.key4_1);//12
// 访问json的json数组
alert(jsons.key5[0].key5_1_2);//&quot;abc&quot;
&lt;/script&gt;
</code></pre>
<h2 id="3-json在java中的使用">3、JSON在java中的使用*</h2>
<figure data-type="image" tabindex="5"><img src="https://Vinci-Ma.github.io/post-images/1597416788349.png" alt="" loading="lazy"></figure>
<h3 id="java对象和json之间的转换">java对象和json之间的转换</h3>
<h4 id="1-单个对象或map集合">1、单个对象或map集合</h4>
<pre><code class="language-java">java-&gt;json：
    Users user2=new Users();
    user2.setUsername(&quot;李四&quot;);
    user2.setPassword(&quot;abc&quot;);
    user2.setAge(20);
    JSONObject obj=JSONObject.fromObject(user);//obj就是json格式的

json-&gt;java
    String str=&quot;{'username':'李四','password':'admin','age':19}&quot;;
    JSONObject json=JSONObject.fromObject(str);
    Users user=(Users)JSONObject.toBean(json,Users.class);
</code></pre>
<h4 id="2-对象集合和json的转换">2、对象集合和json的转换</h4>
<pre><code class="language-java">java集合-&gt;json数组:
    List list=new ArrayList();
    list.add(&quot;dd&quot;);
    list.add(&quot;aa&quot;);
    JSONArray obj=JSONArray.fromObject(list);//set也是这么转
json数组-&gt;java集合:
	Key1:
	String str2=&quot;[{'age':20,'password':'abc','username':'李四'},{'age':10,'password':'adb','username':'张三'}]&quot;;
	JSONArray json2=JSONArray.fromObject(str2);
	Object[] obj=(Object[])JSONArray.toArray(json2,Users.class);

	Key2:
	String str3=&quot;[{'age':20,'password':'abc','username':'李四'},{'age':10,'password':'adb','username':'展示干'}]&quot;;
	JSONArray json3=JSONArray.fromObject(str3);
	//默认转换成ArrayList
	List&lt;Users&gt; list=(List&lt;Users&gt;) 				JSONArray.toCollection(json3,Users.class);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MVC学习]]></title>
        <id>https://Vinci-Ma.github.io/post/mvc-xue-xi/</id>
        <link href="https://Vinci-Ma.github.io/post/mvc-xue-xi/">
        </link>
        <updated>2020-08-14T14:44:15.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#mvc">MVC</a>
<ul>
<li><a href="#1mvc%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">1.MVC设计模式</a></li>
<li><a href="#2%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84%E5%86%99%E4%BB%A3%E7%A0%81%E6%97%B6%E9%9C%80%E8%A6%81%E9%81%B5%E5%BE%AA%E7%9A%84">2.三层架构（写代码时需要遵循的）</a></li>
<li><a href="#3%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84%E4%B8%8Emvc%E7%9A%84%E5%8C%BA%E5%88%AB">3.三层架构与MVC的区别</a></li>
</ul>
</li>
<li><a href="#%E4%B8%80%E8%88%AC%E7%9A%84%E5%8C%85%E7%BB%93%E6%9E%84">一般的包结构</a></li>
</ul>
</p>
<h1 id="mvc">MVC</h1>
<p>随着项目中代码的增多，需要一个模式去规范</p>
<h2 id="1mvc设计模式">1.MVC设计模式</h2>
<p>MVC中的M(模型)-V(视图)-C(控制器)概念和标准MVC概念一样</p>
<p>在Web MVC模式下，模型无法主动推数据给视图，如果用户想要视图更新，需要再发送一次请求（即请求-响应模型）。</p>
<figure data-type="image" tabindex="1"><img src="https://Vinci-Ma.github.io/post-images/1597416425620.jpeg" alt="" loading="lazy"></figure>
<p><strong>M(Model) 模型 :</strong> 应用程序的核心功能，管理这个模块中用的数据和值（bean,dao）；</p>
<pre><code class="language-java">JavaBeans :是Java中一种特殊的类（换言之：JavaBean就是一个Java类）.
一个Java类 ，满足以下要求，则可称为一个JavaBean
    a. public修饰的类，提供public 无参构造方法
    b. 所有属性 都是private
    C. 提供getter和setter方法
从使用层面来看，JavaBean分为2大类：
    a. 封装业务逻辑的JavaBean(eg:LoginDao.java 封装了登录逻辑)
    b. 封装数据的JavaBean(实体类：eg：Student.java Vadio.java 。往往对应于数据库中的一张表，即数据库中有个Student表，项目中就有个Student.java类)通常:表名=类名，列名=属性名
JavaBean是一个可以重复使用的组件，通过编写一个组件来实现某种通用功能，“一次编写、任何地方执行、任何地方重用”。
</code></pre>
<p><strong>V(View )视图：</strong><br>
视图提供模型的展示，管理模型如何显示给用户，它是应用程序的外观；（jsp/html）<br>
<strong>C(Controller)控制器：</strong><br>
对用户的输入做出反应，管理用户和视图的交互，是连接模型和视图的枢纽。（servlet/service）<br>
MVC用于将web（UI）层进行职责解耦</p>
<p><strong>MVC设计模式并不属于23种设计模式</strong></p>
<h2 id="2三层架构写代码时需要遵循的">2.三层架构（写代码时需要遵循的）</h2>
<p>三层架构，通常意义上的三层架构就是将整个业务应用划分为：表现层（UI）、业务逻辑层（BLL）、数据访问层（DAL）。区分层次的目的即为了“高内聚，低耦合”的思想。</p>
<p><strong>1、表现层（UI）：</strong><br>
通俗讲就是展现给用户的界面，即用户在使用一个系统的时候他的所见所得。 jsp/html</p>
<p>表现层实现的代表作品是Struts,springmvc框架</p>
<p><strong>2、业务逻辑层（BLL）：</strong><br>
针对具体问题的操作，也可以说是对数据层的操作，对数据业务逻辑处理。servlet,service</p>
<p>业务层实现的代表作品是Spring</p>
<p><strong>3、数据访问层（DAL）：</strong><br>
该层所做事务直接操作数据库，针对数据的增添、删除、修改、更新、查找等。dao</p>
<p>持久层实现的代表作品是Hibernate,mybatis。</p>
<p>层就相当于一个黑盒子，我们不用知道它内部怎么实现，只需要知道如何去调用它就行了。每层只与上下相邻的两层打交道。当一层内部由于技术变迁发生变化时，只要接口不变，其他层不用做任何改变。分层之后灵活性提高，也便于团队分工开发。</p>
<h2 id="3三层架构与mvc的区别">3.三层架构与MVC的区别</h2>
<figure data-type="image" tabindex="2"><img src="https://Vinci-Ma.github.io/post-images/1597416456532.png" alt="" loading="lazy"></figure>
<p>MVC是 Model-View-Controller，严格说这三个加起来以后才是三层架构中的UI层，也就是说，MVC把三层架构中的UI层再度进行了分化，分成了控制器、视图、实体三个部分，控制器完成页面逻辑，通过实体来与界面层完成通话；而C层直接与三层中的BLL进行对话。</p>
<p>MVC可以是三层中的一个表现层框架，属于表现层。三层和mvc可以共存。</p>
<p>三层是基于业务逻辑来分的，而MVC是基于页面来分的。</p>
<p>MVC主要用于表现层，3层主要用于体系架构，3层一般是表现层、中间层、数据层，其中表现层又可以分成M、V、C，(Model View Controller)模型－视图－控制器</p>
<p>MVC是表现模式（Presentation Pattern）</p>
<p>三层架构是典型的架构模式（Architecture Pattern）</p>
<p>三层架构的分层模式是典型的上下关系，上层依赖于下层。但MVC作为表现模式是不存在上下关系的，而是相互协作关系。即使将MVC当作架构模式，也不是分层模式。MVC和三层架构基本没有可比性，是应用于不同领域的技术。</p>
<h1 id="一般的包结构">一般的包结构</h1>
<p>src中【bean+dao=M（模型层）】</p>
<p>【Servlet调取Service，Service调取Dao，Dao调取数据库】</p>
<ul>
<li>
<p>com.~</p>
<ul>
<li>bean
<ul>
<li>student【创建一个对象类，表名=类名，列名=属性名】</li>
</ul>
</li>
<li>dao（操作数据库的接口）
<ul>
<li>StudentDao【接口，定义操作数据库的方法】</li>
<li>impl.StudentDaoImpl【操作数据库。1、继承德鲁伊，实现StudentDao，得到数据源，加载驱动】</li>
</ul>
</li>
<li>service（Servlet和dao的连接）
<ul>
<li>StudentService（接口，复制StudentDao）</li>
<li>impl.StudentServiceImpl【实现StudentService】</li>
</ul>
</li>
<li>util
<ul>
<li>DruidUtil【连接池】</li>
</ul>
</li>
<li>web
<ul>
<li>studentservlet【1、接收参数，2、调取service方法，3、跳转页面（需要存值）】</li>
</ul>
</li>
<li>druid.properties【德鲁伊】</li>
</ul>
<p>web中</p>
<ul>
<li>WEB-INF
<ul>
<li>lib【驱动包，需要配置环境】</li>
</ul>
</li>
<li>show.jsp【显示页面（需要取值）】</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Tomcat学习]]></title>
        <id>https://Vinci-Ma.github.io/post/tomcat-xue-xi/</id>
        <link href="https://Vinci-Ma.github.io/post/tomcat-xue-xi/">
        </link>
        <updated>2020-08-04T00:48:10.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#tomcat%E7%9A%84%E7%9B%AE%E5%BD%95">tomcat的目录</a>
<ul>
<li><a href="#1-bin">1、bin</a></li>
<li><a href="#2-conf">2、conf</a></li>
<li><a href="#3-lib">3、lib</a></li>
<li><a href="#4-logs">4、logs</a></li>
<li><a href="#5-temp">5、temp</a></li>
<li><a href="#6-webapps">6、webapps</a></li>
<li><a href="#7-work">7、work</a></li>
<li><a href="#8-license">8、LICENSE</a></li>
<li><a href="#9-notice">9、NOTICE</a></li>
<li><a href="#%E9%80%9A%E8%BF%87url%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E5%99%A8">通过url访问服务器:</a></li>
</ul>
</li>
</ul>
</p>
<h1 id="tomcat的目录">tomcat的目录</h1>
<h2 id="1-bin">1、bin</h2>
<p>该目录下存放的是二进制可执行文件，如果是安装版，那么这个目录下会有两个exe文件：tomcat9.exe、tomcat9w.exe，前者是在控制台下启动Tomcat，后者是弹出UGI窗口启动Tomcat；如果是解压版，那么会有startup.bat和shutdown.bat文件，startup.bat用来启动Tomcat，但需要JDK的配置，shutdown.bat用来停止Tomcat；</p>
<h2 id="2-conf">2、conf</h2>
<p>这是一个非常非常重要的目录，这个目录下有四个最为重要的文件：<br>
**server.xml：**配置整个服务器信息。例如修改端口号，添加虚拟主机等；<br>
**tomcat-users.xml：**存储tomcat用户的文件，这里保存的是tomcat的用户名及密码，以及用户的角色信息。可以<br>
按着该文件中的注释信息添加tomcat用户，然后就可以在Tomcat主页中进入Tomcat Manager页面了；<br>
**web.xml：**部署描述符文件，这个文件中注册了很多MIME类型，即文档类型。这些MIME类型是客户端与服务器之间说明文档类型的，如用户请求一个html网页，那么服务器还会告诉客户端浏览器响应的文档是text/html类型<br>
的，这就是一个MIME类型。客户端浏览器通过这个MIME类型就知道如何处理它了。当然是在浏览器中显示这个<br>
html文件了。但如果服务器响应的是一个exe文件，那么浏览器就不可能显示它，而是应该弹出下载窗口才对。<br>
MIME就是用来说明文档的内容是什么类型的！<br>
**context.xml：**对所有应用的统一配置，通常我们不会去配置它。</p>
<h2 id="3-lib">3、lib</h2>
<p>Tomcat的类库，里面是一大堆jar文件。如果需要添加Tomcat依赖的jar文件，可以把它放到这个目录中，<br>
当然也可以把应用依赖的jar文件放到这个目录中，这个目录中的jar所有项目都可以共享之，但这样你的应用放到<br>
其他Tomcat下时就不能再共享这个目录下的Jar包了，所以建议只把Tomcat需要的Jar包放到这个目录下；</p>
<h2 id="4-logs">4、logs</h2>
<p>这个目录中都是日志文件，记录了Tomcat启动和关闭的信息，如果启动Tomcat时有错误，那么异常也会<br>
记录在日志文件中。</p>
<h2 id="5-temp">5、temp</h2>
<p>存放Tomcat的临时文件，这个目录下的东西可以在停止Tomcat后删除！</p>
<h2 id="6-webapps">6、webapps</h2>
<p>存放web项目的目录，其中每个文件夹都是一个项目；如果这个目录下已经存在了目录，那么都是<br>
tomcat自带的项目。其中ROOT是一个特殊的项目，在地址栏中没有给出项目目录时，对应的就是ROOT项目。<br>
http://localhost:8080/examples，进入示例项目。其中examples就是项目名，即文件夹的名字。</p>
<h2 id="7-work">7、work</h2>
<p>运行时生成的文件，最终运行的文件都在这里。通过webapps中的项目生成的！可以把这个目录下的内<br>
容删除，再次运行时会生再次生成work目录。当客户端用户访问一个JSP文件时，Tomcat会通过JSP生成Java文<br>
件，然后再编译Java文件生成class文件，生成的java和class文件都会存放到这个目录下。</p>
<h2 id="8-license">8、LICENSE</h2>
<p>许可证</p>
<h2 id="9-notice">9、NOTICE</h2>
<p>说明文件</p>
<h2 id="通过url访问服务器">通过url访问服务器:</h2>
<p>url:http://服务器的ip地址:端口号/项目名/被访问的页面<br>
示例:http://localhost:8080/test0918<br>
注: (1)启动tomcat后,tomcat会加载部署在服务器端的所有项目<br>
(2) 浏览器访问的页面是服务器端的页面,基本上服务器的项目和工作空间的项目要保持一致</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MySQL高阶——表联结查询]]></title>
        <id>https://Vinci-Ma.github.io/post/mysql-gao-jie-biao-lian-jie-cha-xun/</id>
        <link href="https://Vinci-Ma.github.io/post/mysql-gao-jie-biao-lian-jie-cha-xun/">
        </link>
        <updated>2020-07-30T02:04:07.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E5%AD%90%E6%9F%A5%E8%AF%A2%E4%B8%8E%E8%A1%A8%E8%BF%9E%E6%8E%A5">子查询与表连接</a>
<ul>
<li><a href="#%E5%AD%90%E6%9F%A5%E8%AF%A2%E5%B5%8C%E5%A5%97sql">子查询（嵌套sql）</a></li>
<li><a href="#%E5%85%B3%E7%B3%BB%E8%A1%A8">关系表</a>
<ul>
<li><a href="#1-%E4%B8%80%E5%AF%B9%E4%B8%80%E5%85%B3%E7%B3%BB">1、一对一关系</a></li>
<li><a href="#2-%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%85%B3%E7%B3%BB%E4%BD%BF%E7%94%A8%E9%A2%91%E7%8E%87%E6%9C%80%E9%AB%98">2、一对多关系（使用频率最高）</a></li>
<li><a href="#3-%E5%A4%9A%E5%AF%B9%E5%A4%9A%E5%85%B3%E7%B3%BB">3、多对多关系</a></li>
</ul>
</li>
<li><a href="#%E8%A1%A8%E8%81%94%E7%BB%93">表联结</a>
<ul>
<li><a href="#%E4%B8%A4%E4%B8%AA%E8%A1%A8%E7%9B%B8%E8%81%94%E7%BB%93">两个表相联结</a></li>
<li><a href="#%E8%81%94%E7%BB%93%E5%A4%9A%E4%B8%AA%E8%A1%A8">联结多个表</a></li>
<li><a href="#%E8%87%AA%E8%81%94%E7%BB%93">自联结</a></li>
</ul>
</li>
<li><a href="#%E5%A4%96%E9%83%A8%E8%81%94%E7%BB%93">外部联结</a></li>
<li><a href="#%E6%80%BB%E7%BB%93%E8%A1%A8%E8%81%94%E7%BB%93">总结表联结</a></li>
<li><a href="#%E7%BB%84%E5%90%88%E6%9F%A5%E8%AF%A2union">组合查询UNION</a></li>
</ul>
</li>
</ul>
</p>
<h1 id="子查询与表连接">子查询与表连接</h1>
<h2 id="子查询嵌套sql">子查询（嵌套sql）</h2>
<h2 id="关系表">关系表</h2>
<p>SQL最强大的功能之一就是能在数据检索查询的执行中联结（join）表。<br>
关系表的设计就是要保证把信息分解成多个表，一类数据一个表。<br>
各表通过某些常用值（即关系设计中的关系（relational））相互关联。<br>
<strong>外键：</strong><br>
在一个表中，定义一个字段，这个字段中存储的数据是另外一张表中的主键就是在一个表中的字段，代表着这个数据属于谁。<br>
了解：<br>
外键实现的方式，有两种：物理外键、逻辑外键<br>
1、物理外键：<br>
就是在创建表时，就指定这个表中的字段是一个外键，并且强关联某个表中的某个字段，需要再定义字段时，使用sql语句来实现。<br>
2、<mark>逻辑外键：</mark>（推荐）<br>
就是在表中创建一个普通的字段，没有强关联关系，需要通过程序逻辑来实现。</p>
<h3 id="1-一对一关系">1、一对一关系</h3>
<p>就是在一个表中的数据，对应着另外一张表中的一个数据，只能有一个。</p>
<pre><code class="language-java"> 员工表：
        id，姓名、性别、年龄、籍贯、联系方式、学历、工龄、、、
    由上面的一个表，拆分成两个表
    员工表：
        id，姓名、联系方式、工龄、
        12  张三  1010    3
        13  李四  1020    2

    详情表：
       yid 性别、籍贯、学历
        12    男    山东 本科
        13    男    山西 本科

    上面的表关系就是一对一的表关系，通过详情表中的yid这个字段来标记员工表中的主键。
    一个员工有着一个对应的详情信息，存储在详情表中，
    在详情表中的数据，也只属于某一个员工。
</code></pre>
<h3 id="2-一对多关系使用频率最高">2、一对多关系（使用频率最高）</h3>
<p>在一个表中的一条数据对应着另外一个表中的多条数据。<br>
（在一个表中的多条数据，对应着另外一张表中一个数据）</p>
<pre><code class="language-java">例子：
商品分类
     id 分类名
     1  手机
     2  电脑

 商品
     id 所属分类id，商品名
     1       1         小米手机
     2       1         华为手机
</code></pre>
<h3 id="3-多对多关系">3、多对多关系</h3>
<pre><code class="language-java"> 例如一本书，有多个标签，同时每一个标签下又对应多本书
 books 图书
 id  name          author
 1   &lt;跟川哥学编程&gt;    川哥
 2   &lt;跟川哥学数据分析&gt; 川哥
 3   &lt;川哥讲法律故事&gt;   川哥

 tags 标签
 id   name
 1    编程
 2    计算机
 3    互联网
 4    法律
 5    文学

 从图书角度看，一本书有多个标签
 1   &lt;跟川哥学编程&gt;    川哥   ， 编程、计算机、互联网
 2   &lt;跟川哥学数据分析&gt; 川哥  ，  互联网、计算机
 3   &lt;川哥讲法律故事&gt;   川哥 ，  法律

 换一个角度，从标签这个角度看，一个标签包含多个图书
 计算机， &lt;跟川哥学编程&gt;， &lt;跟川哥学数据分析&gt;
</code></pre>
<h2 id="表联结">表联结</h2>
<p>是一种查询的机制，用来在一个select语句中关联多个表进行查询，这种情况称为联结。</p>
<h3 id="两个表相联结">两个表相联结</h3>
<pre><code class="language-java">需要查询出所有商品以及对应的供应商信息？
供应商名称，商品名称，商品价格
select vend_name,prod_name,prod_price
from vendors,products（限定表格）
where vendors.vend_id  = products.vend_id（指定两个表中的列名相匹配）
order by vend_name（按照名字排序）
</code></pre>
<p><mark>假如没有where条件时会发生什么呢？</mark><br>
如果没有where条件，那么第一个表中的每一行数据会与第二个表中的每一行数据进行匹配，不管逻辑是否可以匹配。<br>
如果没有where条件，那么这种结果称为 笛卡尔积，第一个表的行数乘以第二个表中的行数。<br>
<strong>所以千万不要忘记where条件！！！</strong><br>
另一种联结方式：join</p>
<pre><code class="language-java">select vend_name,prod_name,prod_price
from vendors
(inner)可省略 join products on vendors.vend_id = products.vend_id;

以上sql就是使用了 join 的语法，进行了两个表的联结，在 on 后面 去定义了 联结的条件。
</code></pre>
<h3 id="联结多个表">联结多个表</h3>
<pre><code class="language-java">案例： 查询出订单号为20005的订单中购买的商品及对应的产品供应商信息
select prod_name,vend_name,prod_price,quantity
from orderitems,products,vendors
    where products.vend_id = vendors.vend_id（在where语句中说清联结关系）
    and orderitems.prod_id = products.prod_id
    and order_num = 20005;
改写为 join 的语法
select prod_name,vend_name,prod_price,quantity
from orderitems
inner join products on orderitems.prod_id = products.prod_id
inner join vendors on products.vend_id = vendors.vend_id
where order_num = 20005;
</code></pre>
<p><mark>注：</mark><br>
MySQL在运行时关联指定的每个表以处理联结，这种处理是非常耗费资源的，因此应该自习，不要联结不必要的表，联结的表越多，性能下降越厉害。</p>
<h3 id="自联结">自联结</h3>
<p>自联结:当前这个表与自己这个表 做联结（join）</p>
<pre><code class="language-java">例子：假如你发现某物品（其ID为DTNTR）存在问题，因此想知道生产该物品的供应商生产的其他物品是否也存在这些问题。因此查询要求首先找到生产ID为DTNTR的物品的供应商，然后找出这个供应商生产的其他物品。
-- 使用子查询（嵌套查询）
select prod_id,prod_name
from products
where vend_id = (select vend_id from products where prod_id = 'DTNTR');
-- 使用 自联结方式查询
select p1.prod_id,p2.prod_name
from products as p1
join products as p2 on p1.vend_id = p2.vend_id
where p2.prod_id = 'DTNTR';
-- 改成where语句
select p1.prod_id,p2.prod_name
from products as p1, products as p2
where p1.vend_id = p2.vend_id and p2.prod_id = 'DTNTR';
-- 深入了解 join
select
p1.prod_id,p1.prod_name,p1.vend_id,
p2.prod_id,p2.prod_name,p2.vend_id
from products as p1,products as p2
where p1.vend_id = p2.vend_id
and p2.prod_id = 'DTNTR';

</code></pre>
<p>子查询（嵌套查询） 是目前可明确知道的 sql中运行效率最低的一种方式，尽可能不使用嵌套语句。</p>
<h2 id="外部联结">外部联结</h2>
<p>许多联结将一个表的行与另一个表中的行相关联，当时有时候需要包含没有关联行的那些行<br>
left join ： 是以 left join 左侧表为基准，去关联右侧的表进行联结，如果有未关联的数据，那么结果为null。<br>
right join ：是以 right join 右侧表为基准，去关联左侧的表进行联结，如果有未关联的数据，那么结果为null。</p>
<h2 id="总结表联结">总结表联结</h2>
<p>内部联结：where，inner join<br>
自联结：在一个sql中，用当前这个表，联结自己<br>
外部联结：left join，right join</p>
<h2 id="组合查询union">组合查询UNION</h2>
<p>UNION规则：</p>
<ul>
<li>UNION必须由两条或者两条以上的SELECT语句组成，语句之间用关键字UNION分隔（如果组合4条SELECT语句，将要使用3个UNION关键字）</li>
<li>UNION中的每个查询必须包含相同的列，表达式或聚集函数（不过各个列不需要以相同的次序列出）</li>
<li>列数据类型必须兼容：类型不必完全相同，但必须是DBMS可以隐含的转换的类型（例如：不同的数值类型或者不同的日期类型）<br>
<mark>注意</mark></li>
<li>使用UNION时，默认删除重复的行，如果想返回所有的匹配行，可以使用UNION ALL</li>
<li>对组合查询结果排序时：只能使用一条ORDER BY子句！对于结果集，只能存在一种排序方式。</li>
</ul>
<pre><code class="language-java">例如：
select vend_id,prod_id,prod_price from products where prod_price &lt;= 5
union
select vend_id,prod_id,prod_price from products where vend_id in(1001,1002)
order by prod_price;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JDBC学习]]></title>
        <id>https://Vinci-Ma.github.io/post/jdbc-xue-xi/</id>
        <link href="https://Vinci-Ma.github.io/post/jdbc-xue-xi/">
        </link>
        <updated>2020-07-27T02:44:28.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#jdbc%E7%AE%80%E4%BB%8B">JDBC简介</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4">使用步骤</a></li>
<li><a href="#jdbc%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E7%B1%BB%E5%9E%8B%E4%B8%8E%E6%96%B9%E6%B3%95">JDBC中常用的类型与方法</a></li>
<li><a href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F">工厂方法设计模式（静态工厂方法模式）</a></li>
<li><a href="#dao">DAO</a></li>
<li><a href="#sql%E6%B3%A8%E5%85%A5%E9%97%AE%E9%A2%98">==SQL注入问题==</a>
<ul>
<li><a href="#%E8%A7%A3%E5%86%B3sql%E6%B3%A8%E5%85%A5%E9%97%AE%E9%A2%98">解决sql注入问题</a></li>
<li><a href="#preparedstatement-%E9%A2%84%E7%BC%96%E8%AF%91%E7%9A%84sql%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83">PreparedStatement 预编译的SQL执行环境</a></li>
<li><a href="#preparedstatement%E4%B8%8Estatement%E8%B0%81%E7%9A%84%E6%80%A7%E8%83%BD%E9%AB%98">PreparedStatement与Statement谁的性能高?</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8B%E5%8A%A1">事务</a>
<ul>
<li><a href="#%E4%BA%8B%E5%8A%A1%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98">事务相关面试题</a></li>
</ul>
</li>
<li><a href="#%E6%89%B9%E5%A4%84%E7%90%86">批处理</a></li>
<li><a href="#properties-%E4%BD%9C%E4%B8%BA%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">Properties 作为配置文件</a></li>
<li><a href="#%E8%BF%9E%E6%8E%A5%E6%B1%A0datasource%E7%9A%84%E4%BD%BF%E7%94%A8">==连接池(DataSource)的使用==</a>
<ul>
<li><a href="#dbcp%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4">==DBCP连接池的使用步骤==</a></li>
<li><a href="#%E5%BE%B7%E9%B2%81%E4%BC%8A%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4">==德鲁伊连接池的使用步骤==</a></li>
</ul>
</li>
</ul>
</p>
<h1 id="jdbc简介">JDBC简介</h1>
<p>Java DataBase Connectivity Java数据库连接<br>
JDBC是一套标准,是Java与各大数据库厂商共同定制的一套接口. 这套接口由各大数据库厂商进行了实现</p>
<h1 id="使用步骤">使用步骤</h1>
<blockquote>
<p>1、 引入jar文件.<br>
2、加载数据库驱动 (JavaSE项目中可以省略 , JavaWeb项目必须编写此步骤)<br>
Class.forName(&quot;com.mysql.jdbc.Driver&quot;);<br>
3、通过驱动管理器, 获取JDBC连接对象.<br>
Connection conn = DriverManager.getConnection(&quot;数据库连接地址&quot;,&quot;帐号&quot;,&quot;密码&quot;);<br>
// 数据库连接地址格式: 主协议:子协议://ip地址:端口号/数据库名称<br>
// mysql的连接地址: jdbc:mysql://localhost:3306/java35<br>
// oracle的连接地址: jdbc:oracle:thin:@localhost:1521:ORCL<br>
4、 通过连接对象, 创建SQL执行对象 (SQL执行环境)<br>
Statement state = conn.createStatement();<br>
5、通过SQL执行对象 ,执行SQL语句.<br>
state.execute(String sql语句);<br>
返回值：true【表示的sql语句有结果集，并不是说执行成功】<br>
6、释放资源<br>
state.close();<br>
conn.close();</p>
</blockquote>
<h1 id="jdbc中常用的类型与方法">JDBC中常用的类型与方法</h1>
<pre><code class="language-javascript">1. DriverManager : 驱动管理器
    常用方法:
    - 获取数据库连接:
    static Connection getConnection(String 数据库地址,String 账号 ,String 密码)
2. Connection : 数据库连接对象
    常用方法:
    - 创建SQL执行对象: Statement createStatement();
3. Statement : SQL执行对象
    常用方法:
    - 执行SQL语句(查询语句返回true, 其它语句返回false)
    boolean execute(String sql);
    - 执行DML语句(INSERT UPDATE DELETE) 和 DDL语句(create alter drop)
    (返回int值, 表示语句对数据库表格的影响行数 !)
    (通常我们认为 返回值&gt;0 表示执行成功.)
    int executeUpdate(String sql);
    - 执行DQL语句 (select)
    ResultSet executeQuery(String sql);
4. ResultSet : 结果集对象 (指的是一个select语句的查询结果)
    常用方法:
        1. 控制游标移动的常用方法:
            - boolean next() ****
            作用: 控制游标向下一行移动.
            返回值: 移动成功返回true , 下一行不存在移动失败, 返回false
            - boolean privious() 了解
            作用: 控制游标向上一行移动.
            返回值: 移动成功返回true , 上一行不存在移动失败, 返回false
            - boolean absolute(int 行号) 了解
            作用: 控制游标向指定行移动
            返回值: 移动成功返回true , 行不存在移动失败, 返回false
            - boolean beforeFirst() 了解
            作用: 控制游标移动到第一行
            返回值: 移动成功返回true, 没有第一行数据返回false
            - boolean afterLast() 了解
            作用: 控制游标移动到最后一行
            返回值: 移动成功返回true, 没有最后一行数据返回false
        2. 获取游标指向行的字段值的常用方法:
            - XXX getXXX(String 列名) ***
            根据字段名, 得到此字段的值
            - XXX getXXX(int 字段的索引) *
            根据字段的索引, 得到字段的值 , 索引从1开始
</code></pre>
<h1 id="工厂方法设计模式静态工厂方法模式">工厂方法设计模式（静态工厂方法模式）</h1>
<p>工厂方法模式一种创建对象的模式.<br>
工厂方法模式基于&quot;输入&quot;，应用在超类和多个子类之间的情况，这种模式将创建对象的责任转移到工厂类；<br>
<mark>工厂设计模式的优点:</mark></p>
<ol>
<li>面向接口编程，体现了面向对象的思想</li>
<li>降低了耦合, 将创建对象的工作转移到了工厂类</li>
</ol>
<h1 id="dao">DAO</h1>
<p>DAO(Data Access Object)是一个数据访问接口，数据访问：顾名思义就是与数据库打交道。夹在业务逻辑与数据库资源中间。<br>
为了建立一个健壮的Java应用，应该将所有对数据源的访问操作抽象封装在一个公共API中。用程序设计的<br>
语言来说，就是建立一个接口，接口中定义了此应用程序中将会用到的所有事务方法。在这个应用程序中，<br>
当需要和数据源进行交互的时候则使用这个接口，并且编写一个单独的类来实现这个接口在逻辑上对应这个<br>
特定的数据存储。<br>
DAO模式是标准的JavaEE设计模式之一.开发人员使用这个模式把底层的数据访问操作和上层的商务逻辑分<br>
开.一个典型的DAO实现有下列几个组件：</p>
<ol>
<li>一个DAO工厂类；</li>
<li>一个DAO接口；</li>
<li>至少一个实现DAO接口的具体类；</li>
<li>数据传递对象（有些时候叫做Bean对象）</li>
</ol>
<h1 id="sql注入问题"><mark>SQL注入问题</mark></h1>
<pre><code class="language-java">进行用户登录时, 输入不存在的帐号 和 如下的密码:
    1' or '1'='1
结果显示登录成功.
因为用户输入的密码, 与我们的查询语句拼接后, 使得我们的查询语句产生了歧义:
原查询语句:
    select * from xzk_user where username='' and password='密码'
拼接后:
    select * from xzk_user where username='hahahaheiheihei' and password='1' or '1'='1'
</code></pre>
<h2 id="解决sql注入问题">解决sql注入问题</h2>
<p>我们可以将SQL语句与参数分离,将参数作为SQL的特殊部分进行预处理</p>
<h2 id="preparedstatement-预编译的sql执行环境">PreparedStatement 预编译的SQL执行环境</h2>
<p>内部实现原理:<br>
1. 将未拼接参数的SQL语句, 作为SQL指令, 先传递给数据库 进行编译.<br>
2. 再将参数传递给数据库, 此时传递的参数不会再作为指令执行, 只会被当作文本存在.</p>
<pre><code class="language-java">操作流程与Statement基本一致:
    1. 如何得到一个PreparedStatement 对象
            PreparedStatement state = conn.prepareStatement(&quot;预编译的SQL语句&quot;);
    2. 预编译的SQL语句如何编写
            需要填充参数的位置, 使用?代替即可! 例如:
            select id from xzk_user where username=? and password=?
    3. 参数如何填充
            state.setXXX(int index,XXX value);
            setXXX中XXX指的是数据类型,
            参数1: index : SQL语句中?的索引值 , 从1开始
            参数2: value : 填充的参数值.
    4. 如何执行填充完毕参数的SQL
            - boolean execute();
            - int executeUpdate();
            - ResultSet executeQuery();
</code></pre>
<h2 id="preparedstatement与statement谁的性能高">PreparedStatement与Statement谁的性能高?</h2>
<p>根据数据库的不同，两者的性能高低也不同。<br>
在<strong>mysql</strong>中, preparedStatement原理是拼接SQL, 所以<strong>Statement</strong>性能高.<br>
在<strong>Oracle</strong>中, preparedStatement原理是对SQL指令进行预处理, 再传递的参数不具备特殊含义.有更好的SQL缓存策略,<strong>PreparedStatement</strong>高.</p>
<h1 id="事务">事务</h1>
<p>将多条SQL语句, 看作一个整体. 要么一起成功, 要么一起失败。<br>
事务在mysql中, 是默认自动提交的。</p>
<pre><code class="language-java">操作方式1：命令行
    - 开启事务: start transaction;
    - 回滚 : rollback; --此次事务中所有的sql操作, 放弃.
    - 提交 : commit; --此次事务中所有的sql操作, 作为一个整体, 提交.
操作方式2：java
    JDBC事务通过连接对象开启, 回滚 ,提交. 只针对当前连接对象生效.
    - 开启事务: conn.setAutoCommit(false);
    - 回滚事务: conn.rollback();
    - 提交事务: conn.commit();
</code></pre>
<h2 id="事务相关面试题">事务相关面试题</h2>
<ol>
<li><strong>请描述事务的四大特征 :</strong><br>
&lt;1&gt;. 原子性: 事务是一个整体 , 不可分割 , 要么同时成功, 要么同时失败.<br>
&lt;2&gt;. 持久性: 当事务提交或回滚后, 数据库会持久化的保存数据.<br>
&lt;3&gt;. 隔离性: 多个事务之间, 隔离开, 相互独立.<br>
&lt;4&gt;. 一致性: 事务操作的前后 , 数据总量不变 (例如: 转账时: 孟亮给帅兵转账是一个事务, 转账完毕后. 两人余额的和不变.)</li>
<li><strong>请描述什么是脏读, 幻读, 不可重复读 ?</strong></li>
</ol>
<ul>
<li>脏读: 读取到了一个事务 未提交的数据.</li>
<li>不可重复读: 一个事务中, 两次连续的读取 ,结果不一致(中间被其它事务更改了).</li>
<li>幻读: 一个事务A在执行DML语句时, 另一个事务B也在执行DML语句 , B修改了A修改过的数据, 导致A在查询时就像发生了幻觉一样(A更改的内容A看不到了.)<br>
解决方法：加锁</li>
</ul>
<ol start="3">
<li><strong>请描述事务的隔离级别</strong><br>
//三种级别锁: 页级,表级,行级(共享锁,排它锁).<br>
1、 读未提交 : read uncommitted; (可能产生:脏读, 不可重复读, 幻读)<br>
2、读已提交 : read committed; (可能产生: 不可重复度, 幻读)<br>
3、可重复读 : repeatable read;(mysql默认值) (可能产生: 幻读)<br>
4、串行化 : serializable;</li>
</ol>
<ul>
<li>查看数据库当前的隔离级别: select @@tx_isolation; (了解)</li>
<li>数据库设置隔离级别: set global transaction isolation level 级别字符串;(了解)</li>
</ul>
<h1 id="批处理">批处理</h1>
<p>将多条语句, 放到一起批量处理 。<br>
批处理的原理: 将多条SQL语句, 转换为一个SQL指令. 显著的提高大量SQL语句执行时的数据库性能。</p>
<pre><code class="language-java">Statement对象使用流程:
    1. 得到Statement对象
    Statement state = conn.createStatement();
    1. 将一条SQL语句, 加入到批处理中.
    state.addBatch(String sql);
    1. 执行批处理
    state.executeBatch();
    1. 清空批处理
    state.clearBatch();
PreparedStatement对象使用流程:
    1. 得到PreparedStatement对象
    PreparedStatement state = conn.prepareStatement(&quot;预编译的SQL&quot;);
    2. 填充预编译的参数
    state.setXXX(1,填充参数);
    3. 将一条填充完毕参数的SQL, 加入到批处理中.
    state.addBatch();
    4. 执行批处理
    state.executeBatch();
    5. 清空批处理
    state.clearBatch();
</code></pre>
<h1 id="properties-作为配置文件">Properties 作为配置文件</h1>
<p>Properties类 是Java中的Map集合的实现类.<br>
.properties文件 用于通过文件描述一组键值对!<br>
.properties文件 ,可以快速的转换为Properties类的对象.</p>
<pre><code class="language-java">文件中内容的格式:
    文件内容都是字符串 , 键与值之间通过等号连接 , 多个键值对之间换行分割.
    例如:
    url=xxx
    user=xxx
    password=xxx
如何将文件 转换为 集合:
    步骤:
    1. 创建Properties对象
        Properties ppt = new Properties();
    2. 创建一个字节输入流 , 指向.properties文件
        InputStream is = new FileInputStream(&quot;文件地址&quot;);
    3. 将字节输入流, 传递给properties对象, 进行加载.
        ppt.load(is);
</code></pre>
<h1 id="连接池datasource的使用"><mark>连接池(DataSource)的使用</mark></h1>
<p>连接池用于缓存连接!<br>
当我们需要使用连接时, 可以不用再创建连接 ! 可以直接从连接池中获取连接.<br>
当连接池中存在空闲连接时, 会将空闲连接给到程序使用.<br>
当连接池中不存在空闲连接时, 且连接池未满时 , 则创建连接提供给程序使用 ,并在程序使用完毕后,<br>
缓存连接.<br>
当连接池中不存在空闲连接时, 且连接池已满时 , 则排队等候空闲连接的出现.<br>
<mark>注意:</mark><br>
使用连接池中的连接对象操作数据库时, 操作完毕依然需要释放连接(调用close()).<br>
连接池中的连接在设计时, 使用了动态代理设计模式+装饰者设计模式 . 我们调用它的close方法,代理没有关闭这个连接, 而是将连接重新放入了池中.</p>
<h2 id="dbcp连接池的使用步骤"><mark>DBCP连接池的使用步骤</mark></h2>
<pre><code class="language-java">1. 引入相关的jar文件
    - dbcp.jar
    - poll.jar
2. 将配置文件引入
3. 将配置文件, 转换为Properties对象
    Properties ppt = new Properties();
    ppt.load(配置文件的输入流);
4. 通过连接池的工厂类(BasicDataSourceFactory)的创建连接池的方法(createDataSource())
    DataSource ds = BasicDataSourceFactory.createDataSource(ppt);
5. 从连接池中 获取连接对象
    Connection conn = ds.getConnection();
</code></pre>
<h2 id="德鲁伊连接池的使用步骤"><mark>德鲁伊连接池的使用步骤</mark></h2>
<pre><code class="language-java">1. 引入相关的jar文件
    - druid-1.0.9.jar
2. 将配置文件引入
3. 将配置文件, 转换为Properties对象
    Properties ppt = new Properties();
    ppt.load(配置文件的输入流);
4. 通过连接池的工厂类(DruidDataSourceFactory)的创建连接池的方法(createDataSource())
    DataSource ds = DruidDataSourceFactory.createDataSource(ppt);
5. 从连接池中 获取连接对象
    Connection conn = ds.getConnection();
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MySQL学习]]></title>
        <id>https://Vinci-Ma.github.io/post/mysql-xue-xi/</id>
        <link href="https://Vinci-Ma.github.io/post/mysql-xue-xi/">
        </link>
        <updated>2020-07-25T08:38:34.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BB%8B%E7%BB%8D">MySQL数据库介绍</a>
<ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E5%BA%93">什么是数据库</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BD%9C%E7%94%A8">数据库的作用</a></li>
<li><a href="#%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E5%BA%93">常见数据库</a></li>
</ul>
</li>
<li><a href="#mysql%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">MySQL中的数据类型</a>
<ul>
<li><a href="#1-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">1、字符串数据类型</a></li>
<li><a href="#2-%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">2、数值类型</a></li>
<li><a href="#3-%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B">3、日期和时间类型</a></li>
<li><a href="#4-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%BE%88%E5%B0%91%E4%BD%BF%E7%94%A8">4、二进制数据类型（很少使用）</a></li>
</ul>
</li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4">数据库的基本命令</a>
<ul>
<li><a href="#mysql%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C">MySQL基础操作</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C">数据库的基本操作</a></li>
<li><a href="#%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C">表的基本操作</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C">数据的基本操作</a></li>
<li><a href="#mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AF%BC%E5%85%A5%E5%92%8C%E5%AF%BC%E5%87%BA">MySQL数据库的导入和导出</a></li>
</ul>
</li>
</ul>
</p>
<h1 id="mysql数据库介绍">MySQL数据库介绍</h1>
<h2 id="什么是数据库">什么是数据库</h2>
<ul>
<li>数据库(Database)就是按照数据结构来组织，存储和管理数据的仓库。</li>
<li>专业的数据库是专门对数据进行创建，访问，管理，搜索等操作的软件，比起我们自己用文件读写的方<br>
式对象数据进行管理更加的方便，快速，安全。</li>
</ul>
<h2 id="数据库的作用">数据库的作用</h2>
<ol>
<li>对数据进行持久化的保存。</li>
<li>方便数据的存储和查询，速度快，安全，方便。</li>
<li>可以处理并发访问。</li>
<li>更加安全的权限管理访问机制。</li>
</ol>
<h2 id="常见数据库">常见数据库</h2>
<ul>
<li>关系型数据库： MySQL，Oracle，PostgreSQL，SQLserver……</li>
<li>非关系型数据库：Redis内存数据库，MongoDB文档数据库……<br>
MySQL数据库是最流行的关系型数据库管理系统。</li>
</ul>
<h1 id="mysql中的数据类型">MySQL中的数据类型</h1>
<h2 id="1-字符串数据类型">1、字符串数据类型</h2>
<p>存储串，如名字、地址、电 话号码、邮政编码等</p>
<ul>
<li>定长串：char</li>
</ul>
<ol>
<li>接受长度固定的字符串，其长度是在创建表时指定的。<br>
定长列不允许存储多于指定长度字符的数据。</li>
<li>指定长度后，就会分配固定的存储空间用于存放数据</li>
</ol>
<ul>
<li>变长串 varchar<br>
存储可变长度的字符串 varchar(7) 如果实际插入4个字符, 那么它只占4个字符位置,当然插入的数据长度不能超过7个字符。<br>
<mark>注意</mark><br>
既然变长数据类型这样灵活，为什么还要使用定长数据类型？<br>
回答：因为性能，MySQL处理定长列远比处理变长列快得多。</li>
<li>Text 变长文本类型存储<br>
<img src="https://Vinci-Ma.github.io/post-images/1595685781112.png" alt="" loading="lazy"></li>
</ul>
<h2 id="2-数值类型">2、数值类型</h2>
<figure data-type="image" tabindex="1"><img src="https://Vinci-Ma.github.io/post-images/1595685848153.png" alt="" loading="lazy"></figure>
<pre><code class="language-javascript">decimal(5, 2) 表示数值总共5位, 小数占2位
tinyint 1字节(8位) 0-255。-128，127
int 4字节。 -21亿，21亿。0-42亿
float.
MySQL中没有专门存储货币的数据类型，一般情况下使用DECIMAL(8, 2)
</code></pre>
<p><strong>有符号或无符号</strong><br>
所有数值数据类型（除BIT和BOOLEAN外）都可以有符号或无符号<br>
有符号数值列可以存储正或负的数值<br>
无符号数值列只能存储正数。<br>
默认情况为有符号，但如果你知道自己不需要存储负值，可以使用UNSIGNED关键字<br>
<mark>注意</mark><br>
如果将邮政编码类似于01234存储为数值类型，则保存的将是数值1234，此时需要使用字符串类型<br>
手机号也应该使用字符串类型</p>
<h2 id="3-日期和时间类型">3、日期和时间类型</h2>
<figure data-type="image" tabindex="2"><img src="https://Vinci-Ma.github.io/post-images/1595686044391.png" alt="" loading="lazy"></figure>
<h2 id="4-二进制数据类型很少使用">4、二进制数据类型（很少使用）</h2>
<p>二进制数据类型可存储任何数据（甚至包括二进制信息），如图像、多媒体、字处理文档等<br>
<img src="https://Vinci-Ma.github.io/post-images/1595686105163.png" alt="" loading="lazy"></p>
<h1 id="数据库的基本命令">数据库的基本命令</h1>
<h2 id="mysql基础操作">MySQL基础操作</h2>
<ul>
<li><strong>SQL ( Structure query language ) 结构化查询语言</strong><br>
SQL语言分为4个部分：DDL（定义）、DML（操作）、DQL（查询）、DCL（控制）</li>
<li><strong>SQL语句中的快捷键</strong><br>
\G 格式化输出（文本式，竖立显示）<br>
\s 查看服务器端信息<br>
\c 结束命令输入操作<br>
\q 退出当前sql命令行模式<br>
\h 查看帮助</li>
<li><strong>连接MySQL</strong></li>
</ul>
<pre><code class="language-javascript">mysql -u root -p
</code></pre>
<p>其中：<br>
-h 服务器地址<br>
-u 登录账号<br>
-p 回车后输入密码<br>
-P （大写）端口号</p>
<ul>
<li><strong>退出MySQL</strong></li>
</ul>
<pre><code class="language-javascript">exit; 或者 quit; 或者 \q
</code></pre>
<h2 id="数据库的基本操作">数据库的基本操作</h2>
<ul>
<li><strong>查看数据库</strong></li>
</ul>
<pre><code class="language-javascript">show databases;
</code></pre>
<ul>
<li><strong>打开数据库</strong></li>
</ul>
<pre><code class="language-javascript">use 库名;
</code></pre>
<ul>
<li><strong>创建数据库</strong></li>
</ul>
<pre><code class="language-javascript">create database 库名 default charset=utf8;
</code></pre>
<ul>
<li><strong>删除数据库</strong></li>
</ul>
<pre><code class="language-javascript">drop database 库名;
</code></pre>
<h2 id="表的基本操作">表的基本操作</h2>
<ul>
<li><strong>查看表</strong></li>
</ul>
<pre><code class="language-javascript">show tables;
</code></pre>
<ul>
<li><strong>新建表</strong></li>
</ul>
<pre><code class="language-javascript">create student(
    Id int unsigned primary key not null unique auto_increment,  
    name varchar(4) not null,
    age int unsigned not null
)engine=innodb default charset=utf8;
</code></pre>
<p><strong>表的字段约束</strong></p>
<ul>
<li>unsigned 无符号(给数值类型使用，表示为正数，不写可以表示正负数都可以)</li>
<li>字段类型后面加括号限制宽度
<ul>
<li>char(5). varchar(7) 在字符类型后面加限制 表示 字符串的长度</li>
<li>int(4) 没有意义，默认无符号的int为int(11)，有符号的int(10)</li>
<li>nt(4) unsigned zerofill只有当给int类型设置有前导零时，设置int的宽度才有意义。</li>
</ul>
</li>
<li>not null 不能为空,在操作数据库时如果输入该字段的数据为NULL ，就会报错</li>
<li>default 设置默认值</li>
<li>primary key 主键不能为空,且唯一.一般和自动递增一起配合使用。</li>
<li>auto_increment 定义列为自增属性，一般用于主键，数值会自动加1</li>
<li>unique 唯一索引(数据不能重复:用户名)可以增加查询速度,但是会降低插入和更新速度<br>
<strong>主键</strong><br>
1、表中每一行都应该有可以唯一标识自己的一列，用于记录两条记录不能重复，任意两行都不具有相同的主键值<br>
2、应该总是定义主键 虽然并不总是都需要主键，但大多数数据库设计人员都应保证他们创建的每个表具有一个主<br>
键，以便于以后的数据操纵和管理。<br>
<mark>要求</mark></li>
<li>记录一旦插入到表中，主键最好不要再修改</li>
<li>不允许NULL</li>
<li>不在主键列中使用可能会更改的值。</li>
<li>自增整数类型：数据库会在插入数据时自动为每一条记录分配一个自增整数，这样我们就完全不用担心主键重复，也不用自己预先生成主键</li>
<li>可以使用多个列作为联合主键，但联合主键并不常用。使用多列作为主键时，所有列值的组合必须是唯一的</li>
<li><strong>查看表结构</strong></li>
</ul>
<pre><code class="language-javascript">desc 表名;
</code></pre>
<ul>
<li><strong>修改表结构</strong></li>
</ul>
<pre><code class="language-javascript">alter table 表名 action (更改的选项)
</code></pre>
<ol>
<li>添加字段</li>
</ol>
<pre><code class="language-javascript"># 语法：alter table 表名 add 添加的字段信息
-- 在 users 表中 追加 一个 num 字段
alter table users add num int not null;
-- 在指定字段后面追加字段 在 users 表中 age字段后面 添加一个 email 字段
alter table users add email varchar(50) after age;
-- 在指定字段后面追加字段，在 users 表中 age字段后面 添加一个 phone
alter table users add phone char(11) not null after age;
-- 在表的最前面添加一个字段
alter table users add aa int first;
</code></pre>
<ol start="2">
<li>删除字段</li>
</ol>
<pre><code class="language-javascript"># 删除字段 alter table 表名 drop 被删除的字段名
alter table users drop aa;
</code></pre>
<ol start="3">
<li>修改字段</li>
</ol>
<pre><code class="language-javascript">语法格式： alter table 表名 change|modify 被修改的字段信息
change: 可以修改字段名，
modify: 不能修改字段名。
# 修改表中的 num 字段 类型，使用 modify 不修改表名
alter table users modify num tinyint not null default 12;
# 修改表中的 num 字段 为 int并且字段名为 nn
alter table users change num mm int;
# 注意：一般情况下，无特殊要求，不要轻易修改表结构
</code></pre>
<ul>
<li><strong>修改表名</strong></li>
</ul>
<pre><code class="language-javascript"># 语法：alter table 原表名 rename as 新表名
</code></pre>
<ul>
<li><strong>更改表中的自增的值</strong></li>
</ul>
<pre><code class="language-javascript"># 在常规情况下，auto_increment 默认从1开始继续递增
alter table users auto_increment = 1000;
</code></pre>
<ul>
<li><strong>修改表引擎</strong></li>
</ul>
<pre><code class="language-javascript"># 推荐在定义表时，表引擎为 innodb。
# 通过查看建表语句获取当前的表引擎
mysql&gt; show create table users\G;
*************************** 1. row ***************************
Table: users
Create Table: CREATE TABLE `users` (
PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=1001 DEFAULT CHARSET=utf8
1 row in set (0.00 sec)
# 直接查看当前表状态信息
mysql&gt; show table status from tlxy where name = 'users'\G;
*************************** 1. row ***************************
Name: users
Engine: InnoDB
# 修改表引擎语句
alter table users engine = 'myisam';
</code></pre>
<ul>
<li><strong>删除表</strong></li>
</ul>
<pre><code class="language-javascript">drop table 表名;
</code></pre>
<h2 id="数据的基本操作">数据的基本操作</h2>
<ul>
<li><strong>查看表中的数据</strong></li>
</ul>
<pre><code class="language-javascript">select 字段列表|* from 表名
[where 搜索条件]
[group by 分组字段 [having 分组条件]]
[order by 排序字段 排序规则]
[limit 分页参数]
</code></pre>
<ol>
<li>基础查询</li>
</ol>
<pre><code class="language-javascript"># 查询表中所有列 所有数据
select * from users;
# 指定字段列表进行查询
select id,name,phone from users;
</code></pre>
<ol start="2">
<li>Where条件查询</li>
</ol>
<blockquote>
<p>可以在where子句中指定任何条件<br>
可以使用 and 或者 or 指定一个或多个条件<br>
where条件也可以运用在update和delete语句的后面<br>
where子句类似程序语言中if条件，根据mysql表中的字段值来进行数据的过滤</p>
</blockquote>
<pre><code class="language-javascript">-- 查询users表中 age &gt; 22的数据
select * from users where age &gt; 22;
-- 查询 users 表中 name=某个条件值 的数据
select * from users where name = '王五';
-- 查询 users 表中 年龄在22到25之间的数据
select * from users where age &gt;= 22 and age &lt;= 25;
select * from users where age between 22 and 25;
-- 查询 users 表中 年龄不在22到25之间的数据
select * from users where age &lt; 22 or age &gt; 25;
select * from users where age not between 22 and 25;
-- 查询 users 表中 年龄在22到25之间的女生信息
select * from users where age &gt;= 22 and age &lt;= 25 and sex = '女';
</code></pre>
<p>and和or使用时注意：在 sql 计算的顺序上，sql会优先处理and条件，使用时记得加括号。<br>
3. Like子句<br>
可以使用like语句进行某个字段的模糊搜索。</p>
<pre><code class="language-javascript">-- like 语句 like某个确定的值 和 where name = '王五' 是一样
select * from users where name like '王五';
-- 使用 % 模糊搜索。%代表任意个任意字符
    -- 查询name字段中包含五的
select * from users where name like '%五%';
-- 查询name字段中最后一个字符 为 五的
select * from users where name like '%五';
-- 查询name字段中第一个字符 为 王 的
select * from users where name like '王%';
-- 使用 _ 单个的下划线。表示一个任意字符，使用和%类似
    -- 查询表中 name 字段为两个字符的数据
    select * from users where name like '__';
    -- 查询 name 字段最后为五，的两个字符的数据
    select * from users where name like '_五';
</code></pre>
<p><mark>注意：</mark><br>
where子句中的like在使用%或者_进行模糊搜索时，效率不高，使用时注意：<br>
尽可能的不去使用%或者_<br>
如果需要使用，也尽可能不要把通配符放在开头处<br>
4. MySQL中的统计函数（聚合函数）<br>
max(),min(),count(),sum(),avg()</p>
<pre><code class="language-javascript"># 计算 users 表中 最大年龄，最小年龄，年龄和及平均年龄
select max(age),min(age),sum(age),avg(age) from users;
+----------+----------+----------+----------+
| max(age) | min(age) | sum(age) | avg(age) |
+----------+----------+----------+----------+
| 28 | 20 | 202 | 22.4444 |
+----------+----------+----------+----------+
-- 上面数据中的列都是在查询时使用的函数名，不方便阅读和后期的调用，可以通过别名方式 美化
select max(age) as max_age,
min(age) min_age,sum(age) as sum_age,
avg(age) as avg_age
from users;
+---------+---------+---------+---------+
| max_age | min_age | sum_age | avg_age |
+---------+---------+---------+---------+
| 28 | 20 | 202 | 22.4444 |
+---------+---------+---------+---------+
-- 统计 users 表中的数据量
select count(*) from users;
+----------+
| count(*) |
+----------+
| 9 |
+----------+
select count(id) from users;
+-----------+
| count(id) |
+-----------+
| 9 |
+-----------+
-- 上面的两个统计，分别使用了 count(*) 和 count(id),结果目前都一样，有什么区别？
-- count(*) 是按照 users表中所有的列进行数据的统计，只要其中一列上有数据，就可以计算
-- count(id) 是按照指定的 id 字段进行统计，也可以使用别的字段进行统计，
-- 但是注意，如果指定的列上出现了NULL值，那么为NULL的这个数据不会被统计
</code></pre>
<ol start="5">
<li>Group by分组<br>
group by 语句根据一个或多个列对结果集进行分组<br>
一般情况下，是用与数据的统计或计算，配合聚合函数使用</li>
</ol>
<pre><code class="language-javascript">-- 统计 users 表中 男女生人数,
-- 很明显按照上面的需要，可以写出两个语句进行分别统计
select count(*) from users where sex = '女';
select count(*) from users where sex = '男';
-- 可以使用分组进行统计，更方便
select sex,count(*) from users group by sex;
-- 统计1班和2班的人数
select classid,count(*) from users group by classid;
-- 分别统计每个班级的男女生人数
select classid,sex,count(*) as num from users group by classid,sex;
# 注意，在使用。group by分组时，一般除了聚合函数，其它在select后面出现的字段列都需要出现在group by 后面
</code></pre>
<p><strong>Having 子句</strong><br>
having时在分组聚合计算后，对结果再一次进行过滤，类似于where，<br>
where过滤的是行数据，having过滤的是分组数据</p>
<pre><code class="language-javascript">-- 要统计班级人数
select classid,count(*) from users group by classid;
-- 统计班级人数，并且要人数达到5人及以上
select classid,count(*) as num from users group by classid having num &gt;=5;
</code></pre>
<ol start="6">
<li>Order by分组<br>
我们在mysql中使用select的语句查询的数据结果是根据数据在底层文件的结构来排序的，<br>
首先不要依赖默认的排序，另外在需要排序时要使用orderby对返回的结果进行排序<br>
Asc 升序，默认<br>
desc降序</li>
</ol>
<pre><code class="language-javascript">-- 按照年龄对结果进行排序，从大到小
select * from users order by age desc;
-- 从小到大排序 asc 默认就是。可以不写
select * from users order by age;
-- 也可以按照多个字段进行排序
select * from users order by age,id; # 先按照age进行排序，age相同情况下，按照id进行排序
select * from users order by age,id desc;
</code></pre>
<ol start="7">
<li>Limit数据分页<br>
limit n 提取n条数据，<br>
limit m,n 跳过m跳数据，提取n条数据</li>
</ol>
<pre><code class="language-javascript">-- 查询users表中的数据，只要3条
select * from users limit 3;
-- 跳过前4条数据，再取3条数据
select * from users limit 4,3;
-- limit一般应用在数据分页上面
-- 例如每页显示10条数据，第三页的 limit应该怎么写？ 思考
第一页 limit 0,10
第二页 limit 10,10
第三页 limit 20,10
第四页 limit 30,10
-- 提取 user表中 年龄最大的三个用户数据 怎么查询？
select * from users order by age desc limit 3;
</code></pre>
<ul>
<li><strong>向表中插入数据</strong></li>
</ul>
<pre><code class="language-javascript">--标准添加（指定所有字段，给定所有的值）
 insert into stu(id,name,age,sex,classid) values(1,'zhangsan',20,'m','lamp138');
--指定部分字段添加值
insert into stu(name,classid) value('lisi','lamp138');
-- 不指定字段添加值
 insert into stu value(null,'wangwu',21,'w','lamp138');
-- 批量添加值
insert into stu values
-&gt; (null,'zhaoliu',25,'w','lamp94'),
-&gt; (null,'uu01',26,'m','lamp94'),
-&gt; (null,'uu02',28,'w','lamp92'),
-&gt; (null,'qq02',24,'m','lamp92'),
-&gt; (null,'uu03',32,'m','lamp138'),
-&gt; (null,'qq03',23,'w','lamp94'),
-&gt; (null,'aa',19,'m','lamp138');
</code></pre>
<ul>
<li><strong>修改表中的数据</strong></li>
</ul>
<pre><code class="language-javascript">update 表名 set 字段=某个值 where 条件;
update 表名 set 字段1=值1,字段2=值2 where 条件;
update 表名 set 字段=字段+值 where 条件;
-- 将id为11的age改为35，sex改为m值
mysql&gt; update stu set age=35,sex='m' where id=11;
Query OK, 1 row affected (0.16 sec)
Rows matched: 1 Changed: 1 Warnings: 0
-- 将id值为12和14的数据值sex改为m，classid改为lamp92
mysql&gt; update stu set sex='m',classid='lamp92' where id=12 or id=14 --等价于下面
mysql&gt; update stu set sex='m',classid='lamp92' where id in(12,14);
</code></pre>
<blockquote>
<p>MySQL中的运算符<br>
算术运算符： +、 -、 *、 /、 %<br>
比较运算符： =、 &gt;、 &lt;、 &gt;=、 &lt;=、!=<br>
数据库特有的比较： in、not in、is null、is not null、like、between、and<br>
逻辑运算符： and、or、not<br>
like: 支持特殊符号%和_ ;<br>
其中%表示任意数量的任意字符，_表示任意一位字符</p>
</blockquote>
<ul>
<li><strong>删除表中的数据</strong></li>
</ul>
<pre><code class="language-javascript">delete from 表名 where 字段=某个值;
-- 删除stu表中id值为100的数据
mysql&gt; delete from stu where id=100;
-- 删除stu表中id值为20到30的数据
mysql&gt; delete from stu where id&gt;=20 and id&lt;=30;
-- 删除stu表中id值为20到30的数据（等级于上面写法）
mysql&gt; delete from stu where id between 20 and 30;
-- 删除stu表中id值大于200的数据
mysql&gt; delete from stu where id&gt;200;
</code></pre>
<h2 id="mysql数据库的导入和导出">MySQL数据库的导入和导出</h2>
<ul>
<li><strong>数据导出</strong></li>
</ul>
<pre><code class="language-javascript">1、数据库数据导出
# 不要进入mysql，然后输入以下命令 导出某个库中的数据
mysqldump -u root -p tlxy &gt; ~/Desktop/code/tlxy.sql（文件路径）
2、将数据库中的表导出
# 不要进入mysql，然后输入以下命令 导出某个库中指定的表的数据
mysqldump -u root -p tlxy tts &gt; ~/Desktop/code/tlxy-tts.sql
</code></pre>
<ul>
<li><strong>数据导入</strong></li>
</ul>
<pre><code class="language-javascript"># 在新的数据库中 导入备份的数据，导入导出的sql文件
mysql -u root -p ops &lt; ./tlxy.sql
# 把导出的表sql 导入数据库
mysql -u root -p ops &lt; ./tlxy-tts.sql
</code></pre>
<ul>
<li><strong>权限管理</strong></li>
</ul>
<blockquote>
<p>mysql中的root用户是数据库中权限最高的用户，千万不要用在项目中。<br>
可以给不同的用户，或者项目，创建不同的mysql用户，并适当的授权，完成数据库的相关操作<br>
这样就一定程度上保证了数据库的安全。</p>
</blockquote>
<pre><code class="language-javascript">创建用户的语法格式：
grant 授权的操作 on 授权的库.授权的表 to 账户@登录地址 identified by ‘密码’;
# 在mysql中 创建一个 zhangsan 用户，授权可以对tlxy这个库中的所有表 进行 添加和查询 的权限
grant select,insert on tlxy.* to zhangsan@'%' identified by '123456';
# 用户 lisi。密码 123456 可以对tlxy库中的所有表有 所有操作权限
grant all on tlxy.* to lisi@'%' identified by '123456';
# 删除用户
drop user 'lisi'@'%';
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java基础学习——JSON 解析]]></title>
        <id>https://Vinci-Ma.github.io/post/java-ji-chu-xue-xi-json-jie-xi/</id>
        <link href="https://Vinci-Ma.github.io/post/java-ji-chu-xue-xi-json-jie-xi/">
        </link>
        <updated>2020-07-11T03:28:46.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#json%E7%AE%80%E4%BB%8B">JSON简介</a></li>
<li><a href="#json%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99">JSON语法规则</a></li>
<li><a href="#json%E8%A7%A3%E6%9E%90">JSON解析</a>
<ul>
<li><a href="#%E5%BC%95%E5%85%A5jar%E6%96%87%E4%BB%B6">引入JAR文件</a></li>
<li><a href="#gson">Gson</a>
<ul>
<li><a href="#1%E5%B0%86%E5%AF%B9%E8%B1%A1%E8%BD%AC%E6%8D%A2%E6%88%90-gson">1.将对象转换成 GSON</a></li>
<li><a href="#2%E5%B0%86json%E8%BD%AC%E6%8D%A2%E6%88%90%E5%AF%B9%E8%B1%A1">2.将JSON转换成对象</a></li>
</ul>
</li>
<li><a href="#fastjson">FastJson</a>
<ul>
<li><a href="#1%E5%B0%86%E5%AF%B9%E8%B1%A1%E8%BD%AC%E6%8D%A2%E6%88%90fastjson">1.将对象转换成FastJson</a></li>
<li><a href="#2%E5%B0%86fastjson%E8%BD%AC%E6%8D%A2%E6%88%90%E5%AF%B9%E8%B1%A1">2.将FastJson转换成对象</a></li>
</ul>
</li>
</ul>
</li>
</ul>
(Java基础学习——JSON 解析)</p>
<h1 id="json简介">JSON简介</h1>
<blockquote>
<p>JSON(JavaScript Object Notation, JS 对象简谱) 是<mark>一种轻量级的数据交换格式</mark>。它基于 ECMAScript (欧洲计算机协会制定的js规范)的一个子集，<mark>采用完全独立于编程语言的文本格式来存储和表示数据</mark>。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。<br>
【百度百科】</p>
</blockquote>
<h1 id="json语法规则">JSON语法规则</h1>
<ol>
<li>对象由大括号表示，括号中通过键值对描述对象的属性；</li>
<li>键与值之间使用冒号连接，多个键值对之间用逗号分离；</li>
<li>键值对的键，用引号引住；</li>
<li>键值对的值，可以是JS中任意类型的数据</li>
</ol>
<pre><code class="language-javascript">// 示例
{
	&quot;name&quot;:&quot;哈利·波特&quot;，
	&quot;friends&quot;:[&quot;赫敏&quot;,&quot;罗恩&quot;,
			{
			&quot;name&quot;:&quot;小天狼星布莱克&quot;
			&quot;status&quot;:&quot;哈利的教父&quot;}]
	&quot;wand&quot;:{
		&quot;length&quot;:&quot;11英寸&quot;,
		&quot;details&quot;:&quot;冬青木，杖芯是凤凰福克斯的尾毛&quot;
	}
}
</code></pre>
<h1 id="json解析">JSON解析</h1>
<h2 id="引入jar文件">引入JAR文件</h2>
<p><img src="https://Vinci-Ma.github.io/post-images/1594440402092.png" alt="1" loading="lazy"><br>
<img src="https://Vinci-Ma.github.io/post-images/1594440409797.png" alt="2" loading="lazy"><br>
<img src="https://Vinci-Ma.github.io/post-images/1594440445090.png" alt="3" loading="lazy"><br>
<img src="https://Vinci-Ma.github.io/post-images/1594440416932.png" alt="3.1" loading="lazy"><br>
<img src="https://Vinci-Ma.github.io/post-images/1594440421736.png" alt="3.2" loading="lazy"><br>
<img src="https://Vinci-Ma.github.io/post-images/1594440426566.png" alt="3.3" loading="lazy"><br>
<img src="https://Vinci-Ma.github.io/post-images/1594440432621.png" alt="3.4" loading="lazy"><br>
<img src="https://Vinci-Ma.github.io/post-images/1594440437486.png" alt="4" loading="lazy"></p>
<h2 id="gson">Gson</h2>
<p>由Google开发的， Java 语言实现的 JSON 解析器和生成器。<br>
<a href="https://github.com/google/gson">Gson JAR文件下载地址</a>.</p>
<h3 id="1将对象转换成-gson">1.将对象转换成 GSON</h3>
<pre><code class="language-javascript">//将对象转换成 GSON
		Person p = new Person(&quot;哈利波特&quot;, 
			 new String[]{&quot;赫敏&quot;, &quot;罗恩&quot;},
			 new String[]{&quot;11英寸&quot;,&quot;冬青木，杖芯是凤凰福克斯的尾毛&quot;});
        String s = new Gson().toJson(p);
        System.out.println(s);
</code></pre>
<p><strong>输出结果：</strong><br>
<img src="https://img-blog.csdnimg.cn/20200711105924659.png" alt="在这里插入图片描述" loading="lazy"></p>
<h3 id="2将json转换成对象">2.将JSON转换成对象</h3>
<pre><code class="language-javascript">//将JSON转换成对象
        Person p = new Gson().fromJson(&quot;{\&quot;name\&quot;:\&quot;哈利波特\&quot;,\&quot;friends\&quot;:[\&quot;赫敏\&quot;,\&quot;罗恩\&quot;],\&quot;wand\&quot;:[\&quot;11英寸\&quot;,\&quot;冬青木，杖芯是凤凰福克斯的尾毛\&quot;]}\n&quot;,Person.class);
        System.out.println(p.getName());
        System.out.println(p.getFriends()[0]);
        System.out.println(p.getWand()[1]);
</code></pre>
<p><strong>输出结果：</strong><br>
<img src="https://img-blog.csdnimg.cn/20200711110505590.png" alt="在这里插入图片描述" loading="lazy"></p>
<h2 id="fastjson">FastJson</h2>
<p>由阿里巴巴的工程师开发的， Java 语言实现的 JSON 解析器和生成器。<br>
<a href="https://github.com/alibaba/fastjson">FastJson JAR文件下载地址</a>.</p>
<h3 id="1将对象转换成fastjson">1.将对象转换成FastJson</h3>
<pre><code class="language-javascript">//将对象转换成FastJson
		Person p = new Person(&quot;哈利波特&quot;, 
			new String[]{&quot;赫敏&quot;, &quot;罗恩&quot;}, 
			new String[]{&quot;11英寸&quot;,&quot;冬青木，杖芯是凤凰福克斯的尾毛&quot;});
        String fjson = JSON.toJSONString(p);
		System.out.println(p);
</code></pre>
<p><strong>输出结果：</strong><br>
<img src="https://img-blog.csdnimg.cn/20200711111258310.png" alt="在这里插入图片描述" loading="lazy"></p>
<h3 id="2将fastjson转换成对象">2.将FastJson转换成对象</h3>
<pre><code class="language-javascript">//将FastJson转换成对象
        Person p = JSON.parseObject(&quot;{\&quot;name\&quot;:\&quot;哈利波特\&quot;,\&quot;friends\&quot;:[\&quot;赫敏\&quot;,\&quot;罗恩\&quot;],\&quot;wand\&quot;:[\&quot;11英寸\&quot;,\&quot;冬青木，杖芯是凤凰福克斯的尾毛\&quot;]}\n&quot;,Person.class);
        System.out.println(p.getName());
        System.out.println(p.toString());
</code></pre>
<p><strong>输出结果：</strong><br>
<img src="https://img-blog.csdnimg.cn/20200711112008345.png" alt="在这里插入图片描述" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java中的递归算法]]></title>
        <id>https://Vinci-Ma.github.io/post/java-zhong-de-di-gui-suan-fa/</id>
        <link href="https://Vinci-Ma.github.io/post/java-zhong-de-di-gui-suan-fa/">
        </link>
        <updated>2020-06-25T15:15:44.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E7%9A%84%E4%B8%89%E4%B8%AA%E6%9D%A1%E4%BB%B6">使用递归算法的三个条件</a></li>
<li><a href="#%E9%80%92%E5%BD%92%E7%9A%84%E5%BA%94%E7%94%A8">递归的应用</a></li>
<li><a href="#%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B">程序示例</a>
<ul>
<li><a href="#1-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97">1、斐波那契数列</a></li>
<li><a href="#2-%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98">2、汉诺塔问题</a></li>
<li><a href="#3-%E4%BA%8C%E5%8F%89%E6%A0%91">3、二叉树</a></li>
</ul>
</li>
</ul>
(Java中的递归算法)<br>
编程语言中，函数直接或间接调用函数本身，则该函数称为递归函数。程序调用自身的编程技巧称为递归（ recursion）。递归通常是把一个大问题转化成为与大问题解决方法相似的小问题来解决，一般递归需要有<mark>边界条件</mark>、<mark>递归前进段</mark>和<mark>递归返回段</mark>。当边界条件不满足时，递归前进；当边界条件满足时，递归返回。</p>
<h1 id="使用递归算法的三个条件">使用递归算法的三个条件</h1>
<ol>
<li>一个问题可以分解为几个子问题</li>
<li>分解形成的子问题，除了数据规模不同，求解思路与原问题相同</li>
<li>存在递归终止的条件</li>
</ol>
<h1 id="递归的应用">递归的应用</h1>
<p>递归算法一般用于解决三类问题：</p>
<ol>
<li><strong>数据的定义是按递归定义的</strong><br>
如：斐波那契数列（Fibonacci sequence）</li>
<li><strong>问题解法按递归算法实现</strong><br>
如：汉诺塔问题（Hanoi）</li>
<li><strong>数据的结构形式是按递归定义的</strong><br>
如：二叉树、广义表等</li>
</ol>
<h1 id="程序示例">程序示例</h1>
<h2 id="1-斐波那契数列">1、斐波那契数列</h2>
<p>斐波那契数列（Fibonacci sequence），又称黄金分割数列，是这样一组数列：1、1、2、3、5、8、13、21、34、……从这个数列的第3项开始，每一项都等于前两项数字的和。</p>
<pre><code class="language-javascript">for (int i = 1;i &lt; 10;i++){
            System.out.printf(&quot;%4d&quot;,fibonacci(i));
        }
//结果为：   1   1   2   3   5   8  13  21  34

//f(n) = f(n - 1) + f(n - 2)
static int fibonacci(int nums){
        if (nums &lt; 0){
            return 1;
        }else if (nums &lt; 3){
            return 1;
        }else
            return fibonacci(nums - 1) + fibonacci(nums - 2);
    }
</code></pre>
<h2 id="2-汉诺塔问题">2、汉诺塔问题</h2>
<blockquote>
<p>相传在古印度圣庙中，有一种被称为汉诺塔(Hanoi)的游戏。该游戏是在一块铜板装置上，有三根杆(编号A、B、C)，在A杆自下而上、由大到小按顺序放置64个金盘(如下图)。游戏的目标：把A杆上的金盘全部移到C杆上，并仍保持原有顺序叠好。操作规则：每次只能移动一个盘子，并且在移动过程中三根杆上都始终保持大盘在下，小盘在上，操作过程中盘子可以置于A、B、C任一杆上。<br>
【百度百科】</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200705001114632.png" alt="汉诺塔" loading="lazy"><br>
思路：<br>
【注：start为圆盘开始时的位置，mid 为圆盘暂时存放的位置，last 为圆盘最终需要到达的位置】</p>
<ol>
<li>当圆盘个数为1时，可以直接从 start 移动到 last</li>
<li>当圆盘个数为n时，需要把（n - 1）个圆盘移动到 mid</li>
<li>最后把剩下的圆盘移动到 last</li>
</ol>
<pre><code class="language-javascript">hanoi(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,3);

static void hanoi(String start,String mid,String last,int n){
        if(n == 1){
            System.out.println(start+&quot;------&gt;&quot;+last);
        }else{
            //把 n - 1 个圆盘移动到过渡位置
            hanoi(start,last,mid,n-1);
            //把最底层的圆盘移动到最后的位置
            hanoi(start,mid,last,1);
            //把在过渡位置的 n - 1 个圆盘移动到最终的位置
            hanoi(mid,start,last,n-1);
        }

    }
</code></pre>
<p><strong>结果：</strong><br>
<img src="https://img-blog.csdnimg.cn/20200705003826677.png" alt="结果" loading="lazy"><br>
<strong>动画演示</strong><br>
<img src="https://Vinci-Ma.github.io/post-images/1593881942534.gif" alt="" loading="lazy"></p>
<h2 id="3-二叉树">3、二叉树</h2>
<p>见前篇<br>
链接: <a href="https://vinci-ma.github.io/post/er-cha-shu-bian-li-java-de-dai-ma-shi-xian/">二叉树遍历——Java的代码实现</a>.</p>
]]></content>
    </entry>
</feed>