<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Vinci-Ma.github.io</id>
    <title>Vinci-Ma</title>
    <updated>2020-07-04T10:52:06.209Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Vinci-Ma.github.io"/>
    <link rel="self" href="https://Vinci-Ma.github.io/atom.xml"/>
    <subtitle>Stay cooool!</subtitle>
    <logo>https://Vinci-Ma.github.io/images/avatar.png</logo>
    <icon>https://Vinci-Ma.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Vinci-Ma</rights>
    <entry>
        <title type="html"><![CDATA[二叉树遍历Java的代码实现]]></title>
        <id>https://Vinci-Ma.github.io/post/er-cha-shu-bian-li-java-de-dai-ma-shi-xian</id>
        <link href="https://Vinci-Ma.github.io/post/er-cha-shu-bian-li-java-de-dai-ma-shi-xian">
        </link>
        <updated>2020-06-24T13:14:39.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91">二叉树</a></li>
<li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86">二叉树的遍历</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">代码实现</a>
<ul>
<li><a href="#%E9%A6%96%E5%85%88%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9">首先创建一个结点</a></li>
<li><a href="#%E5%85%B6%E6%AC%A1%E6%98%AF%E8%BF%9B%E8%A1%8C%E9%81%8D%E5%8E%86%E6%93%8D%E4%BD%9C%E7%9A%84binarytree%E7%B1%BB">其次是进行遍历操作的BinaryTree类</a>
<ul>
<li><a href="#%E8%83%BD%E5%A4%9F%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E7%9A%84%E4%B8%89%E4%B8%AA%E6%9D%A1%E4%BB%B6">能够使用递归的三个条件</a></li>
<li><a href="#%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95%E8%AF%A6%E8%BF%B0%E4%BB%A5%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E4%B8%BA%E4%BE%8B">递归实现二叉树遍历方法详述（以中序遍历为例）</a></li>
</ul>
</li>
<li><a href="#%E4%B8%BB%E5%87%BD%E6%95%B0">主函数</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C">输出结果</a></li>
</ul>
</li>
</ul>
</p>
<h1 id="二叉树">二叉树</h1>
<p>二叉树是树的一种，每个结点最多可具有两个子树，即结点的度最大为2</p>
<h1 id="二叉树的遍历">二叉树的遍历</h1>
<p>先序遍历：先访问根节点，然后访问左节点，最后访问右节点。<br>
【1-&gt;2-&gt;4-&gt;8-&gt;9-&gt;5-&gt;10-&gt;3-&gt;6-&gt;7】<br>
<img src="https://img-blog.csdnimg.cn/20200627000853767.png?x-oss-process=image" alt="在这里插入图片描述" loading="lazy"><br>
中序遍历：先访问左节点，然后访问根节点，最后访问右节点。<br>
【8-&gt;4-&gt;9-&gt;2-&gt;10-&gt;5-&gt;1-&gt;6-&gt;3-&gt;7】<br>
<img src="https://img-blog.csdnimg.cn/20200627001030262.png?x-oss-process=image" alt="在这里插入图片描述" loading="lazy"><br>
后序遍历：先访问左节点，然后访问右节点，最后访问根节点。<br>
【8-&gt;9-&gt;4-&gt;10-&gt;5-&gt;2-&gt;6-&gt;7-&gt;3-&gt;1】<br>
<img src="https://img-blog.csdnimg.cn/20200627001118497.png?x-oss-process=image" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="代码实现">代码实现</h1>
<h2 id="首先创建一个结点">首先创建一个结点</h2>
<p>这个结点包括，一个根结点，一个根所对应的左结点，一个根所对应的右节点</p>
<pre><code class="language-javascript">public class Node {
    Object data;
    Node left = null;
    Node right = null;
    void Node(Object data,Node left,Node right){
        this.data = data;
        this.left = left;
        this.right = right;
    }
}
</code></pre>
<h2 id="其次是进行遍历操作的binarytree类">其次是进行遍历操作的BinaryTree类</h2>
<p>用递归的方法实现遍历</p>
<pre><code class="language-javascript">public class BinaryTree {
// 先序遍历
    void preSearch(Node root){
        if (root != null){
            System.out.printf(&quot;%-4s&quot;,root.data);
            preSearch(root.left);
            preSearch(root.right);
        }
    }
    // 中序遍历
    void midSearch(Node root){
        if (root != null){
            midSearch(root.left);
            System.out.printf(&quot;%-4s&quot;,root.data);
            midSearch(root.right);
        }
    }
    // 后序遍历
    void bacSearch(Node root){
        if (root != null){
            bacSearch(root.left);
            bacSearch(root.right);
            System.out.printf(&quot;%-4s&quot;,root.data);
        }
    }
}
</code></pre>
<h3 id="能够使用递归的三个条件">能够使用递归的三个条件</h3>
<ol>
<li>一个问题可以分解成几个子问题。</li>
<li>这个问题与分解过后的子问题，除了数据规模不同（子问题更为简单），求解思路完全一样。</li>
<li>存在一个明确的递归终止条件。</li>
</ol>
<p>在此例中，</p>
<ol>
<li>遍历二叉树的操作可以分解为遍历单个结点的操作。</li>
<li>遍历整个二叉树的操作和遍历一个结点的操作相同。</li>
<li>存在截止条件，即根节点不为null。</li>
</ol>
<p>所以，可以使用递归实现二叉树的遍历。</p>
<h3 id="递归实现二叉树遍历方法详述以中序遍历为例">递归实现二叉树遍历方法详述（以中序遍历为例）</h3>
<p><img src="https://img-blog.csdnimg.cn/20200627001030262.png?x-oss-process=image" alt="" loading="lazy"><br>
<img src="https://Vinci-Ma.github.io/post-images/1593329449625.jpg" alt="" loading="lazy"></p>
<h2 id="主函数">主函数</h2>
<pre><code class="language-javascript">public class E1 {
    public static void main(String[] args) {
        //构造一个二叉树
        Node node10 = new Node();
        node10.Node(&quot;10&quot;,null,null);
        Node node9 = new Node();
        node9.Node(&quot;9&quot;,null,null);
        Node node8 = new Node();
        node8.Node(&quot;8&quot;,null,null);
        Node node7 = new Node();
        node7.Node(&quot;7&quot;,null,null);
        Node node6 = new Node();
        node6.Node(&quot;6&quot;,null,null);
        Node node5 = new Node();
        node5.Node(&quot;5&quot;,node10,null);
        Node node4 = new Node();
        node4.Node(&quot;4&quot;,node8,node9);
        Node node3 = new Node();
        node3.Node(&quot;3&quot;,node6,node7);
        Node node2 = new Node();
        node2.Node(&quot;2&quot;,node4,node5);
        Node node1 = new Node();
        node1.Node(&quot;1&quot;,node2,node3);
        BinaryTree b = new BinaryTree();
        //对所构造的二叉树遍历输出
        System.out.println(&quot;前序遍历输出：&quot;);
        b.preSearch(node1);
        System.out.println();
        System.out.println(&quot;中序遍历输出：&quot;);
        b.midSearch(node1);
        System.out.println();
        System.out.println(&quot;后序遍历输出：&quot;);
        b.bacSearch(node1);
    }
}
</code></pre>
<h2 id="输出结果">输出结果</h2>
<figure data-type="image" tabindex="1"><img src="https://Vinci-Ma.github.io/post-images/1593178800956.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java基础学习——面向对象]]></title>
        <id>https://Vinci-Ma.github.io/post/java-ji-chu-xue-xi-mian-xiang-dui-xiang</id>
        <link href="https://Vinci-Ma.github.io/post/java-ji-chu-xue-xi-mian-xiang-dui-xiang">
        </link>
        <updated>2020-06-20T13:37:01.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3">面向对象思想</a>
<ul>
<li><a href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E6%80%9D%E6%83%B3">面向对象的三大思想</a></li>
<li><a href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81">面向对象的三大特征</a>
<ul>
<li><a href="#%E5%B0%81%E8%A3%85">封装</a></li>
<li><a href="#%E7%BB%A7%E6%89%BF">继承</a></li>
<li><a href="#%E5%A4%9A%E6%80%81">多态</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<h1 id="面向对象思想">面向对象思想</h1>
<p>面向对象（Object Oriented）是软件开发方法。面向对象（Procedure Oriented）是相对于面向过程来说的，指的是把相关的数据和方法组织为一个整体来看待。面向过程关注的是执行的过程，面向对象关注的是具备功能的对象。</p>
<h2 id="面向对象的三大思想">面向对象的三大思想</h2>
<p>OOA（Object Oriented Analysis）：面向对象分析<br>
OOD（Object Oriented Design）：面向对象设计<br>
OOP（Object Oriented Programming）：面向对象程序</p>
<h2 id="面向对象的三大特征">面向对象的三大特征</h2>
<h3 id="封装">封装</h3>
<p>1、隐藏具体的实现细节【安全性】<br>
2、对外提供公共的访问方式【功能】</p>
<h3 id="继承">继承</h3>
<p>1、子类可以继承父类的所有非私有成员（成员属性和成员方法）。<br>
2、子类不可以继承父类的构造，但是默认访问父类的空参构造。<br>
3、只可以单继承，不能多继承，但是可以多级继承。</p>
<h3 id="多态">多态</h3>
<p><strong>多态的前提：</strong></p>
<ol>
<li>有类的继承或接口的实现</li>
<li>子类重写父类的方法</li>
<li>父类引用指向子类对象</li>
</ol>
<p><strong>多态的成员访问特点：</strong></p>
<ol>
<li>属性：编译看父类，运行看父类 --- 只有父类有的，编译才能够通过&lt;-多态的弊端产生的原因</li>
<li><mark>功能：编译看父类，运行看子类</mark></li>
</ol>
<p>对于多态访问特点的理解：父类的引用指向子类的对象，可以理解为，fu的外在表现为父类，而实际内核是子类。<br>
对于属性来说，表现的是外在的特征，所以属性的运行看的是父类；<br>
而调用方法表现的是本质，所以运行的结果是子类。</p>
<pre><code class="language-javascript">//示例如下
public class E1 {
    public static void main(String[] args) {
        Fu fu = new Zi();// 3、父类的引用指向子类的对象
        fu.say();//结果：=====子类   ---&gt;对于功能来说：编译看父类，运行看子类
        //fu.show;----&gt;编译报错
        System.out.println(fu.name);//结果：父类   ---&gt;对于属性来说：编译看父类，运行看父类
        //System.out.println(fu.age);----&gt;编译报错
        Zi zi = (Zi) fu;//向下转型
        zi.show();//结果：=====子类show
    }
}
class Fu{
    String name = &quot;父类&quot;;
    public void say(){
        System.out.println(&quot;=====父类&quot;);
    }
}
class Zi extends Fu{  // 1、有类的继承或接口的实现
    String name = &quot;子类&quot;;
    int age;
    public void say(){  // 2、子类重写父类的方法
        System.out.println(&quot;=====子类&quot;);
    }
    public void show(){  
        System.out.println(&quot;=====子类show&quot;);
    }
}
</code></pre>
<p><strong>多态的成员访问特点：</strong></p>
<ol>
<li>属性：编译看父类，运行看父类 --- 只有父类有的，编译才能够通过&lt;-多态的弊端产生的原因</li>
<li>功能：编译看父类，运行看子类</li>
</ol>
<p><strong>多态的弊端：</strong><br>
不能访问子类特有的成员</p>
<p><mark><strong>应用场景：</strong></mark><br>
<mark>当做形参传递使用</mark></p>
<pre><code class="language-javascript">//例如在调用时
say(&quot;aaa&quot;);

 //在定义该方法时，根本不需要指导具体的子类是谁，但是可以保证最终执行的是子类的功能
void say(Object o ){
    //实际参数 ====&gt; 形式参数  Object o = &quot;aaa&quot;;   形成了多态【父类引用指向子类的对象】
     System.out.println(o);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java基础学习——数组及其常用算法]]></title>
        <id>https://Vinci-Ma.github.io/post/java-ji-chu-xue-xi-shu-zu-ji-qi-chang-yong-suan-fa</id>
        <link href="https://Vinci-Ma.github.io/post/java-ji-chu-xue-xi-shu-zu-ji-qi-chang-yong-suan-fa">
        </link>
        <updated>2020-06-18T07:49:56.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E6%95%B0%E7%BB%84">数组</a>
<ul>
<li><a href="#%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84">一维数组</a>
<ul>
<li><a href="#%E5%88%9B%E5%BB%BA%E6%A0%BC%E5%BC%8F">创建格式</a></li>
<li><a href="#%E9%80%9A%E8%BF%87%E4%B8%8B%E6%A0%87%E5%AF%B9%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E6%93%8D%E4%BD%9C">通过下标对数据进行操作</a></li>
<li><a href="#%E8%8E%B7%E5%8F%96%E6%95%B0%E7%BB%84%E7%9A%84%E9%95%BF%E5%BA%A6">获取数组的长度</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84">二维数组</a>
<ul>
<li><a href="#%E5%88%9B%E5%BB%BA%E6%A0%BC%E5%BC%8F-2">创建格式</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95">数组常用算法</a>
<ul>
<li><a href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F">冒泡排序</a>
<ul>
<li><a href="#%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86">算法原理</a></li>
<li><a href="#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0">算法实现</a>
<ul>
<li><a href="#%E5%88%9D%E5%A7%8B%E7%8A%B6%E6%80%81">初始状态：</a></li>
<li><a href="#%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%BE%AA%E7%8E%AF">第一次循环：</a></li>
<li><a href="#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%BE%AA%E7%8E%AF">第二次循环：</a></li>
<li><a href="#%E7%AC%AC%E4%B8%89%E6%AC%A1%E5%BE%AA%E7%8E%AF">第三次循环：</a></li>
<li><a href="#%E7%AC%AC%E5%9B%9B%E6%AC%A1%E5%BE%AA%E7%8E%AF">第四次循环：</a></li>
<li><a href="#%E6%9C%80%E7%BB%88%E8%BE%93%E5%87%BA">最终输出</a></li>
</ul>
</li>
<li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">代码实现</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE">二分查找</a>
<ul>
<li><a href="#%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86-2">算法原理</a></li>
<li><a href="#%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4">实现步骤</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2">代码实现</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<h1 id="数组">数组</h1>
<p>所谓数组，是有序的元素序列。在java语言中，数组是一种最简单的复合数据类型，它是由一些具有相同的数据类型的元素所构成的，可以用一个统一的数组名和下标来唯一地确定数组中的元素。数组有一维数组和多维数组。</p>
<h2 id="一维数组">一维数组</h2>
<h3 id="创建格式">创建格式</h3>
<p>其中第1、2种较为常用<br>
1、数据类型[ ] 数组名称 = {数组内容1，数组内容2，……，数组内容n}；</p>
<pre><code class="language-javascript">// 示例如下
int[] age = {1, 2, 3 ,4};
</code></pre>
<p>2、数据类型[ ] 数组名称 = new 数据类型[数组长度]；</p>
<pre><code class="language-javascript">// 示例如下
int[] age = new int[4];
</code></pre>
<p>3、数据类型 [ ] 数组名称 = new 数据类型[ ] {数组内容1，数组内容2，……，数组内容n}；</p>
<pre><code class="language-javascript">// 示例如下
int[] age = new int[]{1, 2, 3 ,4};
</code></pre>
<p>4、数据类型[ ] 数组名；<br>
该种方法只创建了数组引用名，并未在内存中创建数组空间，只能通过以下方式进行初始化设置。</p>
<pre><code class="language-javascript">// 示例如下
int[] age;
age = new int[4];
</code></pre>
<h3 id="通过下标对数据进行操作">通过下标对数据进行操作</h3>
<p>赋值操作：<br>
数组名[下标] = 值；</p>
<pre><code class="language-javascript">// 把13赋予了age数组中的第一个元素，该元素在数组中的编号为0
age[0] = 13;
</code></pre>
<p>取值操作：<br>
数组名[下标]</p>
<pre><code class="language-javascript">// 示例如下
age[0];
</code></pre>
<h3 id="获取数组的长度">获取数组的长度</h3>
<p>数组名称.length</p>
<pre><code class="language-javascript">// 示例如下
age.length;
</code></pre>
<h2 id="二维数组">二维数组</h2>
<h3 id="创建格式-2">创建格式</h3>
<p>数据类型[ ][ ] 数组名 = new 数据类型[长度][(可写可不写) ]；</p>
<pre><code class="language-javascript">// 示例如下
int[][] age = new int [4][];
</code></pre>
<h1 id="数组常用算法">数组常用算法</h1>
<h2 id="冒泡排序">冒泡排序</h2>
<p>冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。它重复地走访过要排序的元素列，依次比较两个相邻的元素，如果顺序（如从大到小、首字母从Z到A）错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素列已经排序完成。<br>
【以下以升序排列为例】</p>
<h3 id="算法原理">算法原理</h3>
<p>1、比较相邻两个数值的大小，将数值较大的移动到右边。<br>
2、对每一对相邻元素都进行1中的比较，直到所有相邻元素都经过了比较。此时完成一次外层循环，将最大的数值移动到了数组最右边。<br>
3、重复1、2的操作，直至所有的元素在数组中都按照从小到大的顺序排列。</p>
<h3 id="算法实现">算法实现</h3>
<p>以数组nums = {1,15,9,5,7}为例</p>
<h4 id="初始状态">初始状态：</h4>
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">15</th>
<th style="text-align:center">9</th>
<th style="text-align:center">5</th>
<th style="text-align:center">7</th>
</tr>
</thead>
<tbody></tbody>
</table>
<h4 id="第一次循环">第一次循环：</h4>
<p>第1趟排序：<br>
1和15相比较</p>
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">15</th>
<th style="text-align:center">9</th>
<th style="text-align:center">5</th>
<th style="text-align:center">7</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>第2趟排序：<br>
15和9相比较</p>
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">9</th>
<th style="text-align:center">15</th>
<th style="text-align:center">5</th>
<th style="text-align:center">7</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>第3趟排序：<br>
15和5相比较</p>
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">9</th>
<th style="text-align:center">5</th>
<th style="text-align:center">15</th>
<th style="text-align:center">7</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>第4趟排序：<br>
15和7相比较</p>
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">9</th>
<th style="text-align:center">5</th>
<th style="text-align:center">7</th>
<th style="text-align:center">15</th>
</tr>
</thead>
<tbody></tbody>
</table>
<h4 id="第二次循环">第二次循环：</h4>
<p>第1趟排序：<br>
1和9相比较</p>
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">9</th>
<th style="text-align:center">5</th>
<th style="text-align:center">7</th>
<th style="text-align:center">15</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>第2趟排序：<br>
9和5相比较</p>
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">5</th>
<th style="text-align:center">9</th>
<th style="text-align:center">7</th>
<th style="text-align:center">15</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>第3趟排序：<br>
9和7相比较</p>
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">5</th>
<th style="text-align:center">7</th>
<th style="text-align:center">9</th>
<th style="text-align:center">15</th>
</tr>
</thead>
<tbody></tbody>
</table>
<h4 id="第三次循环">第三次循环：</h4>
<p>第1趟排序：<br>
1和5相比较</p>
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">5</th>
<th style="text-align:center">7</th>
<th style="text-align:center">9</th>
<th style="text-align:center">15</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>第2趟排序：<br>
5和7相比较</p>
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">5</th>
<th style="text-align:center">7</th>
<th style="text-align:center">9</th>
<th style="text-align:center">15</th>
</tr>
</thead>
<tbody></tbody>
</table>
<h4 id="第四次循环">第四次循环：</h4>
<p>第1趟排序：<br>
1和5相比较</p>
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">5</th>
<th style="text-align:center">7</th>
<th style="text-align:center">9</th>
<th style="text-align:center">15</th>
</tr>
</thead>
<tbody></tbody>
</table>
<h4 id="最终输出">最终输出</h4>
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">5</th>
<th style="text-align:center">7</th>
<th style="text-align:center">9</th>
<th style="text-align:center">15</th>
</tr>
</thead>
<tbody></tbody>
</table>
<h3 id="代码实现">代码实现</h3>
<pre><code class="language-javascript">	// 示例如下
	int[] nums = {1,15,9,5,7};
	for(int i=0; i&lt;nums.length; i++) {
		for(int j=0; j&lt;nums.length-i-1; j++) {
		//如果nums[j+1]的值小于nums[j]，则交换两者位置，使得较大的数字在右边
			if(nums[j+1]&lt;nums[j]) {
				nums[j+1] = nums[j] + nums[j+1];
				nums[j] = nums[j+1] - nums[j];
				nums[j+1] = nums[j+1] - nums[j];					
			}
		}
	}
	//利用for循环输出数组
	System.out.println(&quot;排序后的数组：&quot;);
	for(int i=0; i&lt;nums.length;i++)
	System.out.print(nums[i]+&quot;  &quot;);
</code></pre>
<p>编译结果<br>
<img src="https://img-blog.csdnimg.cn/20200613143855899.png" alt="编译结果" loading="lazy"></p>
<h2 id="二分查找">二分查找</h2>
<p>二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，二分查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。</p>
<h3 id="算法原理-2">算法原理</h3>
<p>1、假设数组中元素是有序排列，将数组中间位置的数据与查找数据比较，如果两者相等，则查找成功。<br>
2、否则利用中间位置记录将数组分成前、后两个子数组，如果中间位置数据大于查找数据，则进一步查找前子数<br>
组，否则进一步查找后子数组。<br>
3、重复以上过程，直到找到满足条件的数据，则表示查找成功，直到子数组不存在为止，表示查找不成功。</p>
<h3 id="实现步骤">实现步骤</h3>
<p>1、确定查找范围，最小——最大<br>
2、计算中间下标  =（最小+最大）/2<br>
3、比较中间下标和寻找的数据大小关系，如果中间下标所对应的元素比所寻找的数字小，则证明所要寻找的数字在数组的右半段，令最小下标 = 中间下标 + 1，中间下标  =（最小+最大）/2，最大下标不变，继续寻找。<br>
4、如果最小下标 &gt; 最大下标，说明数据不存在</p>
<h3 id="代码实现-2">代码实现</h3>
<pre><code class="language-javascript">// 示例如下
//使用二分法查找6，nums为上述冒泡排序示例
		int a = 6;
		int max = nums.length - 1;
		int min = 0;
		int mid =  (max + min)/2;
		while(true) {
			if(nums[mid] == a)
				break;
			//所要查找的数字在右半段
			else if(nums[mid] &lt; a) {
				min = mid + 1;
				mid = (max + min)/2;
			}
			//所要查找的数据在左半端
			else if(nums[mid] &gt; a) {
				max = mid - 1;
				mid = (max + min)/2;
			}
			
			if(min &gt; max){
				mid = -1;
				break;		
			}
			
		}
		if(mid == -1)
			System.out.println(&quot;没有这个数&quot;);
		else
			System.out.println(&quot;找到了&quot;+a+&quot;，其下标为：&quot;+mid);
</code></pre>
<p>编译结果：<br>
当a = 6时，即所要查找的数字是6<br>
<img src="https://img-blog.csdnimg.cn/2020061314410351.png" alt="当a = 6时" loading="lazy"><br>
当a = 9时，即所要查找的数字是9<br>
<img src="https://img-blog.csdnimg.cn/20200613150423899.png" alt="当a = 9时" loading="lazy"></p>
]]></content>
    </entry>
</feed>