<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Vinci-Ma.github.io</id>
    <title>Vinci-Ma</title>
    <updated>2020-07-14T02:58:33.624Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Vinci-Ma.github.io"/>
    <link rel="self" href="https://Vinci-Ma.github.io/atom.xml"/>
    <subtitle>Stay cooool!</subtitle>
    <logo>https://Vinci-Ma.github.io/images/avatar.png</logo>
    <icon>https://Vinci-Ma.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Vinci-Ma</rights>
    <entry>
        <title type="html"><![CDATA[Java基础学习——JSON 解析]]></title>
        <id>https://Vinci-Ma.github.io/post/java-ji-chu-xue-xi-json-jie-xi/</id>
        <link href="https://Vinci-Ma.github.io/post/java-ji-chu-xue-xi-json-jie-xi/">
        </link>
        <updated>2020-07-11T03:28:46.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#json%E7%AE%80%E4%BB%8B">JSON简介</a></li>
<li><a href="#json%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99">JSON语法规则</a></li>
<li><a href="#json%E8%A7%A3%E6%9E%90">JSON解析</a>
<ul>
<li><a href="#%E5%BC%95%E5%85%A5jar%E6%96%87%E4%BB%B6">引入JAR文件</a></li>
<li><a href="#gson">Gson</a>
<ul>
<li><a href="#1%E5%B0%86%E5%AF%B9%E8%B1%A1%E8%BD%AC%E6%8D%A2%E6%88%90-gson">1.将对象转换成 GSON</a></li>
<li><a href="#2%E5%B0%86json%E8%BD%AC%E6%8D%A2%E6%88%90%E5%AF%B9%E8%B1%A1">2.将JSON转换成对象</a></li>
</ul>
</li>
<li><a href="#fastjson">FastJson</a>
<ul>
<li><a href="#1%E5%B0%86%E5%AF%B9%E8%B1%A1%E8%BD%AC%E6%8D%A2%E6%88%90fastjson">1.将对象转换成FastJson</a></li>
<li><a href="#2%E5%B0%86fastjson%E8%BD%AC%E6%8D%A2%E6%88%90%E5%AF%B9%E8%B1%A1">2.将FastJson转换成对象</a></li>
</ul>
</li>
</ul>
</li>
</ul>
(Java基础学习——JSON 解析)</p>
<h1 id="json简介">JSON简介</h1>
<blockquote>
<p>JSON(JavaScript Object Notation, JS 对象简谱) 是<mark>一种轻量级的数据交换格式</mark>。它基于 ECMAScript (欧洲计算机协会制定的js规范)的一个子集，<mark>采用完全独立于编程语言的文本格式来存储和表示数据</mark>。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。<br>
【百度百科】</p>
</blockquote>
<h1 id="json语法规则">JSON语法规则</h1>
<ol>
<li>对象由大括号表示，括号中通过键值对描述对象的属性；</li>
<li>键与值之间使用冒号连接，多个键值对之间用逗号分离；</li>
<li>键值对的键，用引号引住；</li>
<li>键值对的值，可以是JS中任意类型的数据</li>
</ol>
<pre><code class="language-javascript">// 示例
{
	&quot;name&quot;:&quot;哈利·波特&quot;，
	&quot;friends&quot;:[&quot;赫敏&quot;,&quot;罗恩&quot;,
			{
			&quot;name&quot;:&quot;小天狼星布莱克&quot;
			&quot;status&quot;:&quot;哈利的教父&quot;}]
	&quot;wand&quot;:{
		&quot;length&quot;:&quot;11英寸&quot;,
		&quot;details&quot;:&quot;冬青木，杖芯是凤凰福克斯的尾毛&quot;
	}
}
</code></pre>
<h1 id="json解析">JSON解析</h1>
<h2 id="引入jar文件">引入JAR文件</h2>
<p><img src="https://Vinci-Ma.github.io/post-images/1594440402092.png" alt="1" loading="lazy"><br>
<img src="https://Vinci-Ma.github.io/post-images/1594440409797.png" alt="2" loading="lazy"><br>
<img src="https://Vinci-Ma.github.io/post-images/1594440445090.png" alt="3" loading="lazy"><br>
<img src="https://Vinci-Ma.github.io/post-images/1594440416932.png" alt="3.1" loading="lazy"><br>
<img src="https://Vinci-Ma.github.io/post-images/1594440421736.png" alt="3.2" loading="lazy"><br>
<img src="https://Vinci-Ma.github.io/post-images/1594440426566.png" alt="3.3" loading="lazy"><br>
<img src="https://Vinci-Ma.github.io/post-images/1594440432621.png" alt="3.4" loading="lazy"><br>
<img src="https://Vinci-Ma.github.io/post-images/1594440437486.png" alt="4" loading="lazy"></p>
<h2 id="gson">Gson</h2>
<p>由Google开发的， Java 语言实现的 JSON 解析器和生成器。<br>
<a href="https://github.com/google/gson">Gson JAR文件下载地址</a>.</p>
<h3 id="1将对象转换成-gson">1.将对象转换成 GSON</h3>
<pre><code class="language-javascript">//将对象转换成 GSON
		Person p = new Person(&quot;哈利波特&quot;, 
			 new String[]{&quot;赫敏&quot;, &quot;罗恩&quot;},
			 new String[]{&quot;11英寸&quot;,&quot;冬青木，杖芯是凤凰福克斯的尾毛&quot;});
        String s = new Gson().toJson(p);
        System.out.println(s);
</code></pre>
<p><strong>输出结果：</strong><br>
<img src="https://img-blog.csdnimg.cn/20200711105924659.png" alt="在这里插入图片描述" loading="lazy"></p>
<h3 id="2将json转换成对象">2.将JSON转换成对象</h3>
<pre><code class="language-javascript">//将JSON转换成对象
        Person p = new Gson().fromJson(&quot;{\&quot;name\&quot;:\&quot;哈利波特\&quot;,\&quot;friends\&quot;:[\&quot;赫敏\&quot;,\&quot;罗恩\&quot;],\&quot;wand\&quot;:[\&quot;11英寸\&quot;,\&quot;冬青木，杖芯是凤凰福克斯的尾毛\&quot;]}\n&quot;,Person.class);
        System.out.println(p.getName());
        System.out.println(p.getFriends()[0]);
        System.out.println(p.getWand()[1]);
</code></pre>
<p><strong>输出结果：</strong><br>
<img src="https://img-blog.csdnimg.cn/20200711110505590.png" alt="在这里插入图片描述" loading="lazy"></p>
<h2 id="fastjson">FastJson</h2>
<p>由阿里巴巴的工程师开发的， Java 语言实现的 JSON 解析器和生成器。<br>
<a href="https://github.com/alibaba/fastjson">FastJson JAR文件下载地址</a>.</p>
<h3 id="1将对象转换成fastjson">1.将对象转换成FastJson</h3>
<pre><code class="language-javascript">//将对象转换成FastJson
		Person p = new Person(&quot;哈利波特&quot;, 
			new String[]{&quot;赫敏&quot;, &quot;罗恩&quot;}, 
			new String[]{&quot;11英寸&quot;,&quot;冬青木，杖芯是凤凰福克斯的尾毛&quot;});
        String fjson = JSON.toJSONString(p);
		System.out.println(p);
</code></pre>
<p><strong>输出结果：</strong><br>
<img src="https://img-blog.csdnimg.cn/20200711111258310.png" alt="在这里插入图片描述" loading="lazy"></p>
<h3 id="2将fastjson转换成对象">2.将FastJson转换成对象</h3>
<pre><code class="language-javascript">//将FastJson转换成对象
        Person p = JSON.parseObject(&quot;{\&quot;name\&quot;:\&quot;哈利波特\&quot;,\&quot;friends\&quot;:[\&quot;赫敏\&quot;,\&quot;罗恩\&quot;],\&quot;wand\&quot;:[\&quot;11英寸\&quot;,\&quot;冬青木，杖芯是凤凰福克斯的尾毛\&quot;]}\n&quot;,Person.class);
        System.out.println(p.getName());
        System.out.println(p.toString());
</code></pre>
<p><strong>输出结果：</strong><br>
<img src="https://img-blog.csdnimg.cn/20200711112008345.png" alt="在这里插入图片描述" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TCP连接的”三次握手“和”四次挥手“]]></title>
        <id>https://Vinci-Ma.github.io/post/tcp-lian-jie-de-san-ci-wo-shou-he-si-ci-hui-shou/</id>
        <link href="https://Vinci-Ma.github.io/post/tcp-lian-jie-de-san-ci-wo-shou-he-si-ci-hui-shou/">
        </link>
        <updated>2020-07-07T06:25:47.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#tcp%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B">TCP连接的”三次握手“</a>
<ul>
<li><a href="#tcp%E8%BF%9E%E6%8E%A5%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E5%BC%82%E5%B8%B8%E6%83%85%E5%86%B5">TCP连接”三次握手“的异常情况</a>
<ul>
<li><a href="#1-%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%AC%AC%E4%B8%80%E4%B8%AAsyn%E5%8C%85%E4%B8%A2%E4%BA%86"><strong>1、客户端第一个【SYN】包丢了</strong></a></li>
<li><a href="#2-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%94%B6%E5%88%B0syn%E5%9B%9E%E5%A4%8D%E4%BD%86%E6%98%AF%E5%9B%9E%E5%A4%8D%E7%9A%84synack%E5%8C%85%E4%B8%A2%E4%BA%86"><strong>2、服务器端收到【SYN】回复，但是回复的【SYN，ACK】包丢了</strong></a></li>
<li><a href="#3-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%94%B6%E5%88%B0synack%E5%8C%85%E5%9C%A8%E5%9B%9E%E5%A4%8D%E6%97%B6%E4%B8%A2%E5%A4%B1ack%E5%8C%85"><strong>3、客户端收到【SYN，ACK】包，在回复时丢失【ACK】包</strong></a></li>
<li><a href="#4-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%95%85%E6%84%8F%E4%B8%8D%E5%8F%91%E6%9C%80%E5%90%8E%E4%B8%80%E6%AC%A1syn%E5%8C%85"><strong>4、客户端故意不发最后一次【SYN】包</strong></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#tcp%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B">TCP连接的”四次挥手“</a>
<ul>
<li><a href="#tcp%E8%BF%9E%E6%8E%A5%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%9A%84%E5%BC%82%E5%B8%B8%E6%83%85%E5%86%B5%E4%BB%A5%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%A6%96%E5%85%88%E5%8F%91%E9%80%81fin%E4%B8%BA%E4%BE%8B">TCP连接“四次挥手”的异常情况（以客户端首先发送【FIN】为例）</a>
<ul>
<li><a href="#1-%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5%E7%9A%84fin%E5%8C%85%E4%B8%A2%E5%A4%B1"><strong>1、断开连接的【FIN】包丢失</strong></a></li>
<li><a href="#2-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%9B%9E%E5%A4%8D%E7%9A%84ack%E4%B8%A2%E5%8C%85"><strong>2、服务端第一次回复的【ACK】丢包</strong></a></li>
<li><a href="#3-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8F%91%E9%80%81%E7%9A%84-finack-%E4%B8%A2%E5%8C%85"><strong>3、服务端发送的 【FIN,ACK】 丢包</strong></a></li>
<li><a href="#4-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9C%80%E5%90%8E%E5%9B%9E%E5%A4%8D%E7%9A%84ack%E4%B8%A2%E5%8C%85"><strong>4、客户端最后回复的【ACK】丢包</strong></a></li>
<li><a href="#5-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%94%B6%E5%88%B0ack%E5%90%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%B7%91%E8%B7%AF%E4%BA%86"><strong>5. 客户端收到【ACK】后，服务端跑路了</strong></a></li>
<li><a href="#6-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%94%B6%E5%88%B0-ack-%E5%90%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%87%AA%E5%B7%B1%E8%B7%91%E8%B7%AF%E4%BA%86"><strong>6. 客户端收到 ACK 后，客户端自己跑路了</strong></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98">常见面试题</a></li>
</ul>
(TCP连接的”三次握手“和”四次挥手“)<br>
<img src="https://Vinci-Ma.github.io/post-images/1594630185256.png" alt="TCP连接的”三次握手“和”四次挥手“图示" loading="lazy"></p>
<h1 id="tcp连接的三次握手">TCP连接的”三次握手“</h1>
<figure data-type="image" tabindex="1"><img src="https://Vinci-Ma.github.io/post-images/1594640308254.png" alt="三次握手" loading="lazy"></figure>
<ol>
<li>开始时，客户端和服务器端都处于CLOSE状态，【服务器为了提供服务，会主动监听某个端口，进入LISTEN状态】？？？？？？</li>
<li>客户端主动发送连接的 【SYN】 包，之后进入SYN-SENT状态，服务端在收到客户端发来的 【SYN】包后，回复 【SYN , ACK】包，之后进入 SYN-RCVD 状态。</li>
<li>客户端收到服务端发来的【SYN ,ACK】包后，可以确认对方的的存在，回复 【ACK】包，进入ESTABLISHED状态</li>
<li>服务端收到最后一个[ACK]包后，也进入ESTABLISHED状态</li>
</ol>
<p>正常的三次握手之后，双端都进入ESTABLISHED状态，然后开始传输数据。</p>
<h2 id="tcp连接三次握手的异常情况">TCP连接”三次握手“的异常情况</h2>
<h3 id="1-客户端第一个syn包丢了"><strong>1、客户端第一个【SYN】包丢了</strong></h3>
<ol>
<li>如果在TCP连接中，客户端的第一个【SYN】包丢了，而此时跟服务器端并无联系，所以处理办法在客户端。</li>
<li>在TCP协议中，任何一端的【请求——应答】过程中，在一定时间范围内没哟接收到对方的回应的【ACK】包，就会认为是丢包，此时触发超时重传机制。</li>
<li>此时会重传【SYN】包，会重传3次，时间间隔分别是： 5.8s、24s、48s，三次时间大约是 76s 左右，而大多数伯克利系统将建立一个新连接的最长时间，限制为 75s。</li>
</ol>
<p><mark>总结：</mark><br>
<mark>客户端第一个【SYN】包丢了：客户端会进行三次重传【SYN】包，总的尝试时间大约在75s左右。</mark></p>
<h3 id="2-服务器端收到syn回复但是回复的synack包丢了"><strong>2、服务器端收到【SYN】回复，但是回复的【SYN，ACK】包丢了</strong></h3>
<ol>
<li>对于客户端来说，在规定时间内没有接收到来自服务器端的回复，会认为是自己丢包了，会进行重传【SYN】包。</li>
<li>对于服务器端来说，发出的【SYN，SCK】迟迟没有客户端的【ACK】回复，会触发重传，此时服务端处于 SYN_RCVD 状态，会依次等待 3s、6s、12s 后，重新发送【SYN，ACK】包；而【SYN，ACK】的重传次数，不同操作系统有不同的配置，例如在 Linux 下可以通过 tcp_synack_retries 进行配置，默认值为 5。如果这个重试次数内，仍未收到【ACK】应答包，那么服务端会自动关闭这个连接。</li>
<li>同时由于客户端在没有收到【SYN，ACK】时，也会进行重传，当客户端重传的【SYN】收到后，会立即重新发送【SYN，ACK】包。</li>
</ol>
<p><mark>总结：</mark><br>
<mark>服务器端收到【SYN】回复，但是回复的【SYN，ACK】包丢了：客户端会进行如上的重传；服务器端也会进行重传。</mark></p>
<h3 id="3-客户端收到synack包在回复时丢失ack包"><strong>3、客户端收到【SYN，ACK】包，在回复时丢失【ACK】包</strong></h3>
<ol>
<li>对于客户端，在发送【ACK】包后进入 ESTABLISHED 状态。多数情况下，客户端进入ESTABLISHED 状态后，认为连接已建立，会立即发送数据。</li>
<li>对于服务端，因为没有收到【ACK】会走重传机制，但是服务端因为没有收到最后一个【ACK】包，依然处于 SYN-RCVD 状态。</li>
<li>当服务端处于 SYN-RCVD 状态下时，接收到客户端真实发送来的数据包时，会认为连接已建立，并进入ESTABLISHED状态。<br>
原因：<br>
当客户端在 ESTABLISHED 状态下，开始发送数据包时，会携带上一个【ACK】的确认序号，所以哪怕客户端响应的【ACK】包丢了，服务端在收到这个数据包时，能够通过包内 ACK 的确认序号，正常进入 ESTABLISHED 状态。<br>
<mark>总结：</mark><br>
<mark>客户端收到【SYN，ACK】包，在回复时丢失【ACK】包：客户端会进入 ESTABLISHED状态，向服务器端发送数据；服务器端虽然没有接收到客户端最后发来【ACK】包，但是因为数据包携带ACK的确认序号，所以在接收到数据包时，会认为连接已经建立，变为ESTABLISHED状态。</mark></li>
</ol>
<h3 id="4-客户端故意不发最后一次syn包"><strong>4、客户端故意不发最后一次【SYN】包</strong></h3>
<p>如果客户端是恶意的，在发送【SYN】包后，并收到【SYN,ACK】后就不回复了，那么服务端此时处于一种半连接的状态，虽然服务端会通过 tcp_synack_retries 配置重试的次数，不会无限等待下去，但是这也是有一个时间周期的。<br>
如果短时间内存在大量的这种恶意连接，对服务端来说压力就会很大，这就是所谓的 SYN FLOOD 攻击。</p>
<h1 id="tcp连接的四次挥手">TCP连接的”四次挥手“</h1>
<figure data-type="image" tabindex="2"><img src="https://Vinci-Ma.github.io/post-images/1594640340361.jpg" alt="四次挥手" loading="lazy"></figure>
<ol>
<li>开始客户端和服务器端都处于ESTABLISHED状态，两端任意一端都可以发送【FIN】包准备断开，图中为客户端发送【FIN】包，请求与服务器断开连接，在发出【FIN】后，客户端进入 FIN-WAIT-1 状态。</li>
<li>服务器端收到【FIN】，回复【ACK】表示接收到了信息，并从 ESTABLISHED 状态进入 CLOSED-WAIT 状态，开始做一些断开连接前的准备工作。</li>
<li>客户端收到服务器端回复的【ACK】消息后，进入 FIN-WAIT-2 状态。而当服务器端做好断开前的准备工作后，也会发送一个【FIN,ACK】的消息給客户端，表示服务器端已经准备好了，请求断开连接，并在发送消息后，服务器端进入 LAST-ACK 状态。</li>
<li>客户端在收到【FIN,ACK】消息后，会立即回复【ACK】，表示收到了消息，并进入 TIME_WAIT 状态，为了稳定和安全考虑，客户端会在 TIME-WAIT 状态等待 2MSL 的时长，最终进入 CLOSED 状态；服务器端收到客户端回复的【ACK】消息后，直接从 LAST-ACK 状态进入 CLOSED 状态。</li>
</ol>
<p>经过了“四次挥手”之后，双端都为CLOSED 状态，双端正式断开了连接。</p>
<h2 id="tcp连接四次挥手的异常情况以客户端首先发送fin为例">TCP连接“四次挥手”的异常情况（以客户端首先发送【FIN】为例）</h2>
<h3 id="1-断开连接的fin包丢失"><strong>1、断开连接的【FIN】包丢失</strong></h3>
<ol>
<li>对于客户端，【FIN】发送后，进入 FIN-WAIT-1 状态，长时间没有接收到服务器端发送的【ACK】回复，会触发超时重传机制，重新向服务器端发送【FIN】包，直到触发重传的次数，关闭连接。</li>
<li>对于服务器端，如果没有收到【FIN】，没有任何感知，会在一段时间后，也关闭连接。</li>
</ol>
<p><mark>总结：</mark><br>
<mark>断开连接的【FIN】包丢失：客户端超时重传，重新发送【FIN】包，直至触发重传次数，关闭连接。</mark></p>
<h3 id="2-服务端第一次回复的ack丢包"><strong>2、服务端第一次回复的【ACK】丢包</strong></h3>
<ol>
<li>对于客户端，没有收到服务器端返回的【ACK】包，会触发会触发超时重传机制，重新向服务器端发送【FIN】包，直到触发重传的次数，关闭连接。</li>
<li>对于服务器端，收到客户端的重传【FIN】包后，又会立即再重传【ACK】。发送过【ACK】之后，进入 CLOSED-WAIT 状态，开始做断开连接前的准备工作，当准备好之后，会回复【FIN,ACK】，而这个消息是携带了之前【ACK】的响应序号的。只要这个消息没丢，客户端可以凭借【FIN,ACK】包中的响应序号，直接从 FIN-WAIT-1 状态，进入 TIME-WAIT 状态，开始长达 2MSL 的等待。</li>
</ol>
<p><mark>总结：</mark><br>
<mark>服务端第一次回复的【ACK】丢包：客户端超时重传，重新发送【FIN】包。服务器端发送【ACK】后，进入CLOSED-WAIT 状态，做断开连接前的准备，准备完毕后，如果发送的【FIN，ACK】顺利传输，则正常进行。</mark></p>
<h3 id="3-服务端发送的-finack-丢包"><strong>3、服务端发送的 【FIN,ACK】 丢包</strong></h3>
<p>服务端在超时后会重传，此时客户端有两种情况，要么处于 FIN-WAIT-2 状态（之前的 ACK 也丢了），会一直等待；要么处于 TIME-WAIT 状态，会等待 2MSL 时间。</p>
<p>也就是说，在一小段时间内客户端还在，客户端在收到服务端发来的「FIN,ACK」包后，也会回复一个「ACK」应答，并做好自己的状态切换。</p>
<p>也就是说，在一小段时间内客户端还在，客户端在收到服务端发来的「FIN,ACK」包后，也会回复一个「ACK」应答，并做好自己的状态切换。</p>
<h3 id="4-客户端最后回复的ack丢包"><strong>4、客户端最后回复的【ACK】丢包</strong></h3>
<ol>
<li>对于客户端，在回复【ACK】后，会进入 TIME-WAIT 状态，开始长达 2MSL 的等待。</li>
<li>对于服务器端，因为没有收到【ACK】的回复，会重试一段时间，直到服务器端重试超时后主动断开；或者等待新的客户端接入后，收到服务器端重试的【FIN】消息后，回复【RST】消息，在收到【RST】消息后，复位服务器端的状态。</li>
</ol>
<h3 id="5-客户端收到ack后服务端跑路了"><strong>5. 客户端收到【ACK】后，服务端跑路了</strong></h3>
<p>客户端在收到「ACK」后，进入了 FIN-WAIT-2 状态，等待服务端发来的「FIN」包，而如果服务端跑路了，这个包永远都等不到。</p>
<p>在 TCP 协议中，是没有对这个状态的处理机制的。但是协议不管，系统来凑，操作系统会接管这个状态，例如在 Linux 下，就可以通过 tcp_fin_timeout 参数，来对这个状态设定一个超时时间。</p>
<p>需要注意的是，当超过 tcp_fin_timeout 的限制后，状态并不是切换到 TIME_WAIT，而是直接进入 CLOSED 状态。</p>
<p>参考：《关于FIN_WAIT2》</p>
<h3 id="6-客户端收到-ack-后客户端自己跑路了"><strong>6. 客户端收到 ACK 后，客户端自己跑路了</strong></h3>
<p>客户端收到「ACK」后直接跑路，服务端后续在发送的「FIN,ACK」就没有接收端，也就不会得到回复，会不断的走 TCP 的超时重试的机制，此时服务端处于 LAST-ACK 状态。</p>
<p>那就要分 2 种情况分析：</p>
<p>在超过一定时间后，服务端主动断开。<br>
收到「RST」后，主动断开连接。<br>
「RST」消息是一种重置消息，表示当前错误了，应该回到初始的状态。如果客户端跑路后有新的客户端接入，会在此发送「SYN」以期望建立连接，此时这个「SYN」将被忽略，并直接回复「FIN,ACK」消息，新客户端在收到「FIN」消息后是不会认的，并且会回复一个「RST」消息。</p>
<h1 id="常见面试题">常见面试题</h1>
<ol>
<li>【问题1】为什么连接的时候是三次握手，关闭的时候却是四次握手？</li>
</ol>
<p>答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，&quot;你发的FIN报文我收到了&quot;。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p>
<ol start="2">
<li>【问题2】为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？</li>
</ol>
<p>答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。</p>
<ol start="3">
<li>【问题3】为什么不能用两次握手进行连接？</li>
</ol>
<p>答：3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。</p>
<pre><code>   现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。
</code></pre>
<ol start="4">
<li>【问题4】如果已经建立了连接，但是客户端突然出现故障了怎么办？</li>
</ol>
<p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java中的递归算法]]></title>
        <id>https://Vinci-Ma.github.io/post/java-zhong-de-di-gui-suan-fa/</id>
        <link href="https://Vinci-Ma.github.io/post/java-zhong-de-di-gui-suan-fa/">
        </link>
        <updated>2020-06-25T15:15:44.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E7%9A%84%E4%B8%89%E4%B8%AA%E6%9D%A1%E4%BB%B6">使用递归算法的三个条件</a></li>
<li><a href="#%E9%80%92%E5%BD%92%E7%9A%84%E5%BA%94%E7%94%A8">递归的应用</a></li>
<li><a href="#%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B">程序示例</a>
<ul>
<li><a href="#1-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97">1、斐波那契数列</a></li>
<li><a href="#2-%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98">2、汉诺塔问题</a></li>
<li><a href="#3-%E4%BA%8C%E5%8F%89%E6%A0%91">3、二叉树</a></li>
</ul>
</li>
</ul>
(Java中的递归算法)<br>
编程语言中，函数直接或间接调用函数本身，则该函数称为递归函数。程序调用自身的编程技巧称为递归（ recursion）。递归通常是把一个大问题转化成为与大问题解决方法相似的小问题来解决，一般递归需要有<mark>边界条件</mark>、<mark>递归前进段</mark>和<mark>递归返回段</mark>。当边界条件不满足时，递归前进；当边界条件满足时，递归返回。</p>
<h1 id="使用递归算法的三个条件">使用递归算法的三个条件</h1>
<ol>
<li>一个问题可以分解为几个子问题</li>
<li>分解形成的子问题，除了数据规模不同，求解思路与原问题相同</li>
<li>存在递归终止的条件</li>
</ol>
<h1 id="递归的应用">递归的应用</h1>
<p>递归算法一般用于解决三类问题：</p>
<ol>
<li><strong>数据的定义是按递归定义的</strong><br>
如：斐波那契数列（Fibonacci sequence）</li>
<li><strong>问题解法按递归算法实现</strong><br>
如：汉诺塔问题（Hanoi）</li>
<li><strong>数据的结构形式是按递归定义的</strong><br>
如：二叉树、广义表等</li>
</ol>
<h1 id="程序示例">程序示例</h1>
<h2 id="1-斐波那契数列">1、斐波那契数列</h2>
<p>斐波那契数列（Fibonacci sequence），又称黄金分割数列，是这样一组数列：1、1、2、3、5、8、13、21、34、……从这个数列的第3项开始，每一项都等于前两项数字的和。</p>
<pre><code class="language-javascript">for (int i = 1;i &lt; 10;i++){
            System.out.printf(&quot;%4d&quot;,fibonacci(i));
        }
//结果为：   1   1   2   3   5   8  13  21  34

//f(n) = f(n - 1) + f(n - 2)
static int fibonacci(int nums){
        if (nums &lt; 0){
            return 1;
        }else if (nums &lt; 3){
            return 1;
        }else
            return fibonacci(nums - 1) + fibonacci(nums - 2);
    }
</code></pre>
<h2 id="2-汉诺塔问题">2、汉诺塔问题</h2>
<blockquote>
<p>相传在古印度圣庙中，有一种被称为汉诺塔(Hanoi)的游戏。该游戏是在一块铜板装置上，有三根杆(编号A、B、C)，在A杆自下而上、由大到小按顺序放置64个金盘(如下图)。游戏的目标：把A杆上的金盘全部移到C杆上，并仍保持原有顺序叠好。操作规则：每次只能移动一个盘子，并且在移动过程中三根杆上都始终保持大盘在下，小盘在上，操作过程中盘子可以置于A、B、C任一杆上。<br>
【百度百科】</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200705001114632.png" alt="汉诺塔" loading="lazy"><br>
思路：<br>
【注：start为圆盘开始时的位置，mid 为圆盘暂时存放的位置，last 为圆盘最终需要到达的位置】</p>
<ol>
<li>当圆盘个数为1时，可以直接从 start 移动到 last</li>
<li>当圆盘个数为n时，需要把（n - 1）个圆盘移动到 mid</li>
<li>最后把剩下的圆盘移动到 last</li>
</ol>
<pre><code class="language-javascript">hanoi(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,3);

static void hanoi(String start,String mid,String last,int n){
        if(n == 1){
            System.out.println(start+&quot;------&gt;&quot;+last);
        }else{
            //把 n - 1 个圆盘移动到过渡位置
            hanoi(start,last,mid,n-1);
            //把最底层的圆盘移动到最后的位置
            hanoi(start,mid,last,1);
            //把在过渡位置的 n - 1 个圆盘移动到最终的位置
            hanoi(mid,start,last,n-1);
        }

    }
</code></pre>
<p><strong>结果：</strong><br>
<img src="https://img-blog.csdnimg.cn/20200705003826677.png" alt="结果" loading="lazy"><br>
<strong>动画演示</strong><br>
<img src="https://Vinci-Ma.github.io/post-images/1593881942534.gif" alt="" loading="lazy"></p>
<h2 id="3-二叉树">3、二叉树</h2>
<p>见前篇<br>
链接: <a href="https://vinci-ma.github.io/post/er-cha-shu-bian-li-java-de-dai-ma-shi-xian/">二叉树遍历——Java的代码实现</a>.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二叉树遍历Java的代码实现]]></title>
        <id>https://Vinci-Ma.github.io/post/er-cha-shu-bian-li-java-de-dai-ma-shi-xian/</id>
        <link href="https://Vinci-Ma.github.io/post/er-cha-shu-bian-li-java-de-dai-ma-shi-xian/">
        </link>
        <updated>2020-06-24T13:14:39.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91">二叉树</a></li>
<li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86">二叉树的遍历</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">代码实现</a>
<ul>
<li><a href="#%E9%A6%96%E5%85%88%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9">首先创建一个结点</a></li>
<li><a href="#%E5%85%B6%E6%AC%A1%E6%98%AF%E8%BF%9B%E8%A1%8C%E9%81%8D%E5%8E%86%E6%93%8D%E4%BD%9C%E7%9A%84binarytree%E7%B1%BB">其次是进行遍历操作的BinaryTree类</a>
<ul>
<li><a href="#%E8%83%BD%E5%A4%9F%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E7%9A%84%E4%B8%89%E4%B8%AA%E6%9D%A1%E4%BB%B6">能够使用递归的三个条件</a></li>
<li><a href="#%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95%E8%AF%A6%E8%BF%B0%E4%BB%A5%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E4%B8%BA%E4%BE%8B">递归实现二叉树遍历方法详述（以中序遍历为例）</a></li>
</ul>
</li>
<li><a href="#%E4%B8%BB%E5%87%BD%E6%95%B0">主函数</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C">输出结果</a></li>
</ul>
</li>
</ul>
</p>
<h1 id="二叉树">二叉树</h1>
<p>二叉树是树的一种，每个结点最多可具有两个子树，即结点的度最大为2</p>
<h1 id="二叉树的遍历">二叉树的遍历</h1>
<p>先序遍历：先访问根节点，然后访问左节点，最后访问右节点。<br>
【1-&gt;2-&gt;4-&gt;8-&gt;9-&gt;5-&gt;10-&gt;3-&gt;6-&gt;7】<br>
<img src="https://img-blog.csdnimg.cn/20200627000853767.png?x-oss-process=image" alt="在这里插入图片描述" loading="lazy"><br>
中序遍历：先访问左节点，然后访问根节点，最后访问右节点。<br>
【8-&gt;4-&gt;9-&gt;2-&gt;10-&gt;5-&gt;1-&gt;6-&gt;3-&gt;7】<br>
<img src="https://img-blog.csdnimg.cn/20200627001030262.png?x-oss-process=image" alt="在这里插入图片描述" loading="lazy"><br>
后序遍历：先访问左节点，然后访问右节点，最后访问根节点。<br>
【8-&gt;9-&gt;4-&gt;10-&gt;5-&gt;2-&gt;6-&gt;7-&gt;3-&gt;1】<br>
<img src="https://img-blog.csdnimg.cn/20200627001118497.png?x-oss-process=image" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="代码实现">代码实现</h1>
<h2 id="首先创建一个结点">首先创建一个结点</h2>
<p>这个结点包括，一个根结点，一个根所对应的左结点，一个根所对应的右节点</p>
<pre><code class="language-javascript">public class Node {
    Object data;
    Node left = null;
    Node right = null;
    void Node(Object data,Node left,Node right){
        this.data = data;
        this.left = left;
        this.right = right;
    }
}
</code></pre>
<h2 id="其次是进行遍历操作的binarytree类">其次是进行遍历操作的BinaryTree类</h2>
<p>用递归的方法实现遍历</p>
<pre><code class="language-javascript">public class BinaryTree {
// 先序遍历
    void preSearch(Node root){
        if (root != null){
            System.out.printf(&quot;%-4s&quot;,root.data);
            preSearch(root.left);
            preSearch(root.right);
        }
    }
    // 中序遍历
    void midSearch(Node root){
        if (root != null){
            midSearch(root.left);
            System.out.printf(&quot;%-4s&quot;,root.data);
            midSearch(root.right);
        }
    }
    // 后序遍历
    void bacSearch(Node root){
        if (root != null){
            bacSearch(root.left);
            bacSearch(root.right);
            System.out.printf(&quot;%-4s&quot;,root.data);
        }
    }
}
</code></pre>
<h3 id="能够使用递归的三个条件">能够使用递归的三个条件</h3>
<ol>
<li>一个问题可以分解成几个子问题。</li>
<li>这个问题与分解过后的子问题，除了数据规模不同（子问题更为简单），求解思路完全一样。</li>
<li>存在一个明确的递归终止条件。</li>
</ol>
<p>在此例中，</p>
<ol>
<li>遍历二叉树的操作可以分解为遍历单个结点的操作。</li>
<li>遍历整个二叉树的操作和遍历一个结点的操作相同。</li>
<li>存在截止条件，即根节点不为null。</li>
</ol>
<p>所以，可以使用递归实现二叉树的遍历。</p>
<h3 id="递归实现二叉树遍历方法详述以中序遍历为例">递归实现二叉树遍历方法详述（以中序遍历为例）</h3>
<p><img src="https://img-blog.csdnimg.cn/20200627001030262.png?x-oss-process=image" alt="" loading="lazy"><br>
<img src="https://Vinci-Ma.github.io/post-images/1593329449625.jpg" alt="" loading="lazy"></p>
<h2 id="主函数">主函数</h2>
<pre><code class="language-javascript">public class E1 {
    public static void main(String[] args) {
        //构造一个二叉树
        Node node10 = new Node();
        node10.Node(&quot;10&quot;,null,null);
        Node node9 = new Node();
        node9.Node(&quot;9&quot;,null,null);
        Node node8 = new Node();
        node8.Node(&quot;8&quot;,null,null);
        Node node7 = new Node();
        node7.Node(&quot;7&quot;,null,null);
        Node node6 = new Node();
        node6.Node(&quot;6&quot;,null,null);
        Node node5 = new Node();
        node5.Node(&quot;5&quot;,node10,null);
        Node node4 = new Node();
        node4.Node(&quot;4&quot;,node8,node9);
        Node node3 = new Node();
        node3.Node(&quot;3&quot;,node6,node7);
        Node node2 = new Node();
        node2.Node(&quot;2&quot;,node4,node5);
        Node node1 = new Node();
        node1.Node(&quot;1&quot;,node2,node3);
        BinaryTree b = new BinaryTree();
        //对所构造的二叉树遍历输出
        System.out.println(&quot;前序遍历输出：&quot;);
        b.preSearch(node1);
        System.out.println();
        System.out.println(&quot;中序遍历输出：&quot;);
        b.midSearch(node1);
        System.out.println();
        System.out.println(&quot;后序遍历输出：&quot;);
        b.bacSearch(node1);
    }
}
</code></pre>
<h2 id="输出结果">输出结果</h2>
<figure data-type="image" tabindex="1"><img src="https://Vinci-Ma.github.io/post-images/1593178800956.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java基础学习——面向对象]]></title>
        <id>https://Vinci-Ma.github.io/post/java-ji-chu-xue-xi-mian-xiang-dui-xiang/</id>
        <link href="https://Vinci-Ma.github.io/post/java-ji-chu-xue-xi-mian-xiang-dui-xiang/">
        </link>
        <updated>2020-06-20T13:37:01.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3">面向对象思想</a>
<ul>
<li><a href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E6%80%9D%E6%83%B3">面向对象的三大思想</a></li>
<li><a href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81">面向对象的三大特征</a>
<ul>
<li><a href="#%E5%B0%81%E8%A3%85">封装</a></li>
<li><a href="#%E7%BB%A7%E6%89%BF">继承</a></li>
<li><a href="#%E5%A4%9A%E6%80%81">多态</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<h1 id="面向对象思想">面向对象思想</h1>
<p>面向对象（Object Oriented）是软件开发方法。面向对象（Procedure Oriented）是相对于面向过程来说的，指的是把相关的数据和方法组织为一个整体来看待。面向过程关注的是执行的过程，面向对象关注的是具备功能的对象。</p>
<h2 id="面向对象的三大思想">面向对象的三大思想</h2>
<p>OOA（Object Oriented Analysis）：面向对象分析<br>
OOD（Object Oriented Design）：面向对象设计<br>
OOP（Object Oriented Programming）：面向对象程序</p>
<h2 id="面向对象的三大特征">面向对象的三大特征</h2>
<h3 id="封装">封装</h3>
<p>1、隐藏具体的实现细节【安全性】<br>
2、对外提供公共的访问方式【功能】</p>
<h3 id="继承">继承</h3>
<p>1、子类可以继承父类的所有非私有成员（成员属性和成员方法）。<br>
2、子类不可以继承父类的构造，但是默认访问父类的空参构造。<br>
3、只可以单继承，不能多继承，但是可以多级继承。</p>
<h3 id="多态">多态</h3>
<p><strong>多态的前提：</strong></p>
<ol>
<li>有类的继承或接口的实现</li>
<li>子类重写父类的方法</li>
<li>父类引用指向子类对象</li>
</ol>
<p><strong>多态的成员访问特点：</strong></p>
<ol>
<li>属性：编译看父类，运行看父类 --- 只有父类有的，编译才能够通过&lt;-多态的弊端产生的原因</li>
<li><mark>功能：编译看父类，运行看子类</mark></li>
</ol>
<p>对于多态访问特点的理解：父类的引用指向子类的对象，可以理解为，fu的外在表现为父类，而实际内核是子类。<br>
对于属性来说，表现的是外在的特征，所以属性的运行看的是父类；<br>
而调用方法表现的是本质，所以运行的结果是子类。</p>
<pre><code class="language-javascript">//示例如下
public class E1 {
    public static void main(String[] args) {
        Fu fu = new Zi();// 3、父类的引用指向子类的对象
        fu.say();//结果：=====子类   ---&gt;对于功能来说：编译看父类，运行看子类
        //fu.show;----&gt;编译报错
        System.out.println(fu.name);//结果：父类   ---&gt;对于属性来说：编译看父类，运行看父类
        //System.out.println(fu.age);----&gt;编译报错
        Zi zi = (Zi) fu;//向下转型
        zi.show();//结果：=====子类show
    }
}
class Fu{
    String name = &quot;父类&quot;;
    public void say(){
        System.out.println(&quot;=====父类&quot;);
    }
}
class Zi extends Fu{  // 1、有类的继承或接口的实现
    String name = &quot;子类&quot;;
    int age;
    public void say(){  // 2、子类重写父类的方法
        System.out.println(&quot;=====子类&quot;);
    }
    public void show(){  
        System.out.println(&quot;=====子类show&quot;);
    }
}
</code></pre>
<p><strong>多态的成员访问特点：</strong></p>
<ol>
<li>属性：编译看父类，运行看父类 --- 只有父类有的，编译才能够通过&lt;-多态的弊端产生的原因</li>
<li>功能：编译看父类，运行看子类</li>
</ol>
<p><strong>多态的弊端：</strong><br>
不能访问子类特有的成员</p>
<p><mark><strong>应用场景：</strong></mark><br>
<mark>当做形参传递使用</mark></p>
<pre><code class="language-javascript">//例如在调用时
say(&quot;aaa&quot;);

//在定义该方法时，根本不需要指导具体的子类是谁，但是可以保证最终执行的是子类的功能
void say(Object o ){
    //实际参数 ====&gt; 形式参数  Object o = &quot;aaa&quot;;   形成了多态【父类引用指向子类的对象】
     System.out.println(o);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java基础学习——数组及其常用算法]]></title>
        <id>https://Vinci-Ma.github.io/post/java-ji-chu-xue-xi-shu-zu-ji-qi-chang-yong-suan-fa/</id>
        <link href="https://Vinci-Ma.github.io/post/java-ji-chu-xue-xi-shu-zu-ji-qi-chang-yong-suan-fa/">
        </link>
        <updated>2020-06-18T07:49:56.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E6%95%B0%E7%BB%84">数组</a>
<ul>
<li><a href="#%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84">一维数组</a>
<ul>
<li><a href="#%E5%88%9B%E5%BB%BA%E6%A0%BC%E5%BC%8F">创建格式</a></li>
<li><a href="#%E9%80%9A%E8%BF%87%E4%B8%8B%E6%A0%87%E5%AF%B9%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E6%93%8D%E4%BD%9C">通过下标对数据进行操作</a></li>
<li><a href="#%E8%8E%B7%E5%8F%96%E6%95%B0%E7%BB%84%E7%9A%84%E9%95%BF%E5%BA%A6">获取数组的长度</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84">二维数组</a>
<ul>
<li><a href="#%E5%88%9B%E5%BB%BA%E6%A0%BC%E5%BC%8F-2">创建格式</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95">数组常用算法</a>
<ul>
<li><a href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F">冒泡排序</a>
<ul>
<li><a href="#%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86">算法原理</a></li>
<li><a href="#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0">算法实现</a>
<ul>
<li><a href="#%E5%88%9D%E5%A7%8B%E7%8A%B6%E6%80%81">初始状态：</a></li>
<li><a href="#%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%BE%AA%E7%8E%AF">第一次循环：</a></li>
<li><a href="#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%BE%AA%E7%8E%AF">第二次循环：</a></li>
<li><a href="#%E7%AC%AC%E4%B8%89%E6%AC%A1%E5%BE%AA%E7%8E%AF">第三次循环：</a></li>
<li><a href="#%E7%AC%AC%E5%9B%9B%E6%AC%A1%E5%BE%AA%E7%8E%AF">第四次循环：</a></li>
<li><a href="#%E6%9C%80%E7%BB%88%E8%BE%93%E5%87%BA">最终输出</a></li>
</ul>
</li>
<li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">代码实现</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE">二分查找</a>
<ul>
<li><a href="#%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86-2">算法原理</a></li>
<li><a href="#%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4">实现步骤</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2">代码实现</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<h1 id="数组">数组</h1>
<p>所谓数组，是有序的元素序列。在java语言中，数组是一种最简单的复合数据类型，它是由一些具有相同的数据类型的元素所构成的，可以用一个统一的数组名和下标来唯一地确定数组中的元素。数组有一维数组和多维数组。</p>
<h2 id="一维数组">一维数组</h2>
<h3 id="创建格式">创建格式</h3>
<p>其中第1、2种较为常用<br>
1、数据类型[ ] 数组名称 = {数组内容1，数组内容2，……，数组内容n}；</p>
<pre><code class="language-javascript">// 示例如下
int[] age = {1, 2, 3 ,4};
</code></pre>
<p>2、数据类型[ ] 数组名称 = new 数据类型[数组长度]；</p>
<pre><code class="language-javascript">// 示例如下
int[] age = new int[4];
</code></pre>
<p>3、数据类型 [ ] 数组名称 = new 数据类型[ ] {数组内容1，数组内容2，……，数组内容n}；</p>
<pre><code class="language-javascript">// 示例如下
int[] age = new int[]{1, 2, 3 ,4};
</code></pre>
<p>4、数据类型[ ] 数组名；<br>
该种方法只创建了数组引用名，并未在内存中创建数组空间，只能通过以下方式进行初始化设置。</p>
<pre><code class="language-javascript">// 示例如下
int[] age;
age = new int[4];
</code></pre>
<h3 id="通过下标对数据进行操作">通过下标对数据进行操作</h3>
<p>赋值操作：<br>
数组名[下标] = 值；</p>
<pre><code class="language-javascript">// 把13赋予了age数组中的第一个元素，该元素在数组中的编号为0
age[0] = 13;
</code></pre>
<p>取值操作：<br>
数组名[下标]</p>
<pre><code class="language-javascript">// 示例如下
age[0];
</code></pre>
<h3 id="获取数组的长度">获取数组的长度</h3>
<p>数组名称.length</p>
<pre><code class="language-javascript">// 示例如下
age.length;
</code></pre>
<h2 id="二维数组">二维数组</h2>
<h3 id="创建格式-2">创建格式</h3>
<p>数据类型[ ][ ] 数组名 = new 数据类型[长度][(可写可不写) ]；</p>
<pre><code class="language-javascript">// 示例如下
int[][] age = new int [4][];
</code></pre>
<h1 id="数组常用算法">数组常用算法</h1>
<h2 id="冒泡排序">冒泡排序</h2>
<p>冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。它重复地走访过要排序的元素列，依次比较两个相邻的元素，如果顺序（如从大到小、首字母从Z到A）错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素列已经排序完成。<br>
【以下以升序排列为例】</p>
<h3 id="算法原理">算法原理</h3>
<p>1、比较相邻两个数值的大小，将数值较大的移动到右边。<br>
2、对每一对相邻元素都进行1中的比较，直到所有相邻元素都经过了比较。此时完成一次外层循环，将最大的数值移动到了数组最右边。<br>
3、重复1、2的操作，直至所有的元素在数组中都按照从小到大的顺序排列。</p>
<h3 id="算法实现">算法实现</h3>
<p>以数组nums = {1,15,9,5,7}为例</p>
<h4 id="初始状态">初始状态：</h4>
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">15</th>
<th style="text-align:center">9</th>
<th style="text-align:center">5</th>
<th style="text-align:center">7</th>
</tr>
</thead>
<tbody></tbody>
</table>
<h4 id="第一次循环">第一次循环：</h4>
<p>第1趟排序：<br>
1和15相比较</p>
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">15</th>
<th style="text-align:center">9</th>
<th style="text-align:center">5</th>
<th style="text-align:center">7</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>第2趟排序：<br>
15和9相比较</p>
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">9</th>
<th style="text-align:center">15</th>
<th style="text-align:center">5</th>
<th style="text-align:center">7</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>第3趟排序：<br>
15和5相比较</p>
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">9</th>
<th style="text-align:center">5</th>
<th style="text-align:center">15</th>
<th style="text-align:center">7</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>第4趟排序：<br>
15和7相比较</p>
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">9</th>
<th style="text-align:center">5</th>
<th style="text-align:center">7</th>
<th style="text-align:center">15</th>
</tr>
</thead>
<tbody></tbody>
</table>
<h4 id="第二次循环">第二次循环：</h4>
<p>第1趟排序：<br>
1和9相比较</p>
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">9</th>
<th style="text-align:center">5</th>
<th style="text-align:center">7</th>
<th style="text-align:center">15</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>第2趟排序：<br>
9和5相比较</p>
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">5</th>
<th style="text-align:center">9</th>
<th style="text-align:center">7</th>
<th style="text-align:center">15</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>第3趟排序：<br>
9和7相比较</p>
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">5</th>
<th style="text-align:center">7</th>
<th style="text-align:center">9</th>
<th style="text-align:center">15</th>
</tr>
</thead>
<tbody></tbody>
</table>
<h4 id="第三次循环">第三次循环：</h4>
<p>第1趟排序：<br>
1和5相比较</p>
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">5</th>
<th style="text-align:center">7</th>
<th style="text-align:center">9</th>
<th style="text-align:center">15</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>第2趟排序：<br>
5和7相比较</p>
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">5</th>
<th style="text-align:center">7</th>
<th style="text-align:center">9</th>
<th style="text-align:center">15</th>
</tr>
</thead>
<tbody></tbody>
</table>
<h4 id="第四次循环">第四次循环：</h4>
<p>第1趟排序：<br>
1和5相比较</p>
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">5</th>
<th style="text-align:center">7</th>
<th style="text-align:center">9</th>
<th style="text-align:center">15</th>
</tr>
</thead>
<tbody></tbody>
</table>
<h4 id="最终输出">最终输出</h4>
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">5</th>
<th style="text-align:center">7</th>
<th style="text-align:center">9</th>
<th style="text-align:center">15</th>
</tr>
</thead>
<tbody></tbody>
</table>
<h3 id="代码实现">代码实现</h3>
<pre><code class="language-javascript">	// 示例如下
	int[] nums = {1,15,9,5,7};
	for(int i=0; i&lt;nums.length; i++) {
		for(int j=0; j&lt;nums.length-i-1; j++) {
		//如果nums[j+1]的值小于nums[j]，则交换两者位置，使得较大的数字在右边
			if(nums[j+1]&lt;nums[j]) {
				nums[j+1] = nums[j] + nums[j+1];
				nums[j] = nums[j+1] - nums[j];
				nums[j+1] = nums[j+1] - nums[j];					
			}
		}
	}
	//利用for循环输出数组
	System.out.println(&quot;排序后的数组：&quot;);
	for(int i=0; i&lt;nums.length;i++)
	System.out.print(nums[i]+&quot;  &quot;);
</code></pre>
<p>编译结果<br>
<img src="https://img-blog.csdnimg.cn/20200613143855899.png" alt="编译结果" loading="lazy"></p>
<h2 id="二分查找">二分查找</h2>
<p>二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，二分查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。</p>
<h3 id="算法原理-2">算法原理</h3>
<p>1、假设数组中元素是有序排列，将数组中间位置的数据与查找数据比较，如果两者相等，则查找成功。<br>
2、否则利用中间位置记录将数组分成前、后两个子数组，如果中间位置数据大于查找数据，则进一步查找前子数<br>
组，否则进一步查找后子数组。<br>
3、重复以上过程，直到找到满足条件的数据，则表示查找成功，直到子数组不存在为止，表示查找不成功。</p>
<h3 id="实现步骤">实现步骤</h3>
<p>1、确定查找范围，最小——最大<br>
2、计算中间下标  =（最小+最大）/2<br>
3、比较中间下标和寻找的数据大小关系，如果中间下标所对应的元素比所寻找的数字小，则证明所要寻找的数字在数组的右半段，令最小下标 = 中间下标 + 1，中间下标  =（最小+最大）/2，最大下标不变，继续寻找。<br>
4、如果最小下标 &gt; 最大下标，说明数据不存在</p>
<h3 id="代码实现-2">代码实现</h3>
<pre><code class="language-javascript">// 示例如下
//使用二分法查找6，nums为上述冒泡排序示例
		int a = 6;
		int max = nums.length - 1;
		int min = 0;
		int mid =  (max + min)/2;
		while(true) {
			if(nums[mid] == a)
				break;
			//所要查找的数字在右半段
			else if(nums[mid] &lt; a) {
				min = mid + 1;
				mid = (max + min)/2;
			}
			//所要查找的数据在左半端
			else if(nums[mid] &gt; a) {
				max = mid - 1;
				mid = (max + min)/2;
			}
			
			if(min &gt; max){
				mid = -1;
				break;		
			}
			
		}
		if(mid == -1)
			System.out.println(&quot;没有这个数&quot;);
		else
			System.out.println(&quot;找到了&quot;+a+&quot;，其下标为：&quot;+mid);
</code></pre>
<p>编译结果：<br>
当a = 6时，即所要查找的数字是6<br>
<img src="https://img-blog.csdnimg.cn/2020061314410351.png" alt="当a = 6时" loading="lazy"><br>
当a = 9时，即所要查找的数字是9<br>
<img src="https://img-blog.csdnimg.cn/20200613150423899.png" alt="当a = 9时" loading="lazy"></p>
]]></content>
    </entry>
</feed>