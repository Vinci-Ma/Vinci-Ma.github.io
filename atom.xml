<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Vinci-Ma.github.io</id>
    <title>Vinci-Ma</title>
    <updated>2020-07-25T15:21:13.566Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Vinci-Ma.github.io"/>
    <link rel="self" href="https://Vinci-Ma.github.io/atom.xml"/>
    <subtitle>Stay cooool!</subtitle>
    <logo>https://Vinci-Ma.github.io/images/avatar.png</logo>
    <icon>https://Vinci-Ma.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Vinci-Ma</rights>
    <entry>
        <title type="html"><![CDATA[MySQL学习]]></title>
        <id>https://Vinci-Ma.github.io/post/mysql-xue-xi/</id>
        <link href="https://Vinci-Ma.github.io/post/mysql-xue-xi/">
        </link>
        <updated>2020-07-25T08:38:34.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BB%8B%E7%BB%8D">MySQL数据库介绍</a>
<ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E5%BA%93">什么是数据库</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BD%9C%E7%94%A8">数据库的作用</a></li>
<li><a href="#%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E5%BA%93">常见数据库</a></li>
</ul>
</li>
<li><a href="#mysql%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">MySQL中的数据类型</a>
<ul>
<li><a href="#1-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">1、字符串数据类型</a></li>
<li><a href="#2-%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">2、数值类型</a></li>
<li><a href="#3-%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B">3、日期和时间类型</a></li>
<li><a href="#4-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%BE%88%E5%B0%91%E4%BD%BF%E7%94%A8">4、二进制数据类型（很少使用）</a></li>
</ul>
</li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4">数据库的基本命令</a>
<ul>
<li><a href="#mysql%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C">MySQL基础操作</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C">数据库的基本操作</a></li>
<li><a href="#%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C">表的基本操作</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C">数据的基本操作</a></li>
</ul>
</li>
</ul>
</p>
<h1 id="mysql数据库介绍">MySQL数据库介绍</h1>
<h2 id="什么是数据库">什么是数据库</h2>
<ul>
<li>数据库(Database)就是按照数据结构来组织，存储和管理数据的仓库。</li>
<li>专业的数据库是专门对数据进行创建，访问，管理，搜索等操作的软件，比起我们自己用文件读写的方<br>
式对象数据进行管理更加的方便，快速，安全。</li>
</ul>
<h2 id="数据库的作用">数据库的作用</h2>
<ol>
<li>对数据进行持久化的保存。</li>
<li>方便数据的存储和查询，速度快，安全，方便。</li>
<li>可以处理并发访问。</li>
<li>更加安全的权限管理访问机制。</li>
</ol>
<h2 id="常见数据库">常见数据库</h2>
<ul>
<li>关系型数据库： MySQL，Oracle，PostgreSQL，SQLserver……</li>
<li>非关系型数据库：Redis内存数据库，MongoDB文档数据库……<br>
MySQL数据库是最流行的关系型数据库管理系统。</li>
</ul>
<h1 id="mysql中的数据类型">MySQL中的数据类型</h1>
<h2 id="1-字符串数据类型">1、字符串数据类型</h2>
<p>存储串，如名字、地址、电 话号码、邮政编码等</p>
<ul>
<li>定长串：char</li>
</ul>
<ol>
<li>接受长度固定的字符串，其长度是在创建表时指定的。<br>
定长列不允许存储多于指定长度字符的数据。</li>
<li>指定长度后，就会分配固定的存储空间用于存放数据</li>
</ol>
<ul>
<li>变长串 varchar<br>
存储可变长度的字符串 varchar(7) 如果实际插入4个字符, 那么它只占4个字符位置,当然插入的数据长度不能超过7个字符。<br>
<mark>注意</mark><br>
既然变长数据类型这样灵活，为什么还要使用定长数据类型？<br>
回答：因为性能，MySQL处理定长列远比处理变长列快得多。</li>
<li>Text 变长文本类型存储<br>
<img src="https://Vinci-Ma.github.io/post-images/1595685781112.png" alt="" loading="lazy"></li>
</ul>
<h2 id="2-数值类型">2、数值类型</h2>
<figure data-type="image" tabindex="1"><img src="https://Vinci-Ma.github.io/post-images/1595685848153.png" alt="" loading="lazy"></figure>
<pre><code class="language-javascript">decimal(5, 2) 表示数值总共5位, 小数占2位
tinyint 1字节(8位) 0-255。-128，127
int 4字节。 -21亿，21亿。0-42亿
float.
MySQL中没有专门存储货币的数据类型，一般情况下使用DECIMAL(8, 2)
</code></pre>
<p><strong>有符号或无符号</strong><br>
所有数值数据类型（除BIT和BOOLEAN外）都可以有符号或无符号<br>
有符号数值列可以存储正或负的数值<br>
无符号数值列只能存储正数。<br>
默认情况为有符号，但如果你知道自己不需要存储负值，可以使用UNSIGNED关键字<br>
<mark>注意</mark><br>
如果将邮政编码类似于01234存储为数值类型，则保存的将是数值1234，此时需要使用字符串类型<br>
手机号也应该使用字符串类型</p>
<h2 id="3-日期和时间类型">3、日期和时间类型</h2>
<figure data-type="image" tabindex="2"><img src="https://Vinci-Ma.github.io/post-images/1595686044391.png" alt="" loading="lazy"></figure>
<h2 id="4-二进制数据类型很少使用">4、二进制数据类型（很少使用）</h2>
<p>二进制数据类型可存储任何数据（甚至包括二进制信息），如图像、多媒体、字处理文档等<br>
<img src="https://Vinci-Ma.github.io/post-images/1595686105163.png" alt="" loading="lazy"></p>
<h1 id="数据库的基本命令">数据库的基本命令</h1>
<h2 id="mysql基础操作">MySQL基础操作</h2>
<ul>
<li><strong>SQL ( Structure query language ) 结构化查询语言</strong><br>
SQL语言分为4个部分：DDL（定义）、DML（操作）、DQL（查询）、DCL（控制）</li>
<li><strong>SQL语句中的快捷键</strong><br>
\G 格式化输出（文本式，竖立显示）<br>
\s 查看服务器端信息<br>
\c 结束命令输入操作<br>
\q 退出当前sql命令行模式<br>
\h 查看帮助</li>
<li><strong>连接MySQL</strong></li>
</ul>
<pre><code class="language-javascript">mysql -u root -p
</code></pre>
<p>其中：<br>
-h 服务器地址<br>
-u 登录账号<br>
-p 回车后输入密码<br>
-P （大写）端口号</p>
<ul>
<li><strong>退出MySQL</strong></li>
</ul>
<pre><code class="language-javascript">exit; 或者 quit; 或者 \q
</code></pre>
<h2 id="数据库的基本操作">数据库的基本操作</h2>
<ul>
<li><strong>查看数据库</strong></li>
</ul>
<pre><code class="language-javascript">show databases;
</code></pre>
<ul>
<li><strong>打开数据库</strong></li>
</ul>
<pre><code class="language-javascript">use 库名;
</code></pre>
<ul>
<li><strong>创建数据库</strong></li>
</ul>
<pre><code class="language-javascript">create database 库名 default charset=utf8;
</code></pre>
<ul>
<li><strong>删除数据库</strong></li>
</ul>
<pre><code class="language-javascript">drop database 库名;
</code></pre>
<h2 id="表的基本操作">表的基本操作</h2>
<ul>
<li><strong>查看表</strong></li>
</ul>
<pre><code class="language-javascript">show tables;
</code></pre>
<ul>
<li><strong>新建表</strong></li>
</ul>
<pre><code class="language-javascript">create student(
    Id int unsigned primary key not null unique auto_increment,  
    name varchar(4) not null,
    age int unsigned not null
)engine=innodb default charset=utf8;
</code></pre>
<p><strong>表的字段约束</strong></p>
<ul>
<li>unsigned 无符号(给数值类型使用，表示为正数，不写可以表示正负数都可以)</li>
<li>字段类型后面加括号限制宽度
<ul>
<li>char(5). varchar(7) 在字符类型后面加限制 表示 字符串的长度</li>
<li>int(4) 没有意义，默认无符号的int为int(11)，有符号的int(10)</li>
<li>nt(4) unsigned zerofill只有当给int类型设置有前导零时，设置int的宽度才有意义。</li>
</ul>
</li>
<li>not null 不能为空,在操作数据库时如果输入该字段的数据为NULL ，就会报错</li>
<li>default 设置默认值</li>
<li>primary key 主键不能为空,且唯一.一般和自动递增一起配合使用。</li>
<li>auto_increment 定义列为自增属性，一般用于主键，数值会自动加1</li>
<li>unique 唯一索引(数据不能重复:用户名)可以增加查询速度,但是会降低插入和更新速度<br>
<strong>主键</strong><br>
1、表中每一行都应该有可以唯一标识自己的一列，用于记录两条记录不能重复，任意两行都不具有相同的主键值<br>
2、应该总是定义主键 虽然并不总是都需要主键，但大多数数据库设计人员都应保证他们创建的每个表具有一个主<br>
键，以便于以后的数据操纵和管理。<br>
<mark>要求</mark></li>
<li>记录一旦插入到表中，主键最好不要再修改</li>
<li>不允许NULL</li>
<li>不在主键列中使用可能会更改的值。</li>
<li>自增整数类型：数据库会在插入数据时自动为每一条记录分配一个自增整数，这样我们就完全不用担心主键重复，也不用自己预先生成主键</li>
<li>可以使用多个列作为联合主键，但联合主键并不常用。使用多列作为主键时，所有列值的组合必须是唯一的</li>
<li><strong>查看表结构</strong></li>
</ul>
<pre><code class="language-javascript">desc 表名;
</code></pre>
<ul>
<li><strong>修改表结构</strong></li>
</ul>
<pre><code class="language-javascript">alter table 表名 action (更改的选项)
</code></pre>
<ol>
<li>添加字段</li>
</ol>
<pre><code class="language-javascript"># 语法：alter table 表名 add 添加的字段信息
-- 在 users 表中 追加 一个 num 字段
alter table users add num int not null;
-- 在指定字段后面追加字段 在 users 表中 age字段后面 添加一个 email 字段
alter table users add email varchar(50) after age;
-- 在指定字段后面追加字段，在 users 表中 age字段后面 添加一个 phone
alter table users add phone char(11) not null after age;
-- 在表的最前面添加一个字段
alter table users add aa int first;
</code></pre>
<ol start="2">
<li>删除字段</li>
</ol>
<pre><code class="language-javascript"># 删除字段 alter table 表名 drop 被删除的字段名
alter table users drop aa;
</code></pre>
<ol start="3">
<li>修改字段</li>
</ol>
<pre><code class="language-javascript">语法格式： alter table 表名 change|modify 被修改的字段信息
change: 可以修改字段名，
modify: 不能修改字段名。
# 修改表中的 num 字段 类型，使用 modify 不修改表名
alter table users modify num tinyint not null default 12;
# 修改表中的 num 字段 为 int并且字段名为 nn
alter table users change num mm int;
# 注意：一般情况下，无特殊要求，不要轻易修改表结构
</code></pre>
<ul>
<li><strong>修改表名</strong></li>
</ul>
<pre><code class="language-javascript"># 语法：alter table 原表名 rename as 新表名
</code></pre>
<ul>
<li><strong>更改表中的自增的值</strong></li>
</ul>
<pre><code class="language-javascript"># 在常规情况下，auto_increment 默认从1开始继续递增
alter table users auto_increment = 1000;
</code></pre>
<ul>
<li><strong>修改表引擎</strong></li>
</ul>
<pre><code class="language-javascript"># 推荐在定义表时，表引擎为 innodb。
# 通过查看建表语句获取当前的表引擎
mysql&gt; show create table users\G;
*************************** 1. row ***************************
Table: users
Create Table: CREATE TABLE `users` (
PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=1001 DEFAULT CHARSET=utf8
1 row in set (0.00 sec)
# 直接查看当前表状态信息
mysql&gt; show table status from tlxy where name = 'users'\G;
*************************** 1. row ***************************
Name: users
Engine: InnoDB
# 修改表引擎语句
alter table users engine = 'myisam';
</code></pre>
<ul>
<li><strong>删除表</strong></li>
</ul>
<pre><code class="language-javascript">drop table 表名;
</code></pre>
<h2 id="数据的基本操作">数据的基本操作</h2>
<ul>
<li><strong>查看表中的数据</strong></li>
</ul>
<pre><code class="language-javascript">select * from 表名;
select 字段1,字段2,字段3 from 表名;
select * from 表名 where 字段=某个值;
</code></pre>
<ul>
<li><strong>向表中插入数据</strong></li>
</ul>
<pre><code class="language-javascript">--标准添加（指定所有字段，给定所有的值）
 insert into stu(id,name,age,sex,classid) values(1,'zhangsan',20,'m','lamp138');
--指定部分字段添加值
insert into stu(name,classid) value('lisi','lamp138');
-- 不指定字段添加值
 insert into stu value(null,'wangwu',21,'w','lamp138');
-- 批量添加值
insert into stu values
-&gt; (null,'zhaoliu',25,'w','lamp94'),
-&gt; (null,'uu01',26,'m','lamp94'),
-&gt; (null,'uu02',28,'w','lamp92'),
-&gt; (null,'qq02',24,'m','lamp92'),
-&gt; (null,'uu03',32,'m','lamp138'),
-&gt; (null,'qq03',23,'w','lamp94'),
-&gt; (null,'aa',19,'m','lamp138');
</code></pre>
<ul>
<li><strong>修改表中的数据</strong></li>
</ul>
<pre><code class="language-javascript">update 表名 set 字段=某个值 where 条件;
update 表名 set 字段1=值1,字段2=值2 where 条件;
update 表名 set 字段=字段+值 where 条件;
-- 将id为11的age改为35，sex改为m值
mysql&gt; update stu set age=35,sex='m' where id=11;
Query OK, 1 row affected (0.16 sec)
Rows matched: 1 Changed: 1 Warnings: 0
-- 将id值为12和14的数据值sex改为m，classid改为lamp92
mysql&gt; update stu set sex='m',classid='lamp92' where id=12 or id=14 --等价于下面
mysql&gt; update stu set sex='m',classid='lamp92' where id in(12,14);
</code></pre>
<blockquote>
<p>MySQL中的运算符<br>
算术运算符： +、 -、 *、 /、 %<br>
比较运算符： =、 &gt;、 &lt;、 &gt;=、 &lt;=、!=<br>
数据库特有的比较： in、not in、is null、is not null、like、between、and<br>
逻辑运算符： and、or、not<br>
like: 支持特殊符号%和_ ;<br>
其中%表示任意数量的任意字符，_表示任意一位字符</p>
</blockquote>
<ul>
<li><strong>删除表中的数据</strong></li>
</ul>
<pre><code class="language-javascript">delete from 表名 where 字段=某个值;
-- 删除stu表中id值为100的数据
mysql&gt; delete from stu where id=100;
-- 删除stu表中id值为20到30的数据
mysql&gt; delete from stu where id&gt;=20 and id&lt;=30;
-- 删除stu表中id值为20到30的数据（等级于上面写法）
mysql&gt; delete from stu where id between 20 and 30;
-- 删除stu表中id值大于200的数据
mysql&gt; delete from stu where id&gt;200;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java基础学习——JSON 解析]]></title>
        <id>https://Vinci-Ma.github.io/post/java-ji-chu-xue-xi-json-jie-xi/</id>
        <link href="https://Vinci-Ma.github.io/post/java-ji-chu-xue-xi-json-jie-xi/">
        </link>
        <updated>2020-07-11T03:28:46.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#json%E7%AE%80%E4%BB%8B">JSON简介</a></li>
<li><a href="#json%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99">JSON语法规则</a></li>
<li><a href="#json%E8%A7%A3%E6%9E%90">JSON解析</a>
<ul>
<li><a href="#%E5%BC%95%E5%85%A5jar%E6%96%87%E4%BB%B6">引入JAR文件</a></li>
<li><a href="#gson">Gson</a>
<ul>
<li><a href="#1%E5%B0%86%E5%AF%B9%E8%B1%A1%E8%BD%AC%E6%8D%A2%E6%88%90-gson">1.将对象转换成 GSON</a></li>
<li><a href="#2%E5%B0%86json%E8%BD%AC%E6%8D%A2%E6%88%90%E5%AF%B9%E8%B1%A1">2.将JSON转换成对象</a></li>
</ul>
</li>
<li><a href="#fastjson">FastJson</a>
<ul>
<li><a href="#1%E5%B0%86%E5%AF%B9%E8%B1%A1%E8%BD%AC%E6%8D%A2%E6%88%90fastjson">1.将对象转换成FastJson</a></li>
<li><a href="#2%E5%B0%86fastjson%E8%BD%AC%E6%8D%A2%E6%88%90%E5%AF%B9%E8%B1%A1">2.将FastJson转换成对象</a></li>
</ul>
</li>
</ul>
</li>
</ul>
(Java基础学习——JSON 解析)</p>
<h1 id="json简介">JSON简介</h1>
<blockquote>
<p>JSON(JavaScript Object Notation, JS 对象简谱) 是<mark>一种轻量级的数据交换格式</mark>。它基于 ECMAScript (欧洲计算机协会制定的js规范)的一个子集，<mark>采用完全独立于编程语言的文本格式来存储和表示数据</mark>。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。<br>
【百度百科】</p>
</blockquote>
<h1 id="json语法规则">JSON语法规则</h1>
<ol>
<li>对象由大括号表示，括号中通过键值对描述对象的属性；</li>
<li>键与值之间使用冒号连接，多个键值对之间用逗号分离；</li>
<li>键值对的键，用引号引住；</li>
<li>键值对的值，可以是JS中任意类型的数据</li>
</ol>
<pre><code class="language-javascript">// 示例
{
	&quot;name&quot;:&quot;哈利·波特&quot;，
	&quot;friends&quot;:[&quot;赫敏&quot;,&quot;罗恩&quot;,
			{
			&quot;name&quot;:&quot;小天狼星布莱克&quot;
			&quot;status&quot;:&quot;哈利的教父&quot;}]
	&quot;wand&quot;:{
		&quot;length&quot;:&quot;11英寸&quot;,
		&quot;details&quot;:&quot;冬青木，杖芯是凤凰福克斯的尾毛&quot;
	}
}
</code></pre>
<h1 id="json解析">JSON解析</h1>
<h2 id="引入jar文件">引入JAR文件</h2>
<p><img src="https://Vinci-Ma.github.io/post-images/1594440402092.png" alt="1" loading="lazy"><br>
<img src="https://Vinci-Ma.github.io/post-images/1594440409797.png" alt="2" loading="lazy"><br>
<img src="https://Vinci-Ma.github.io/post-images/1594440445090.png" alt="3" loading="lazy"><br>
<img src="https://Vinci-Ma.github.io/post-images/1594440416932.png" alt="3.1" loading="lazy"><br>
<img src="https://Vinci-Ma.github.io/post-images/1594440421736.png" alt="3.2" loading="lazy"><br>
<img src="https://Vinci-Ma.github.io/post-images/1594440426566.png" alt="3.3" loading="lazy"><br>
<img src="https://Vinci-Ma.github.io/post-images/1594440432621.png" alt="3.4" loading="lazy"><br>
<img src="https://Vinci-Ma.github.io/post-images/1594440437486.png" alt="4" loading="lazy"></p>
<h2 id="gson">Gson</h2>
<p>由Google开发的， Java 语言实现的 JSON 解析器和生成器。<br>
<a href="https://github.com/google/gson">Gson JAR文件下载地址</a>.</p>
<h3 id="1将对象转换成-gson">1.将对象转换成 GSON</h3>
<pre><code class="language-javascript">//将对象转换成 GSON
		Person p = new Person(&quot;哈利波特&quot;, 
			 new String[]{&quot;赫敏&quot;, &quot;罗恩&quot;},
			 new String[]{&quot;11英寸&quot;,&quot;冬青木，杖芯是凤凰福克斯的尾毛&quot;});
        String s = new Gson().toJson(p);
        System.out.println(s);
</code></pre>
<p><strong>输出结果：</strong><br>
<img src="https://img-blog.csdnimg.cn/20200711105924659.png" alt="在这里插入图片描述" loading="lazy"></p>
<h3 id="2将json转换成对象">2.将JSON转换成对象</h3>
<pre><code class="language-javascript">//将JSON转换成对象
        Person p = new Gson().fromJson(&quot;{\&quot;name\&quot;:\&quot;哈利波特\&quot;,\&quot;friends\&quot;:[\&quot;赫敏\&quot;,\&quot;罗恩\&quot;],\&quot;wand\&quot;:[\&quot;11英寸\&quot;,\&quot;冬青木，杖芯是凤凰福克斯的尾毛\&quot;]}\n&quot;,Person.class);
        System.out.println(p.getName());
        System.out.println(p.getFriends()[0]);
        System.out.println(p.getWand()[1]);
</code></pre>
<p><strong>输出结果：</strong><br>
<img src="https://img-blog.csdnimg.cn/20200711110505590.png" alt="在这里插入图片描述" loading="lazy"></p>
<h2 id="fastjson">FastJson</h2>
<p>由阿里巴巴的工程师开发的， Java 语言实现的 JSON 解析器和生成器。<br>
<a href="https://github.com/alibaba/fastjson">FastJson JAR文件下载地址</a>.</p>
<h3 id="1将对象转换成fastjson">1.将对象转换成FastJson</h3>
<pre><code class="language-javascript">//将对象转换成FastJson
		Person p = new Person(&quot;哈利波特&quot;, 
			new String[]{&quot;赫敏&quot;, &quot;罗恩&quot;}, 
			new String[]{&quot;11英寸&quot;,&quot;冬青木，杖芯是凤凰福克斯的尾毛&quot;});
        String fjson = JSON.toJSONString(p);
		System.out.println(p);
</code></pre>
<p><strong>输出结果：</strong><br>
<img src="https://img-blog.csdnimg.cn/20200711111258310.png" alt="在这里插入图片描述" loading="lazy"></p>
<h3 id="2将fastjson转换成对象">2.将FastJson转换成对象</h3>
<pre><code class="language-javascript">//将FastJson转换成对象
        Person p = JSON.parseObject(&quot;{\&quot;name\&quot;:\&quot;哈利波特\&quot;,\&quot;friends\&quot;:[\&quot;赫敏\&quot;,\&quot;罗恩\&quot;],\&quot;wand\&quot;:[\&quot;11英寸\&quot;,\&quot;冬青木，杖芯是凤凰福克斯的尾毛\&quot;]}\n&quot;,Person.class);
        System.out.println(p.getName());
        System.out.println(p.toString());
</code></pre>
<p><strong>输出结果：</strong><br>
<img src="https://img-blog.csdnimg.cn/20200711112008345.png" alt="在这里插入图片描述" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java中的递归算法]]></title>
        <id>https://Vinci-Ma.github.io/post/java-zhong-de-di-gui-suan-fa/</id>
        <link href="https://Vinci-Ma.github.io/post/java-zhong-de-di-gui-suan-fa/">
        </link>
        <updated>2020-06-25T15:15:44.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E7%9A%84%E4%B8%89%E4%B8%AA%E6%9D%A1%E4%BB%B6">使用递归算法的三个条件</a></li>
<li><a href="#%E9%80%92%E5%BD%92%E7%9A%84%E5%BA%94%E7%94%A8">递归的应用</a></li>
<li><a href="#%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B">程序示例</a>
<ul>
<li><a href="#1-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97">1、斐波那契数列</a></li>
<li><a href="#2-%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98">2、汉诺塔问题</a></li>
<li><a href="#3-%E4%BA%8C%E5%8F%89%E6%A0%91">3、二叉树</a></li>
</ul>
</li>
</ul>
(Java中的递归算法)<br>
编程语言中，函数直接或间接调用函数本身，则该函数称为递归函数。程序调用自身的编程技巧称为递归（ recursion）。递归通常是把一个大问题转化成为与大问题解决方法相似的小问题来解决，一般递归需要有<mark>边界条件</mark>、<mark>递归前进段</mark>和<mark>递归返回段</mark>。当边界条件不满足时，递归前进；当边界条件满足时，递归返回。</p>
<h1 id="使用递归算法的三个条件">使用递归算法的三个条件</h1>
<ol>
<li>一个问题可以分解为几个子问题</li>
<li>分解形成的子问题，除了数据规模不同，求解思路与原问题相同</li>
<li>存在递归终止的条件</li>
</ol>
<h1 id="递归的应用">递归的应用</h1>
<p>递归算法一般用于解决三类问题：</p>
<ol>
<li><strong>数据的定义是按递归定义的</strong><br>
如：斐波那契数列（Fibonacci sequence）</li>
<li><strong>问题解法按递归算法实现</strong><br>
如：汉诺塔问题（Hanoi）</li>
<li><strong>数据的结构形式是按递归定义的</strong><br>
如：二叉树、广义表等</li>
</ol>
<h1 id="程序示例">程序示例</h1>
<h2 id="1-斐波那契数列">1、斐波那契数列</h2>
<p>斐波那契数列（Fibonacci sequence），又称黄金分割数列，是这样一组数列：1、1、2、3、5、8、13、21、34、……从这个数列的第3项开始，每一项都等于前两项数字的和。</p>
<pre><code class="language-javascript">for (int i = 1;i &lt; 10;i++){
            System.out.printf(&quot;%4d&quot;,fibonacci(i));
        }
//结果为：   1   1   2   3   5   8  13  21  34

//f(n) = f(n - 1) + f(n - 2)
static int fibonacci(int nums){
        if (nums &lt; 0){
            return 1;
        }else if (nums &lt; 3){
            return 1;
        }else
            return fibonacci(nums - 1) + fibonacci(nums - 2);
    }
</code></pre>
<h2 id="2-汉诺塔问题">2、汉诺塔问题</h2>
<blockquote>
<p>相传在古印度圣庙中，有一种被称为汉诺塔(Hanoi)的游戏。该游戏是在一块铜板装置上，有三根杆(编号A、B、C)，在A杆自下而上、由大到小按顺序放置64个金盘(如下图)。游戏的目标：把A杆上的金盘全部移到C杆上，并仍保持原有顺序叠好。操作规则：每次只能移动一个盘子，并且在移动过程中三根杆上都始终保持大盘在下，小盘在上，操作过程中盘子可以置于A、B、C任一杆上。<br>
【百度百科】</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200705001114632.png" alt="汉诺塔" loading="lazy"><br>
思路：<br>
【注：start为圆盘开始时的位置，mid 为圆盘暂时存放的位置，last 为圆盘最终需要到达的位置】</p>
<ol>
<li>当圆盘个数为1时，可以直接从 start 移动到 last</li>
<li>当圆盘个数为n时，需要把（n - 1）个圆盘移动到 mid</li>
<li>最后把剩下的圆盘移动到 last</li>
</ol>
<pre><code class="language-javascript">hanoi(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,3);

static void hanoi(String start,String mid,String last,int n){
        if(n == 1){
            System.out.println(start+&quot;------&gt;&quot;+last);
        }else{
            //把 n - 1 个圆盘移动到过渡位置
            hanoi(start,last,mid,n-1);
            //把最底层的圆盘移动到最后的位置
            hanoi(start,mid,last,1);
            //把在过渡位置的 n - 1 个圆盘移动到最终的位置
            hanoi(mid,start,last,n-1);
        }

    }
</code></pre>
<p><strong>结果：</strong><br>
<img src="https://img-blog.csdnimg.cn/20200705003826677.png" alt="结果" loading="lazy"><br>
<strong>动画演示</strong><br>
<img src="https://Vinci-Ma.github.io/post-images/1593881942534.gif" alt="" loading="lazy"></p>
<h2 id="3-二叉树">3、二叉树</h2>
<p>见前篇<br>
链接: <a href="https://vinci-ma.github.io/post/er-cha-shu-bian-li-java-de-dai-ma-shi-xian/">二叉树遍历——Java的代码实现</a>.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二叉树遍历Java的代码实现]]></title>
        <id>https://Vinci-Ma.github.io/post/er-cha-shu-bian-li-java-de-dai-ma-shi-xian/</id>
        <link href="https://Vinci-Ma.github.io/post/er-cha-shu-bian-li-java-de-dai-ma-shi-xian/">
        </link>
        <updated>2020-06-24T13:14:39.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91">二叉树</a></li>
<li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86">二叉树的遍历</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">代码实现</a>
<ul>
<li><a href="#%E9%A6%96%E5%85%88%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9">首先创建一个结点</a></li>
<li><a href="#%E5%85%B6%E6%AC%A1%E6%98%AF%E8%BF%9B%E8%A1%8C%E9%81%8D%E5%8E%86%E6%93%8D%E4%BD%9C%E7%9A%84binarytree%E7%B1%BB">其次是进行遍历操作的BinaryTree类</a>
<ul>
<li><a href="#%E8%83%BD%E5%A4%9F%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E7%9A%84%E4%B8%89%E4%B8%AA%E6%9D%A1%E4%BB%B6">能够使用递归的三个条件</a></li>
<li><a href="#%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95%E8%AF%A6%E8%BF%B0%E4%BB%A5%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E4%B8%BA%E4%BE%8B">递归实现二叉树遍历方法详述（以中序遍历为例）</a></li>
</ul>
</li>
<li><a href="#%E4%B8%BB%E5%87%BD%E6%95%B0">主函数</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C">输出结果</a></li>
</ul>
</li>
</ul>
</p>
<h1 id="二叉树">二叉树</h1>
<p>二叉树是树的一种，每个结点最多可具有两个子树，即结点的度最大为2</p>
<h1 id="二叉树的遍历">二叉树的遍历</h1>
<p>先序遍历：先访问根节点，然后访问左节点，最后访问右节点。<br>
【1-&gt;2-&gt;4-&gt;8-&gt;9-&gt;5-&gt;10-&gt;3-&gt;6-&gt;7】<br>
<img src="https://img-blog.csdnimg.cn/20200627000853767.png?x-oss-process=image" alt="在这里插入图片描述" loading="lazy"><br>
中序遍历：先访问左节点，然后访问根节点，最后访问右节点。<br>
【8-&gt;4-&gt;9-&gt;2-&gt;10-&gt;5-&gt;1-&gt;6-&gt;3-&gt;7】<br>
<img src="https://img-blog.csdnimg.cn/20200627001030262.png?x-oss-process=image" alt="在这里插入图片描述" loading="lazy"><br>
后序遍历：先访问左节点，然后访问右节点，最后访问根节点。<br>
【8-&gt;9-&gt;4-&gt;10-&gt;5-&gt;2-&gt;6-&gt;7-&gt;3-&gt;1】<br>
<img src="https://img-blog.csdnimg.cn/20200627001118497.png?x-oss-process=image" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="代码实现">代码实现</h1>
<h2 id="首先创建一个结点">首先创建一个结点</h2>
<p>这个结点包括，一个根结点，一个根所对应的左结点，一个根所对应的右节点</p>
<pre><code class="language-javascript">public class Node {
    Object data;
    Node left = null;
    Node right = null;
    void Node(Object data,Node left,Node right){
        this.data = data;
        this.left = left;
        this.right = right;
    }
}
</code></pre>
<h2 id="其次是进行遍历操作的binarytree类">其次是进行遍历操作的BinaryTree类</h2>
<p>用递归的方法实现遍历</p>
<pre><code class="language-javascript">public class BinaryTree {
// 先序遍历
    void preSearch(Node root){
        if (root != null){
            System.out.printf(&quot;%-4s&quot;,root.data);
            preSearch(root.left);
            preSearch(root.right);
        }
    }
    // 中序遍历
    void midSearch(Node root){
        if (root != null){
            midSearch(root.left);
            System.out.printf(&quot;%-4s&quot;,root.data);
            midSearch(root.right);
        }
    }
    // 后序遍历
    void bacSearch(Node root){
        if (root != null){
            bacSearch(root.left);
            bacSearch(root.right);
            System.out.printf(&quot;%-4s&quot;,root.data);
        }
    }
}
</code></pre>
<h3 id="能够使用递归的三个条件">能够使用递归的三个条件</h3>
<ol>
<li>一个问题可以分解成几个子问题。</li>
<li>这个问题与分解过后的子问题，除了数据规模不同（子问题更为简单），求解思路完全一样。</li>
<li>存在一个明确的递归终止条件。</li>
</ol>
<p>在此例中，</p>
<ol>
<li>遍历二叉树的操作可以分解为遍历单个结点的操作。</li>
<li>遍历整个二叉树的操作和遍历一个结点的操作相同。</li>
<li>存在截止条件，即根节点不为null。</li>
</ol>
<p>所以，可以使用递归实现二叉树的遍历。</p>
<h3 id="递归实现二叉树遍历方法详述以中序遍历为例">递归实现二叉树遍历方法详述（以中序遍历为例）</h3>
<p><img src="https://img-blog.csdnimg.cn/20200627001030262.png?x-oss-process=image" alt="" loading="lazy"><br>
<img src="https://Vinci-Ma.github.io/post-images/1593329449625.jpg" alt="" loading="lazy"></p>
<h2 id="主函数">主函数</h2>
<pre><code class="language-javascript">public class E1 {
    public static void main(String[] args) {
        //构造一个二叉树
        Node node10 = new Node();
        node10.Node(&quot;10&quot;,null,null);
        Node node9 = new Node();
        node9.Node(&quot;9&quot;,null,null);
        Node node8 = new Node();
        node8.Node(&quot;8&quot;,null,null);
        Node node7 = new Node();
        node7.Node(&quot;7&quot;,null,null);
        Node node6 = new Node();
        node6.Node(&quot;6&quot;,null,null);
        Node node5 = new Node();
        node5.Node(&quot;5&quot;,node10,null);
        Node node4 = new Node();
        node4.Node(&quot;4&quot;,node8,node9);
        Node node3 = new Node();
        node3.Node(&quot;3&quot;,node6,node7);
        Node node2 = new Node();
        node2.Node(&quot;2&quot;,node4,node5);
        Node node1 = new Node();
        node1.Node(&quot;1&quot;,node2,node3);
        BinaryTree b = new BinaryTree();
        //对所构造的二叉树遍历输出
        System.out.println(&quot;前序遍历输出：&quot;);
        b.preSearch(node1);
        System.out.println();
        System.out.println(&quot;中序遍历输出：&quot;);
        b.midSearch(node1);
        System.out.println();
        System.out.println(&quot;后序遍历输出：&quot;);
        b.bacSearch(node1);
    }
}
</code></pre>
<h2 id="输出结果">输出结果</h2>
<figure data-type="image" tabindex="1"><img src="https://Vinci-Ma.github.io/post-images/1593178800956.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java基础学习——面向对象]]></title>
        <id>https://Vinci-Ma.github.io/post/java-ji-chu-xue-xi-mian-xiang-dui-xiang/</id>
        <link href="https://Vinci-Ma.github.io/post/java-ji-chu-xue-xi-mian-xiang-dui-xiang/">
        </link>
        <updated>2020-06-20T13:37:01.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3">面向对象思想</a>
<ul>
<li><a href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E6%80%9D%E6%83%B3">面向对象的三大思想</a></li>
<li><a href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81">面向对象的三大特征</a>
<ul>
<li><a href="#%E5%B0%81%E8%A3%85">封装</a></li>
<li><a href="#%E7%BB%A7%E6%89%BF">继承</a></li>
<li><a href="#%E5%A4%9A%E6%80%81">多态</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<h1 id="面向对象思想">面向对象思想</h1>
<p>面向对象（Object Oriented）是软件开发方法。面向对象（Procedure Oriented）是相对于面向过程来说的，指的是把相关的数据和方法组织为一个整体来看待。面向过程关注的是执行的过程，面向对象关注的是具备功能的对象。</p>
<h2 id="面向对象的三大思想">面向对象的三大思想</h2>
<p>OOA（Object Oriented Analysis）：面向对象分析<br>
OOD（Object Oriented Design）：面向对象设计<br>
OOP（Object Oriented Programming）：面向对象程序</p>
<h2 id="面向对象的三大特征">面向对象的三大特征</h2>
<h3 id="封装">封装</h3>
<p>1、隐藏具体的实现细节【安全性】<br>
2、对外提供公共的访问方式【功能】</p>
<h3 id="继承">继承</h3>
<p>1、子类可以继承父类的所有非私有成员（成员属性和成员方法）。<br>
2、子类不可以继承父类的构造，但是默认访问父类的空参构造。<br>
3、只可以单继承，不能多继承，但是可以多级继承。</p>
<h3 id="多态">多态</h3>
<p><strong>多态的前提：</strong></p>
<ol>
<li>有类的继承或接口的实现</li>
<li>子类重写父类的方法</li>
<li>父类引用指向子类对象</li>
</ol>
<p><strong>多态的成员访问特点：</strong></p>
<ol>
<li>属性：编译看父类，运行看父类 --- 只有父类有的，编译才能够通过&lt;-多态的弊端产生的原因</li>
<li><mark>功能：编译看父类，运行看子类</mark></li>
</ol>
<p>对于多态访问特点的理解：父类的引用指向子类的对象，可以理解为，fu的外在表现为父类，而实际内核是子类。<br>
对于属性来说，表现的是外在的特征，所以属性的运行看的是父类；<br>
而调用方法表现的是本质，所以运行的结果是子类。</p>
<pre><code class="language-javascript">//示例如下
public class E1 {
    public static void main(String[] args) {
        Fu fu = new Zi();// 3、父类的引用指向子类的对象
        fu.say();//结果：=====子类   ---&gt;对于功能来说：编译看父类，运行看子类
        //fu.show;----&gt;编译报错
        System.out.println(fu.name);//结果：父类   ---&gt;对于属性来说：编译看父类，运行看父类
        //System.out.println(fu.age);----&gt;编译报错
        Zi zi = (Zi) fu;//向下转型
        zi.show();//结果：=====子类show
    }
}
class Fu{
    String name = &quot;父类&quot;;
    public void say(){
        System.out.println(&quot;=====父类&quot;);
    }
}
class Zi extends Fu{  // 1、有类的继承或接口的实现
    String name = &quot;子类&quot;;
    int age;
    public void say(){  // 2、子类重写父类的方法
        System.out.println(&quot;=====子类&quot;);
    }
    public void show(){  
        System.out.println(&quot;=====子类show&quot;);
    }
}
</code></pre>
<p><strong>多态的成员访问特点：</strong></p>
<ol>
<li>属性：编译看父类，运行看父类 --- 只有父类有的，编译才能够通过&lt;-多态的弊端产生的原因</li>
<li>功能：编译看父类，运行看子类</li>
</ol>
<p><strong>多态的弊端：</strong><br>
不能访问子类特有的成员</p>
<p><mark><strong>应用场景：</strong></mark><br>
<mark>当做形参传递使用</mark></p>
<pre><code class="language-javascript">//例如在调用时
say(&quot;aaa&quot;);

//在定义该方法时，根本不需要指导具体的子类是谁，但是可以保证最终执行的是子类的功能
void say(Object o ){
    //实际参数 ====&gt; 形式参数  Object o = &quot;aaa&quot;;   形成了多态【父类引用指向子类的对象】
     System.out.println(o);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java基础学习——数组及其常用算法]]></title>
        <id>https://Vinci-Ma.github.io/post/java-ji-chu-xue-xi-shu-zu-ji-qi-chang-yong-suan-fa/</id>
        <link href="https://Vinci-Ma.github.io/post/java-ji-chu-xue-xi-shu-zu-ji-qi-chang-yong-suan-fa/">
        </link>
        <updated>2020-06-18T07:49:56.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E6%95%B0%E7%BB%84">数组</a>
<ul>
<li><a href="#%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84">一维数组</a>
<ul>
<li><a href="#%E5%88%9B%E5%BB%BA%E6%A0%BC%E5%BC%8F">创建格式</a></li>
<li><a href="#%E9%80%9A%E8%BF%87%E4%B8%8B%E6%A0%87%E5%AF%B9%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E6%93%8D%E4%BD%9C">通过下标对数据进行操作</a></li>
<li><a href="#%E8%8E%B7%E5%8F%96%E6%95%B0%E7%BB%84%E7%9A%84%E9%95%BF%E5%BA%A6">获取数组的长度</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84">二维数组</a>
<ul>
<li><a href="#%E5%88%9B%E5%BB%BA%E6%A0%BC%E5%BC%8F-2">创建格式</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95">数组常用算法</a>
<ul>
<li><a href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F">冒泡排序</a>
<ul>
<li><a href="#%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86">算法原理</a></li>
<li><a href="#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0">算法实现</a>
<ul>
<li><a href="#%E5%88%9D%E5%A7%8B%E7%8A%B6%E6%80%81">初始状态：</a></li>
<li><a href="#%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%BE%AA%E7%8E%AF">第一次循环：</a></li>
<li><a href="#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%BE%AA%E7%8E%AF">第二次循环：</a></li>
<li><a href="#%E7%AC%AC%E4%B8%89%E6%AC%A1%E5%BE%AA%E7%8E%AF">第三次循环：</a></li>
<li><a href="#%E7%AC%AC%E5%9B%9B%E6%AC%A1%E5%BE%AA%E7%8E%AF">第四次循环：</a></li>
<li><a href="#%E6%9C%80%E7%BB%88%E8%BE%93%E5%87%BA">最终输出</a></li>
</ul>
</li>
<li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">代码实现</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE">二分查找</a>
<ul>
<li><a href="#%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86-2">算法原理</a></li>
<li><a href="#%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4">实现步骤</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2">代码实现</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<h1 id="数组">数组</h1>
<p>所谓数组，是有序的元素序列。在java语言中，数组是一种最简单的复合数据类型，它是由一些具有相同的数据类型的元素所构成的，可以用一个统一的数组名和下标来唯一地确定数组中的元素。数组有一维数组和多维数组。</p>
<h2 id="一维数组">一维数组</h2>
<h3 id="创建格式">创建格式</h3>
<p>其中第1、2种较为常用<br>
1、数据类型[ ] 数组名称 = {数组内容1，数组内容2，……，数组内容n}；</p>
<pre><code class="language-javascript">// 示例如下
int[] age = {1, 2, 3 ,4};
</code></pre>
<p>2、数据类型[ ] 数组名称 = new 数据类型[数组长度]；</p>
<pre><code class="language-javascript">// 示例如下
int[] age = new int[4];
</code></pre>
<p>3、数据类型 [ ] 数组名称 = new 数据类型[ ] {数组内容1，数组内容2，……，数组内容n}；</p>
<pre><code class="language-javascript">// 示例如下
int[] age = new int[]{1, 2, 3 ,4};
</code></pre>
<p>4、数据类型[ ] 数组名；<br>
该种方法只创建了数组引用名，并未在内存中创建数组空间，只能通过以下方式进行初始化设置。</p>
<pre><code class="language-javascript">// 示例如下
int[] age;
age = new int[4];
</code></pre>
<h3 id="通过下标对数据进行操作">通过下标对数据进行操作</h3>
<p>赋值操作：<br>
数组名[下标] = 值；</p>
<pre><code class="language-javascript">// 把13赋予了age数组中的第一个元素，该元素在数组中的编号为0
age[0] = 13;
</code></pre>
<p>取值操作：<br>
数组名[下标]</p>
<pre><code class="language-javascript">// 示例如下
age[0];
</code></pre>
<h3 id="获取数组的长度">获取数组的长度</h3>
<p>数组名称.length</p>
<pre><code class="language-javascript">// 示例如下
age.length;
</code></pre>
<h2 id="二维数组">二维数组</h2>
<h3 id="创建格式-2">创建格式</h3>
<p>数据类型[ ][ ] 数组名 = new 数据类型[长度][(可写可不写) ]；</p>
<pre><code class="language-javascript">// 示例如下
int[][] age = new int [4][];
</code></pre>
<h1 id="数组常用算法">数组常用算法</h1>
<h2 id="冒泡排序">冒泡排序</h2>
<p>冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。它重复地走访过要排序的元素列，依次比较两个相邻的元素，如果顺序（如从大到小、首字母从Z到A）错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素列已经排序完成。<br>
【以下以升序排列为例】</p>
<h3 id="算法原理">算法原理</h3>
<p>1、比较相邻两个数值的大小，将数值较大的移动到右边。<br>
2、对每一对相邻元素都进行1中的比较，直到所有相邻元素都经过了比较。此时完成一次外层循环，将最大的数值移动到了数组最右边。<br>
3、重复1、2的操作，直至所有的元素在数组中都按照从小到大的顺序排列。</p>
<h3 id="算法实现">算法实现</h3>
<p>以数组nums = {1,15,9,5,7}为例</p>
<h4 id="初始状态">初始状态：</h4>
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">15</th>
<th style="text-align:center">9</th>
<th style="text-align:center">5</th>
<th style="text-align:center">7</th>
</tr>
</thead>
<tbody></tbody>
</table>
<h4 id="第一次循环">第一次循环：</h4>
<p>第1趟排序：<br>
1和15相比较</p>
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">15</th>
<th style="text-align:center">9</th>
<th style="text-align:center">5</th>
<th style="text-align:center">7</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>第2趟排序：<br>
15和9相比较</p>
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">9</th>
<th style="text-align:center">15</th>
<th style="text-align:center">5</th>
<th style="text-align:center">7</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>第3趟排序：<br>
15和5相比较</p>
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">9</th>
<th style="text-align:center">5</th>
<th style="text-align:center">15</th>
<th style="text-align:center">7</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>第4趟排序：<br>
15和7相比较</p>
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">9</th>
<th style="text-align:center">5</th>
<th style="text-align:center">7</th>
<th style="text-align:center">15</th>
</tr>
</thead>
<tbody></tbody>
</table>
<h4 id="第二次循环">第二次循环：</h4>
<p>第1趟排序：<br>
1和9相比较</p>
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">9</th>
<th style="text-align:center">5</th>
<th style="text-align:center">7</th>
<th style="text-align:center">15</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>第2趟排序：<br>
9和5相比较</p>
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">5</th>
<th style="text-align:center">9</th>
<th style="text-align:center">7</th>
<th style="text-align:center">15</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>第3趟排序：<br>
9和7相比较</p>
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">5</th>
<th style="text-align:center">7</th>
<th style="text-align:center">9</th>
<th style="text-align:center">15</th>
</tr>
</thead>
<tbody></tbody>
</table>
<h4 id="第三次循环">第三次循环：</h4>
<p>第1趟排序：<br>
1和5相比较</p>
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">5</th>
<th style="text-align:center">7</th>
<th style="text-align:center">9</th>
<th style="text-align:center">15</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>第2趟排序：<br>
5和7相比较</p>
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">5</th>
<th style="text-align:center">7</th>
<th style="text-align:center">9</th>
<th style="text-align:center">15</th>
</tr>
</thead>
<tbody></tbody>
</table>
<h4 id="第四次循环">第四次循环：</h4>
<p>第1趟排序：<br>
1和5相比较</p>
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">5</th>
<th style="text-align:center">7</th>
<th style="text-align:center">9</th>
<th style="text-align:center">15</th>
</tr>
</thead>
<tbody></tbody>
</table>
<h4 id="最终输出">最终输出</h4>
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">5</th>
<th style="text-align:center">7</th>
<th style="text-align:center">9</th>
<th style="text-align:center">15</th>
</tr>
</thead>
<tbody></tbody>
</table>
<h3 id="代码实现">代码实现</h3>
<pre><code class="language-javascript">	// 示例如下
	int[] nums = {1,15,9,5,7};
	for(int i=0; i&lt;nums.length; i++) {
		for(int j=0; j&lt;nums.length-i-1; j++) {
		//如果nums[j+1]的值小于nums[j]，则交换两者位置，使得较大的数字在右边
			if(nums[j+1]&lt;nums[j]) {
				nums[j+1] = nums[j] + nums[j+1];
				nums[j] = nums[j+1] - nums[j];
				nums[j+1] = nums[j+1] - nums[j];					
			}
		}
	}
	//利用for循环输出数组
	System.out.println(&quot;排序后的数组：&quot;);
	for(int i=0; i&lt;nums.length;i++)
	System.out.print(nums[i]+&quot;  &quot;);
</code></pre>
<p>编译结果<br>
<img src="https://img-blog.csdnimg.cn/20200613143855899.png" alt="编译结果" loading="lazy"></p>
<h2 id="二分查找">二分查找</h2>
<p>二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，二分查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。</p>
<h3 id="算法原理-2">算法原理</h3>
<p>1、假设数组中元素是有序排列，将数组中间位置的数据与查找数据比较，如果两者相等，则查找成功。<br>
2、否则利用中间位置记录将数组分成前、后两个子数组，如果中间位置数据大于查找数据，则进一步查找前子数<br>
组，否则进一步查找后子数组。<br>
3、重复以上过程，直到找到满足条件的数据，则表示查找成功，直到子数组不存在为止，表示查找不成功。</p>
<h3 id="实现步骤">实现步骤</h3>
<p>1、确定查找范围，最小——最大<br>
2、计算中间下标  =（最小+最大）/2<br>
3、比较中间下标和寻找的数据大小关系，如果中间下标所对应的元素比所寻找的数字小，则证明所要寻找的数字在数组的右半段，令最小下标 = 中间下标 + 1，中间下标  =（最小+最大）/2，最大下标不变，继续寻找。<br>
4、如果最小下标 &gt; 最大下标，说明数据不存在</p>
<h3 id="代码实现-2">代码实现</h3>
<pre><code class="language-javascript">// 示例如下
//使用二分法查找6，nums为上述冒泡排序示例
		int a = 6;
		int max = nums.length - 1;
		int min = 0;
		int mid =  (max + min)/2;
		while(true) {
			if(nums[mid] == a)
				break;
			//所要查找的数字在右半段
			else if(nums[mid] &lt; a) {
				min = mid + 1;
				mid = (max + min)/2;
			}
			//所要查找的数据在左半端
			else if(nums[mid] &gt; a) {
				max = mid - 1;
				mid = (max + min)/2;
			}
			
			if(min &gt; max){
				mid = -1;
				break;		
			}
			
		}
		if(mid == -1)
			System.out.println(&quot;没有这个数&quot;);
		else
			System.out.println(&quot;找到了&quot;+a+&quot;，其下标为：&quot;+mid);
</code></pre>
<p>编译结果：<br>
当a = 6时，即所要查找的数字是6<br>
<img src="https://img-blog.csdnimg.cn/2020061314410351.png" alt="当a = 6时" loading="lazy"><br>
当a = 9时，即所要查找的数字是9<br>
<img src="https://img-blog.csdnimg.cn/20200613150423899.png" alt="当a = 9时" loading="lazy"></p>
]]></content>
    </entry>
</feed>