<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Vinci-Ma.github.io</id>
    <title>Vinci-Ma</title>
    <updated>2020-07-12T07:43:47.155Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Vinci-Ma.github.io"/>
    <link rel="self" href="https://Vinci-Ma.github.io/atom.xml"/>
    <subtitle>Stay cooool!</subtitle>
    <logo>https://Vinci-Ma.github.io/images/avatar.png</logo>
    <icon>https://Vinci-Ma.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Vinci-Ma</rights>
    <entry>
        <title type="html"><![CDATA[红楼梦]]></title>
        <id>https://Vinci-Ma.github.io/post/reads-hong-lou-meng/</id>
        <link href="https://Vinci-Ma.github.io/post/reads-hong-lou-meng/">
        </link>
        <updated>2020-07-12T07:41:15.000Z</updated>
        <content type="html"><![CDATA[<p>jdjjd</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java基础学习——JSON 解析]]></title>
        <id>https://Vinci-Ma.github.io/post/java-ji-chu-xue-xi-json-jie-xi/</id>
        <link href="https://Vinci-Ma.github.io/post/java-ji-chu-xue-xi-json-jie-xi/">
        </link>
        <updated>2020-07-11T03:28:46.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#json%E7%AE%80%E4%BB%8B">JSON简介</a></li>
<li><a href="#json%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99">JSON语法规则</a></li>
<li><a href="#json%E8%A7%A3%E6%9E%90">JSON解析</a>
<ul>
<li><a href="#%E5%BC%95%E5%85%A5jar%E6%96%87%E4%BB%B6">引入JAR文件</a></li>
<li><a href="#gson">Gson</a>
<ul>
<li><a href="#1%E5%B0%86%E5%AF%B9%E8%B1%A1%E8%BD%AC%E6%8D%A2%E6%88%90-gson">1.将对象转换成 GSON</a></li>
<li><a href="#2%E5%B0%86json%E8%BD%AC%E6%8D%A2%E6%88%90%E5%AF%B9%E8%B1%A1">2.将JSON转换成对象</a></li>
</ul>
</li>
<li><a href="#fastjson">FastJson</a>
<ul>
<li><a href="#1%E5%B0%86%E5%AF%B9%E8%B1%A1%E8%BD%AC%E6%8D%A2%E6%88%90fastjson">1.将对象转换成FastJson</a></li>
<li><a href="#2%E5%B0%86fastjson%E8%BD%AC%E6%8D%A2%E6%88%90%E5%AF%B9%E8%B1%A1">2.将FastJson转换成对象</a></li>
</ul>
</li>
</ul>
</li>
</ul>
(Java基础学习——JSON 解析)</p>
<h1 id="json简介">JSON简介</h1>
<blockquote>
<p>JSON(JavaScript Object Notation, JS 对象简谱) 是<mark>一种轻量级的数据交换格式</mark>。它基于 ECMAScript (欧洲计算机协会制定的js规范)的一个子集，<mark>采用完全独立于编程语言的文本格式来存储和表示数据</mark>。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。<br>
【百度百科】</p>
</blockquote>
<h1 id="json语法规则">JSON语法规则</h1>
<ol>
<li>对象由大括号表示，括号中通过键值对描述对象的属性；</li>
<li>键与值之间使用冒号连接，多个键值对之间用逗号分离；</li>
<li>键值对的键，用引号引住；</li>
<li>键值对的值，可以是JS中任意类型的数据</li>
</ol>
<pre><code class="language-javascript">// 示例
{
	&quot;name&quot;:&quot;哈利·波特&quot;，
	&quot;friends&quot;:[&quot;赫敏&quot;,&quot;罗恩&quot;,
			{
			&quot;name&quot;:&quot;小天狼星布莱克&quot;
			&quot;status&quot;:&quot;哈利的教父&quot;}]
	&quot;wand&quot;:{
		&quot;length&quot;:&quot;11英寸&quot;,
		&quot;details&quot;:&quot;冬青木，杖芯是凤凰福克斯的尾毛&quot;
	}
}
</code></pre>
<h1 id="json解析">JSON解析</h1>
<h2 id="引入jar文件">引入JAR文件</h2>
<p><img src="https://Vinci-Ma.github.io/post-images/1594440402092.png" alt="1" loading="lazy"><br>
<img src="https://Vinci-Ma.github.io/post-images/1594440409797.png" alt="2" loading="lazy"><br>
<img src="https://Vinci-Ma.github.io/post-images/1594440445090.png" alt="3" loading="lazy"><br>
<img src="https://Vinci-Ma.github.io/post-images/1594440416932.png" alt="3.1" loading="lazy"><br>
<img src="https://Vinci-Ma.github.io/post-images/1594440421736.png" alt="3.2" loading="lazy"><br>
<img src="https://Vinci-Ma.github.io/post-images/1594440426566.png" alt="3.3" loading="lazy"><br>
<img src="https://Vinci-Ma.github.io/post-images/1594440432621.png" alt="3.4" loading="lazy"><br>
<img src="https://Vinci-Ma.github.io/post-images/1594440437486.png" alt="4" loading="lazy"></p>
<h2 id="gson">Gson</h2>
<p>由Google开发的， Java 语言实现的 JSON 解析器和生成器。<br>
<a href="https://github.com/google/gson">Gson JAR文件下载地址</a>.</p>
<h3 id="1将对象转换成-gson">1.将对象转换成 GSON</h3>
<pre><code class="language-javascript">//将对象转换成 GSON
		Person p = new Person(&quot;哈利波特&quot;, 
			 new String[]{&quot;赫敏&quot;, &quot;罗恩&quot;},
			 new String[]{&quot;11英寸&quot;,&quot;冬青木，杖芯是凤凰福克斯的尾毛&quot;});
        String s = new Gson().toJson(p);
        System.out.println(s);
</code></pre>
<p><strong>输出结果：</strong><br>
<img src="https://img-blog.csdnimg.cn/20200711105924659.png" alt="在这里插入图片描述" loading="lazy"></p>
<h3 id="2将json转换成对象">2.将JSON转换成对象</h3>
<pre><code class="language-javascript">//将JSON转换成对象
        Person p = new Gson().fromJson(&quot;{\&quot;name\&quot;:\&quot;哈利波特\&quot;,\&quot;friends\&quot;:[\&quot;赫敏\&quot;,\&quot;罗恩\&quot;],\&quot;wand\&quot;:[\&quot;11英寸\&quot;,\&quot;冬青木，杖芯是凤凰福克斯的尾毛\&quot;]}\n&quot;,Person.class);
        System.out.println(p.getName());
        System.out.println(p.getFriends()[0]);
        System.out.println(p.getWand()[1]);
</code></pre>
<p><strong>输出结果：</strong><br>
<img src="https://img-blog.csdnimg.cn/20200711110505590.png" alt="在这里插入图片描述" loading="lazy"></p>
<h2 id="fastjson">FastJson</h2>
<p>由阿里巴巴的工程师开发的， Java 语言实现的 JSON 解析器和生成器。<br>
<a href="https://github.com/alibaba/fastjson">FastJson JAR文件下载地址</a>.</p>
<h3 id="1将对象转换成fastjson">1.将对象转换成FastJson</h3>
<pre><code class="language-javascript">//将对象转换成FastJson
		Person p = new Person(&quot;哈利波特&quot;, 
			new String[]{&quot;赫敏&quot;, &quot;罗恩&quot;}, 
			new String[]{&quot;11英寸&quot;,&quot;冬青木，杖芯是凤凰福克斯的尾毛&quot;});
        String fjson = JSON.toJSONString(p);
		System.out.println(p);
</code></pre>
<p><strong>输出结果：</strong><br>
<img src="https://img-blog.csdnimg.cn/20200711111258310.png" alt="在这里插入图片描述" loading="lazy"></p>
<h3 id="2将fastjson转换成对象">2.将FastJson转换成对象</h3>
<pre><code class="language-javascript">//将FastJson转换成对象
        Person p = JSON.parseObject(&quot;{\&quot;name\&quot;:\&quot;哈利波特\&quot;,\&quot;friends\&quot;:[\&quot;赫敏\&quot;,\&quot;罗恩\&quot;],\&quot;wand\&quot;:[\&quot;11英寸\&quot;,\&quot;冬青木，杖芯是凤凰福克斯的尾毛\&quot;]}\n&quot;,Person.class);
        System.out.println(p.getName());
        System.out.println(p.toString());
</code></pre>
<p><strong>输出结果：</strong><br>
<img src="https://img-blog.csdnimg.cn/20200711112008345.png" alt="在这里插入图片描述" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java中的递归算法]]></title>
        <id>https://Vinci-Ma.github.io/post/java-zhong-de-di-gui-suan-fa/</id>
        <link href="https://Vinci-Ma.github.io/post/java-zhong-de-di-gui-suan-fa/">
        </link>
        <updated>2020-06-25T15:15:44.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E7%9A%84%E4%B8%89%E4%B8%AA%E6%9D%A1%E4%BB%B6">使用递归算法的三个条件</a></li>
<li><a href="#%E9%80%92%E5%BD%92%E7%9A%84%E5%BA%94%E7%94%A8">递归的应用</a></li>
<li><a href="#%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B">程序示例</a>
<ul>
<li><a href="#1-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97">1、斐波那契数列</a></li>
<li><a href="#2-%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98">2、汉诺塔问题</a></li>
<li><a href="#3-%E4%BA%8C%E5%8F%89%E6%A0%91">3、二叉树</a></li>
</ul>
</li>
</ul>
(Java中的递归算法)<br>
编程语言中，函数直接或间接调用函数本身，则该函数称为递归函数。程序调用自身的编程技巧称为递归（ recursion）。递归通常是把一个大问题转化成为与大问题解决方法相似的小问题来解决，一般递归需要有<mark>边界条件</mark>、<mark>递归前进段</mark>和<mark>递归返回段</mark>。当边界条件不满足时，递归前进；当边界条件满足时，递归返回。</p>
<h1 id="使用递归算法的三个条件">使用递归算法的三个条件</h1>
<ol>
<li>一个问题可以分解为几个子问题</li>
<li>分解形成的子问题，除了数据规模不同，求解思路与原问题相同</li>
<li>存在递归终止的条件</li>
</ol>
<h1 id="递归的应用">递归的应用</h1>
<p>递归算法一般用于解决三类问题：</p>
<ol>
<li><strong>数据的定义是按递归定义的</strong><br>
如：斐波那契数列（Fibonacci sequence）</li>
<li><strong>问题解法按递归算法实现</strong><br>
如：汉诺塔问题（Hanoi）</li>
<li><strong>数据的结构形式是按递归定义的</strong><br>
如：二叉树、广义表等</li>
</ol>
<h1 id="程序示例">程序示例</h1>
<h2 id="1-斐波那契数列">1、斐波那契数列</h2>
<p>斐波那契数列（Fibonacci sequence），又称黄金分割数列，是这样一组数列：1、1、2、3、5、8、13、21、34、……从这个数列的第3项开始，每一项都等于前两项数字的和。</p>
<pre><code class="language-javascript">for (int i = 1;i &lt; 10;i++){
            System.out.printf(&quot;%4d&quot;,fibonacci(i));
        }
//结果为：   1   1   2   3   5   8  13  21  34

//f(n) = f(n - 1) + f(n - 2)
static int fibonacci(int nums){
        if (nums &lt; 0){
            return 1;
        }else if (nums &lt; 3){
            return 1;
        }else
            return fibonacci(nums - 1) + fibonacci(nums - 2);
    }
</code></pre>
<h2 id="2-汉诺塔问题">2、汉诺塔问题</h2>
<blockquote>
<p>相传在古印度圣庙中，有一种被称为汉诺塔(Hanoi)的游戏。该游戏是在一块铜板装置上，有三根杆(编号A、B、C)，在A杆自下而上、由大到小按顺序放置64个金盘(如下图)。游戏的目标：把A杆上的金盘全部移到C杆上，并仍保持原有顺序叠好。操作规则：每次只能移动一个盘子，并且在移动过程中三根杆上都始终保持大盘在下，小盘在上，操作过程中盘子可以置于A、B、C任一杆上。<br>
【百度百科】</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200705001114632.png" alt="汉诺塔" loading="lazy"><br>
思路：<br>
【注：start为圆盘开始时的位置，mid 为圆盘暂时存放的位置，last 为圆盘最终需要到达的位置】</p>
<ol>
<li>当圆盘个数为1时，可以直接从 start 移动到 last</li>
<li>当圆盘个数为n时，需要把（n - 1）个圆盘移动到 mid</li>
<li>最后把剩下的圆盘移动到 last</li>
</ol>
<pre><code class="language-javascript">hanoi(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,3);

static void hanoi(String start,String mid,String last,int n){
        if(n == 1){
            System.out.println(start+&quot;------&gt;&quot;+last);
        }else{
            //把 n - 1 个圆盘移动到过渡位置
            hanoi(start,last,mid,n-1);
            //把最底层的圆盘移动到最后的位置
            hanoi(start,mid,last,1);
            //把在过渡位置的 n - 1 个圆盘移动到最终的位置
            hanoi(mid,start,last,n-1);
        }

    }
</code></pre>
<p><strong>结果：</strong><br>
<img src="https://img-blog.csdnimg.cn/20200705003826677.png" alt="结果" loading="lazy"><br>
<strong>动画演示</strong><br>
<img src="https://Vinci-Ma.github.io/post-images/1593881942534.gif" alt="" loading="lazy"></p>
<h2 id="3-二叉树">3、二叉树</h2>
<p>见前篇<br>
链接: <a href="https://vinci-ma.github.io/post/er-cha-shu-bian-li-java-de-dai-ma-shi-xian/">二叉树遍历——Java的代码实现</a>.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二叉树遍历Java的代码实现]]></title>
        <id>https://Vinci-Ma.github.io/post/er-cha-shu-bian-li-java-de-dai-ma-shi-xian/</id>
        <link href="https://Vinci-Ma.github.io/post/er-cha-shu-bian-li-java-de-dai-ma-shi-xian/">
        </link>
        <updated>2020-06-24T13:14:39.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91">二叉树</a></li>
<li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86">二叉树的遍历</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">代码实现</a>
<ul>
<li><a href="#%E9%A6%96%E5%85%88%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9">首先创建一个结点</a></li>
<li><a href="#%E5%85%B6%E6%AC%A1%E6%98%AF%E8%BF%9B%E8%A1%8C%E9%81%8D%E5%8E%86%E6%93%8D%E4%BD%9C%E7%9A%84binarytree%E7%B1%BB">其次是进行遍历操作的BinaryTree类</a>
<ul>
<li><a href="#%E8%83%BD%E5%A4%9F%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E7%9A%84%E4%B8%89%E4%B8%AA%E6%9D%A1%E4%BB%B6">能够使用递归的三个条件</a></li>
<li><a href="#%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95%E8%AF%A6%E8%BF%B0%E4%BB%A5%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E4%B8%BA%E4%BE%8B">递归实现二叉树遍历方法详述（以中序遍历为例）</a></li>
</ul>
</li>
<li><a href="#%E4%B8%BB%E5%87%BD%E6%95%B0">主函数</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C">输出结果</a></li>
</ul>
</li>
</ul>
</p>
<h1 id="二叉树">二叉树</h1>
<p>二叉树是树的一种，每个结点最多可具有两个子树，即结点的度最大为2</p>
<h1 id="二叉树的遍历">二叉树的遍历</h1>
<p>先序遍历：先访问根节点，然后访问左节点，最后访问右节点。<br>
【1-&gt;2-&gt;4-&gt;8-&gt;9-&gt;5-&gt;10-&gt;3-&gt;6-&gt;7】<br>
<img src="https://img-blog.csdnimg.cn/20200627000853767.png?x-oss-process=image" alt="在这里插入图片描述" loading="lazy"><br>
中序遍历：先访问左节点，然后访问根节点，最后访问右节点。<br>
【8-&gt;4-&gt;9-&gt;2-&gt;10-&gt;5-&gt;1-&gt;6-&gt;3-&gt;7】<br>
<img src="https://img-blog.csdnimg.cn/20200627001030262.png?x-oss-process=image" alt="在这里插入图片描述" loading="lazy"><br>
后序遍历：先访问左节点，然后访问右节点，最后访问根节点。<br>
【8-&gt;9-&gt;4-&gt;10-&gt;5-&gt;2-&gt;6-&gt;7-&gt;3-&gt;1】<br>
<img src="https://img-blog.csdnimg.cn/20200627001118497.png?x-oss-process=image" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="代码实现">代码实现</h1>
<h2 id="首先创建一个结点">首先创建一个结点</h2>
<p>这个结点包括，一个根结点，一个根所对应的左结点，一个根所对应的右节点</p>
<pre><code class="language-javascript">public class Node {
    Object data;
    Node left = null;
    Node right = null;
    void Node(Object data,Node left,Node right){
        this.data = data;
        this.left = left;
        this.right = right;
    }
}
</code></pre>
<h2 id="其次是进行遍历操作的binarytree类">其次是进行遍历操作的BinaryTree类</h2>
<p>用递归的方法实现遍历</p>
<pre><code class="language-javascript">public class BinaryTree {
// 先序遍历
    void preSearch(Node root){
        if (root != null){
            System.out.printf(&quot;%-4s&quot;,root.data);
            preSearch(root.left);
            preSearch(root.right);
        }
    }
    // 中序遍历
    void midSearch(Node root){
        if (root != null){
            midSearch(root.left);
            System.out.printf(&quot;%-4s&quot;,root.data);
            midSearch(root.right);
        }
    }
    // 后序遍历
    void bacSearch(Node root){
        if (root != null){
            bacSearch(root.left);
            bacSearch(root.right);
            System.out.printf(&quot;%-4s&quot;,root.data);
        }
    }
}
</code></pre>
<h3 id="能够使用递归的三个条件">能够使用递归的三个条件</h3>
<ol>
<li>一个问题可以分解成几个子问题。</li>
<li>这个问题与分解过后的子问题，除了数据规模不同（子问题更为简单），求解思路完全一样。</li>
<li>存在一个明确的递归终止条件。</li>
</ol>
<p>在此例中，</p>
<ol>
<li>遍历二叉树的操作可以分解为遍历单个结点的操作。</li>
<li>遍历整个二叉树的操作和遍历一个结点的操作相同。</li>
<li>存在截止条件，即根节点不为null。</li>
</ol>
<p>所以，可以使用递归实现二叉树的遍历。</p>
<h3 id="递归实现二叉树遍历方法详述以中序遍历为例">递归实现二叉树遍历方法详述（以中序遍历为例）</h3>
<p><img src="https://img-blog.csdnimg.cn/20200627001030262.png?x-oss-process=image" alt="" loading="lazy"><br>
<img src="https://Vinci-Ma.github.io/post-images/1593329449625.jpg" alt="" loading="lazy"></p>
<h2 id="主函数">主函数</h2>
<pre><code class="language-javascript">public class E1 {
    public static void main(String[] args) {
        //构造一个二叉树
        Node node10 = new Node();
        node10.Node(&quot;10&quot;,null,null);
        Node node9 = new Node();
        node9.Node(&quot;9&quot;,null,null);
        Node node8 = new Node();
        node8.Node(&quot;8&quot;,null,null);
        Node node7 = new Node();
        node7.Node(&quot;7&quot;,null,null);
        Node node6 = new Node();
        node6.Node(&quot;6&quot;,null,null);
        Node node5 = new Node();
        node5.Node(&quot;5&quot;,node10,null);
        Node node4 = new Node();
        node4.Node(&quot;4&quot;,node8,node9);
        Node node3 = new Node();
        node3.Node(&quot;3&quot;,node6,node7);
        Node node2 = new Node();
        node2.Node(&quot;2&quot;,node4,node5);
        Node node1 = new Node();
        node1.Node(&quot;1&quot;,node2,node3);
        BinaryTree b = new BinaryTree();
        //对所构造的二叉树遍历输出
        System.out.println(&quot;前序遍历输出：&quot;);
        b.preSearch(node1);
        System.out.println();
        System.out.println(&quot;中序遍历输出：&quot;);
        b.midSearch(node1);
        System.out.println();
        System.out.println(&quot;后序遍历输出：&quot;);
        b.bacSearch(node1);
    }
}
</code></pre>
<h2 id="输出结果">输出结果</h2>
<figure data-type="image" tabindex="1"><img src="https://Vinci-Ma.github.io/post-images/1593178800956.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java基础学习——面向对象]]></title>
        <id>https://Vinci-Ma.github.io/post/java-ji-chu-xue-xi-mian-xiang-dui-xiang/</id>
        <link href="https://Vinci-Ma.github.io/post/java-ji-chu-xue-xi-mian-xiang-dui-xiang/">
        </link>
        <updated>2020-06-20T13:37:01.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3">面向对象思想</a>
<ul>
<li><a href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E6%80%9D%E6%83%B3">面向对象的三大思想</a></li>
<li><a href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81">面向对象的三大特征</a>
<ul>
<li><a href="#%E5%B0%81%E8%A3%85">封装</a></li>
<li><a href="#%E7%BB%A7%E6%89%BF">继承</a></li>
<li><a href="#%E5%A4%9A%E6%80%81">多态</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<h1 id="面向对象思想">面向对象思想</h1>
<p>面向对象（Object Oriented）是软件开发方法。面向对象（Procedure Oriented）是相对于面向过程来说的，指的是把相关的数据和方法组织为一个整体来看待。面向过程关注的是执行的过程，面向对象关注的是具备功能的对象。</p>
<h2 id="面向对象的三大思想">面向对象的三大思想</h2>
<p>OOA（Object Oriented Analysis）：面向对象分析<br>
OOD（Object Oriented Design）：面向对象设计<br>
OOP（Object Oriented Programming）：面向对象程序</p>
<h2 id="面向对象的三大特征">面向对象的三大特征</h2>
<h3 id="封装">封装</h3>
<p>1、隐藏具体的实现细节【安全性】<br>
2、对外提供公共的访问方式【功能】</p>
<h3 id="继承">继承</h3>
<p>1、子类可以继承父类的所有非私有成员（成员属性和成员方法）。<br>
2、子类不可以继承父类的构造，但是默认访问父类的空参构造。<br>
3、只可以单继承，不能多继承，但是可以多级继承。</p>
<h3 id="多态">多态</h3>
<p><strong>多态的前提：</strong></p>
<ol>
<li>有类的继承或接口的实现</li>
<li>子类重写父类的方法</li>
<li>父类引用指向子类对象</li>
</ol>
<p><strong>多态的成员访问特点：</strong></p>
<ol>
<li>属性：编译看父类，运行看父类 --- 只有父类有的，编译才能够通过&lt;-多态的弊端产生的原因</li>
<li><mark>功能：编译看父类，运行看子类</mark></li>
</ol>
<p>对于多态访问特点的理解：父类的引用指向子类的对象，可以理解为，fu的外在表现为父类，而实际内核是子类。<br>
对于属性来说，表现的是外在的特征，所以属性的运行看的是父类；<br>
而调用方法表现的是本质，所以运行的结果是子类。</p>
<pre><code class="language-javascript">//示例如下
public class E1 {
    public static void main(String[] args) {
        Fu fu = new Zi();// 3、父类的引用指向子类的对象
        fu.say();//结果：=====子类   ---&gt;对于功能来说：编译看父类，运行看子类
        //fu.show;----&gt;编译报错
        System.out.println(fu.name);//结果：父类   ---&gt;对于属性来说：编译看父类，运行看父类
        //System.out.println(fu.age);----&gt;编译报错
        Zi zi = (Zi) fu;//向下转型
        zi.show();//结果：=====子类show
    }
}
class Fu{
    String name = &quot;父类&quot;;
    public void say(){
        System.out.println(&quot;=====父类&quot;);
    }
}
class Zi extends Fu{  // 1、有类的继承或接口的实现
    String name = &quot;子类&quot;;
    int age;
    public void say(){  // 2、子类重写父类的方法
        System.out.println(&quot;=====子类&quot;);
    }
    public void show(){  
        System.out.println(&quot;=====子类show&quot;);
    }
}
</code></pre>
<p><strong>多态的成员访问特点：</strong></p>
<ol>
<li>属性：编译看父类，运行看父类 --- 只有父类有的，编译才能够通过&lt;-多态的弊端产生的原因</li>
<li>功能：编译看父类，运行看子类</li>
</ol>
<p><strong>多态的弊端：</strong><br>
不能访问子类特有的成员</p>
<p><mark><strong>应用场景：</strong></mark><br>
<mark>当做形参传递使用</mark></p>
<pre><code class="language-javascript">//例如在调用时
say(&quot;aaa&quot;);

//在定义该方法时，根本不需要指导具体的子类是谁，但是可以保证最终执行的是子类的功能
void say(Object o ){
    //实际参数 ====&gt; 形式参数  Object o = &quot;aaa&quot;;   形成了多态【父类引用指向子类的对象】
     System.out.println(o);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java基础学习——数组及其常用算法]]></title>
        <id>https://Vinci-Ma.github.io/post/java-ji-chu-xue-xi-shu-zu-ji-qi-chang-yong-suan-fa/</id>
        <link href="https://Vinci-Ma.github.io/post/java-ji-chu-xue-xi-shu-zu-ji-qi-chang-yong-suan-fa/">
        </link>
        <updated>2020-06-18T07:49:56.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E6%95%B0%E7%BB%84">数组</a>
<ul>
<li><a href="#%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84">一维数组</a>
<ul>
<li><a href="#%E5%88%9B%E5%BB%BA%E6%A0%BC%E5%BC%8F">创建格式</a></li>
<li><a href="#%E9%80%9A%E8%BF%87%E4%B8%8B%E6%A0%87%E5%AF%B9%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E6%93%8D%E4%BD%9C">通过下标对数据进行操作</a></li>
<li><a href="#%E8%8E%B7%E5%8F%96%E6%95%B0%E7%BB%84%E7%9A%84%E9%95%BF%E5%BA%A6">获取数组的长度</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84">二维数组</a>
<ul>
<li><a href="#%E5%88%9B%E5%BB%BA%E6%A0%BC%E5%BC%8F-2">创建格式</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95">数组常用算法</a>
<ul>
<li><a href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F">冒泡排序</a>
<ul>
<li><a href="#%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86">算法原理</a></li>
<li><a href="#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0">算法实现</a>
<ul>
<li><a href="#%E5%88%9D%E5%A7%8B%E7%8A%B6%E6%80%81">初始状态：</a></li>
<li><a href="#%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%BE%AA%E7%8E%AF">第一次循环：</a></li>
<li><a href="#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%BE%AA%E7%8E%AF">第二次循环：</a></li>
<li><a href="#%E7%AC%AC%E4%B8%89%E6%AC%A1%E5%BE%AA%E7%8E%AF">第三次循环：</a></li>
<li><a href="#%E7%AC%AC%E5%9B%9B%E6%AC%A1%E5%BE%AA%E7%8E%AF">第四次循环：</a></li>
<li><a href="#%E6%9C%80%E7%BB%88%E8%BE%93%E5%87%BA">最终输出</a></li>
</ul>
</li>
<li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">代码实现</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE">二分查找</a>
<ul>
<li><a href="#%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86-2">算法原理</a></li>
<li><a href="#%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4">实现步骤</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2">代码实现</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<h1 id="数组">数组</h1>
<p>所谓数组，是有序的元素序列。在java语言中，数组是一种最简单的复合数据类型，它是由一些具有相同的数据类型的元素所构成的，可以用一个统一的数组名和下标来唯一地确定数组中的元素。数组有一维数组和多维数组。</p>
<h2 id="一维数组">一维数组</h2>
<h3 id="创建格式">创建格式</h3>
<p>其中第1、2种较为常用<br>
1、数据类型[ ] 数组名称 = {数组内容1，数组内容2，……，数组内容n}；</p>
<pre><code class="language-javascript">// 示例如下
int[] age = {1, 2, 3 ,4};
</code></pre>
<p>2、数据类型[ ] 数组名称 = new 数据类型[数组长度]；</p>
<pre><code class="language-javascript">// 示例如下
int[] age = new int[4];
</code></pre>
<p>3、数据类型 [ ] 数组名称 = new 数据类型[ ] {数组内容1，数组内容2，……，数组内容n}；</p>
<pre><code class="language-javascript">// 示例如下
int[] age = new int[]{1, 2, 3 ,4};
</code></pre>
<p>4、数据类型[ ] 数组名；<br>
该种方法只创建了数组引用名，并未在内存中创建数组空间，只能通过以下方式进行初始化设置。</p>
<pre><code class="language-javascript">// 示例如下
int[] age;
age = new int[4];
</code></pre>
<h3 id="通过下标对数据进行操作">通过下标对数据进行操作</h3>
<p>赋值操作：<br>
数组名[下标] = 值；</p>
<pre><code class="language-javascript">// 把13赋予了age数组中的第一个元素，该元素在数组中的编号为0
age[0] = 13;
</code></pre>
<p>取值操作：<br>
数组名[下标]</p>
<pre><code class="language-javascript">// 示例如下
age[0];
</code></pre>
<h3 id="获取数组的长度">获取数组的长度</h3>
<p>数组名称.length</p>
<pre><code class="language-javascript">// 示例如下
age.length;
</code></pre>
<h2 id="二维数组">二维数组</h2>
<h3 id="创建格式-2">创建格式</h3>
<p>数据类型[ ][ ] 数组名 = new 数据类型[长度][(可写可不写) ]；</p>
<pre><code class="language-javascript">// 示例如下
int[][] age = new int [4][];
</code></pre>
<h1 id="数组常用算法">数组常用算法</h1>
<h2 id="冒泡排序">冒泡排序</h2>
<p>冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。它重复地走访过要排序的元素列，依次比较两个相邻的元素，如果顺序（如从大到小、首字母从Z到A）错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素列已经排序完成。<br>
【以下以升序排列为例】</p>
<h3 id="算法原理">算法原理</h3>
<p>1、比较相邻两个数值的大小，将数值较大的移动到右边。<br>
2、对每一对相邻元素都进行1中的比较，直到所有相邻元素都经过了比较。此时完成一次外层循环，将最大的数值移动到了数组最右边。<br>
3、重复1、2的操作，直至所有的元素在数组中都按照从小到大的顺序排列。</p>
<h3 id="算法实现">算法实现</h3>
<p>以数组nums = {1,15,9,5,7}为例</p>
<h4 id="初始状态">初始状态：</h4>
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">15</th>
<th style="text-align:center">9</th>
<th style="text-align:center">5</th>
<th style="text-align:center">7</th>
</tr>
</thead>
<tbody></tbody>
</table>
<h4 id="第一次循环">第一次循环：</h4>
<p>第1趟排序：<br>
1和15相比较</p>
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">15</th>
<th style="text-align:center">9</th>
<th style="text-align:center">5</th>
<th style="text-align:center">7</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>第2趟排序：<br>
15和9相比较</p>
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">9</th>
<th style="text-align:center">15</th>
<th style="text-align:center">5</th>
<th style="text-align:center">7</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>第3趟排序：<br>
15和5相比较</p>
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">9</th>
<th style="text-align:center">5</th>
<th style="text-align:center">15</th>
<th style="text-align:center">7</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>第4趟排序：<br>
15和7相比较</p>
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">9</th>
<th style="text-align:center">5</th>
<th style="text-align:center">7</th>
<th style="text-align:center">15</th>
</tr>
</thead>
<tbody></tbody>
</table>
<h4 id="第二次循环">第二次循环：</h4>
<p>第1趟排序：<br>
1和9相比较</p>
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">9</th>
<th style="text-align:center">5</th>
<th style="text-align:center">7</th>
<th style="text-align:center">15</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>第2趟排序：<br>
9和5相比较</p>
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">5</th>
<th style="text-align:center">9</th>
<th style="text-align:center">7</th>
<th style="text-align:center">15</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>第3趟排序：<br>
9和7相比较</p>
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">5</th>
<th style="text-align:center">7</th>
<th style="text-align:center">9</th>
<th style="text-align:center">15</th>
</tr>
</thead>
<tbody></tbody>
</table>
<h4 id="第三次循环">第三次循环：</h4>
<p>第1趟排序：<br>
1和5相比较</p>
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">5</th>
<th style="text-align:center">7</th>
<th style="text-align:center">9</th>
<th style="text-align:center">15</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>第2趟排序：<br>
5和7相比较</p>
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">5</th>
<th style="text-align:center">7</th>
<th style="text-align:center">9</th>
<th style="text-align:center">15</th>
</tr>
</thead>
<tbody></tbody>
</table>
<h4 id="第四次循环">第四次循环：</h4>
<p>第1趟排序：<br>
1和5相比较</p>
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">5</th>
<th style="text-align:center">7</th>
<th style="text-align:center">9</th>
<th style="text-align:center">15</th>
</tr>
</thead>
<tbody></tbody>
</table>
<h4 id="最终输出">最终输出</h4>
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">5</th>
<th style="text-align:center">7</th>
<th style="text-align:center">9</th>
<th style="text-align:center">15</th>
</tr>
</thead>
<tbody></tbody>
</table>
<h3 id="代码实现">代码实现</h3>
<pre><code class="language-javascript">	// 示例如下
	int[] nums = {1,15,9,5,7};
	for(int i=0; i&lt;nums.length; i++) {
		for(int j=0; j&lt;nums.length-i-1; j++) {
		//如果nums[j+1]的值小于nums[j]，则交换两者位置，使得较大的数字在右边
			if(nums[j+1]&lt;nums[j]) {
				nums[j+1] = nums[j] + nums[j+1];
				nums[j] = nums[j+1] - nums[j];
				nums[j+1] = nums[j+1] - nums[j];					
			}
		}
	}
	//利用for循环输出数组
	System.out.println(&quot;排序后的数组：&quot;);
	for(int i=0; i&lt;nums.length;i++)
	System.out.print(nums[i]+&quot;  &quot;);
</code></pre>
<p>编译结果<br>
<img src="https://img-blog.csdnimg.cn/20200613143855899.png" alt="编译结果" loading="lazy"></p>
<h2 id="二分查找">二分查找</h2>
<p>二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，二分查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。</p>
<h3 id="算法原理-2">算法原理</h3>
<p>1、假设数组中元素是有序排列，将数组中间位置的数据与查找数据比较，如果两者相等，则查找成功。<br>
2、否则利用中间位置记录将数组分成前、后两个子数组，如果中间位置数据大于查找数据，则进一步查找前子数<br>
组，否则进一步查找后子数组。<br>
3、重复以上过程，直到找到满足条件的数据，则表示查找成功，直到子数组不存在为止，表示查找不成功。</p>
<h3 id="实现步骤">实现步骤</h3>
<p>1、确定查找范围，最小——最大<br>
2、计算中间下标  =（最小+最大）/2<br>
3、比较中间下标和寻找的数据大小关系，如果中间下标所对应的元素比所寻找的数字小，则证明所要寻找的数字在数组的右半段，令最小下标 = 中间下标 + 1，中间下标  =（最小+最大）/2，最大下标不变，继续寻找。<br>
4、如果最小下标 &gt; 最大下标，说明数据不存在</p>
<h3 id="代码实现-2">代码实现</h3>
<pre><code class="language-javascript">// 示例如下
//使用二分法查找6，nums为上述冒泡排序示例
		int a = 6;
		int max = nums.length - 1;
		int min = 0;
		int mid =  (max + min)/2;
		while(true) {
			if(nums[mid] == a)
				break;
			//所要查找的数字在右半段
			else if(nums[mid] &lt; a) {
				min = mid + 1;
				mid = (max + min)/2;
			}
			//所要查找的数据在左半端
			else if(nums[mid] &gt; a) {
				max = mid - 1;
				mid = (max + min)/2;
			}
			
			if(min &gt; max){
				mid = -1;
				break;		
			}
			
		}
		if(mid == -1)
			System.out.println(&quot;没有这个数&quot;);
		else
			System.out.println(&quot;找到了&quot;+a+&quot;，其下标为：&quot;+mid);
</code></pre>
<p>编译结果：<br>
当a = 6时，即所要查找的数字是6<br>
<img src="https://img-blog.csdnimg.cn/2020061314410351.png" alt="当a = 6时" loading="lazy"><br>
当a = 9时，即所要查找的数字是9<br>
<img src="https://img-blog.csdnimg.cn/20200613150423899.png" alt="当a = 9时" loading="lazy"></p>
]]></content>
    </entry>
</feed>