<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Vinci-Ma.github.io</id>
    <title>Vinci-Ma</title>
    <updated>2021-05-25T01:28:33.634Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Vinci-Ma.github.io"/>
    <link rel="self" href="https://Vinci-Ma.github.io/atom.xml"/>
    <subtitle>Stay cooool!</subtitle>
    <logo>https://Vinci-Ma.github.io/images/avatar.png</logo>
    <icon>https://Vinci-Ma.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Vinci-Ma</rights>
    <entry>
        <title type="html"><![CDATA[Spring]]></title>
        <id>https://Vinci-Ma.github.io/post/spring/</id>
        <link href="https://Vinci-Ma.github.io/post/spring/">
        </link>
        <updated>2020-09-16T07:39:57.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E4%B8%80-spring%E4%BB%8B%E7%BB%8D">一、Spring介绍</a>
<ul>
<li><a href="#1-%E7%89%B9%E7%82%B9">1、特点</a></li>
<li><a href="#2-%E7%BB%84%E7%BB%87%E6%A1%86%E6%9E%B6">2、组织框架</a></li>
<li><a href="#3-%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97">3、核心模块</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C-spring%E4%B8%AD%E7%9A%84ioc">二、Spring中的IOC</a>
<ul>
<li><a href="#1-%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B">1、实现过程</a></li>
<li><a href="#2-bean%E6%A0%87%E7%AD%BE%E7%9A%84%E5%B1%9E%E6%80%A7%E4%BB%8B%E7%BB%8D">2、bean标签的属性介绍</a></li>
<li><a href="#3-spring%E4%B8%AD%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E7%9A%84%E6%96%B9%E5%BC%8F">3、Spring中对象创建的方式</a></li>
<li><a href="#4-springbean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%87%8D%E8%A6%81">4、SpringBean的生命周期【重要】</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89-di%E6%B3%A8%E5%85%A5%E5%80%BC">三、DI注入值</a><br>
*
<ul>
<li><a href="#1-set%E6%B3%A8%E5%85%A5%E5%80%BC">1、set注入值</a></li>
<li><a href="#2-%E6%9E%84%E9%80%A0%E6%B3%A8%E5%85%A5">2、构造注入</a></li>
<li><a href="#3-spel-spring%E8%A1%A8%E8%BE%BE%E5%BC%8F">3、spel spring表达式</a></li>
<li><a href="#4-p%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E6%B3%A8%E5%85%A5%E5%80%BC">4、p命名空间注入值</a></li>
<li><a href="#5-%E5%A4%8D%E6%9D%82%E7%B1%BB%E5%9E%8B%E6%B3%A8%E5%85%A5objectlistsetmapjavautilproperties">5、复杂类型注入（Object[]，list，set，map，java.util.Properties）</a></li>
<li><a href="#6-%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%85%A5%E7%94%B1%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E7%BB%99%E5%B1%9E%E6%80%A7%E8%B5%8B%E5%80%BC">6、自动注入（由程序自动给属性赋值）</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9B-%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0ioc">四、注解实现IOC</a><br>
*
<ul>
<li><a href="#1-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E6%B7%BB%E5%8A%A0%E7%BA%A6%E6%9D%9F">1、配置文件中添加约束</a></li>
<li><a href="#3-%E9%85%8D%E7%BD%AE%E6%B3%A8%E8%A7%A3%E6%89%AB%E6%8F%8F%E6%8C%87%E5%AE%9A%E6%89%AB%E6%8F%8F%E5%8C%85%E4%B8%8B%E6%89%80%E6%9C%89%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3%E6%89%AB%E6%8F%8F%E5%8C%85%E6%97%B6%E4%BC%9A%E6%89%AB%E6%8F%8F%E5%8C%85%E6%89%80%E6%9C%89%E7%9A%84%E5%AD%90%E5%AD%99%E5%8C%85">3、配置注解扫描:指定扫描包下所有类中的注解,扫描包时,会扫描包所有的子孙包</a></li>
<li><a href="#3-%E6%B3%A8%E8%A7%A3">3、注解</a></li>
</ul>
</li>
<li><a href="#%E4%BA%94-aop%E4%BB%8B%E7%BB%8D">五、Aop介绍</a></li>
<li><a href="#%E5%85%AD-aop%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6">六、AOP的实现机制</a>
<ul>
<li><a href="#1-jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0">1、JDK动态代理实现</a></li>
<li><a href="#2-cglib%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%90%86">2、CGlib实现代理</a></li>
<li><a href="#%E4%B8%A4%E7%A7%8D%E4%BB%A3%E7%90%86%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB">两种代理方式的区别:</a></li>
</ul>
</li>
</ul>
</p>
<h1 id="一-spring介绍">一、Spring介绍</h1>
<blockquote>
<p>Spring是一个开放源代码的设计层面框架，他解决的是业务逻辑层和其他各层的松耦合问题，因此它将面向接口的编程思想贯穿整个系统应用。Spring是于2003 年兴起的一个轻量级的Java 开发框架，由Rod Johnson创建。简单来说，Spring是一个分层的JavaSE/EE full-stack(一站式) 轻量级开源框架。</p>
</blockquote>
<h2 id="1-特点">1、特点</h2>
<ul>
<li>1、<strong>方便解耦，简化开发</strong></li>
<li>2、<strong>AOP编程的支持</strong></li>
<li>3、<strong>声明式事务的支持</strong></li>
<li>4、<strong>方便程序的测试</strong></li>
<li>5、<strong>方便集成各种优秀框架</strong></li>
<li>6、<strong>降低Java EE API的使用难度</strong></li>
</ul>
<h2 id="2-组织框架">2、组织框架</h2>
<figure data-type="image" tabindex="1"><img src="https://Vinci-Ma.github.io/post-images/1600674050078.png" alt="组织框架" loading="lazy"></figure>
<h2 id="3-核心模块">3、核心模块</h2>
<ul>
<li>spring-core：依赖注入IOC与DI的最基本实现</li>
<li>spring-beans：Bean工厂与bean的装配</li>
<li>spring-context：spring的context上下文即IoC容器</li>
<li>spring-context-support</li>
<li>spring-expression：spring表达式语言</li>
</ul>
<h1 id="二-spring中的ioc">二、Spring中的IOC</h1>
<p>IOC是 Inverse of Control 的简写，意思是控制反转。是<strong>降低对象之间的耦合关系</strong>的设计思想。</p>
<p>DI是Dependency Injection的缩写，意思是依赖注入，说的是创建对象实例时，同时为这个对象注入它所依赖的属性。</p>
<h2 id="1-实现过程">1、实现过程</h2>
<p>1、添加对应依赖包</p>
<pre><code class="language-java">&lt;!-- Spring的核心工具包--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-core&lt;/artifactId&gt;
        &lt;version&gt;5.0.8.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
&lt;!--在基础IOC功能上提供扩展服务，还提供许多企业级服务的支持，有邮件服务、
任务调度、远程访问、缓存以及多种视图层框架的支持--&gt;
    &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;5.0.8.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
&lt;!-- Spring IOC的基础实现，包含访问配置文件、创建和管理bean等 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;
        &lt;version&gt;5.0.8.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
&lt;!-- Spring context的扩展支持，用于MVC方面 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;
        &lt;version&gt;5.0.8.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
&lt;!-- Spring表达式语言 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-expression&lt;/artifactId&gt;
        &lt;version&gt;5.0.8.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
</code></pre>
<p>2、创建配置文件applicationContext.xml</p>
<pre><code class="language-java">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
&lt;/beans&gt;
</code></pre>
<p>3、在配置文件中创建对象</p>
<pre><code class="language-java">&lt;bean id=&quot;对象名&quot; class=&quot;类的完整路径&quot;&gt;
	&lt;property name=&quot;属性名&quot; ref=&quot;对象的id值&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<p>4、加载配置文件，获得对象</p>
<pre><code class="language-java">ApplicationContext app=new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);//解析xml文件
Users users=(Users)app.getBean(&quot;u1&quot;);//通过getBean得到指定对象
</code></pre>
<h2 id="2-bean标签的属性介绍">2、bean标签的属性介绍</h2>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>class</td>
<td>指定bean对应类的全路径</td>
</tr>
<tr>
<td>name</td>
<td>name是bean对应对象的一个标识</td>
</tr>
<tr>
<td>scope</td>
<td>执行bean对象创建模式和生命周期,scope=&quot;singleton&quot;（默认单例）和scope=&quot;prototype&quot;（多例）</td>
</tr>
<tr>
<td>id</td>
<td>id是bean对象的唯一标识,不能添加特别字符</td>
</tr>
<tr>
<td>lazy-init</td>
<td>是否延时加载 默认值:false。true 延迟加载对象,当对象被调用的时候才会加载，测试的时候，通过getbean()方法获得对象。lazy-init=&quot;false&quot; 默认值，不延迟，无论对象是否被使用，都会立即创建对象,测试时只需要加载配置文件即可。注意:测试的时候只留下id,class属性</td>
</tr>
<tr>
<td>init-method</td>
<td>只需要加载配置文件即可对象初始化方法</td>
</tr>
<tr>
<td>destroy-method</td>
<td>对象销毁方法</td>
</tr>
</tbody>
</table>
<h2 id="3-spring中对象创建的方式">3、Spring中对象创建的方式</h2>
<p>1、无参构造</p>
<p>2、有参构造</p>
<pre><code class="language-java">public Person(String name , Car car){
        this.name = name;
        this.car = car;
        System.out.println(&quot;Person的有参构造方法:&quot;+name+car);
    }

	&lt;!--给属性赋值时，对象类型选择ref，非对象类型选择value--&gt;
    &lt;bean name=&quot;person&quot; class=&quot;com.vinci.spring.bean.Person&quot;&gt;
        &lt;constructor-arg name=&quot;name&quot; value=&quot;rose&quot;/&gt;
        &lt;constructor-arg name=&quot;car&quot; ref=&quot;car&quot;/&gt;
    &lt;/bean&gt;
</code></pre>
<p>3、静态方法创建对象</p>
<pre><code class="language-java">//静态工厂模式
public class PersonFactory {
    public static Person createPerson(){
        System.out.println(&quot;静态工厂创建Person&quot;);
        return new Person();
    }
}

&lt;bean name=&quot;pf&quot; class=&quot;com.xzk.PersonFactory&quot; factory-method=&quot;createPerson&quot; /&gt;
</code></pre>
<p>4、非静态工厂方法</p>
<pre><code class="language-java">public class Users{
    public Person createPerson1(){
        System.out.println(&quot;非静态工厂创建Person&quot;);
        return new Person();
    }
}

&lt;bean id=&quot;u2&quot; class=&quot;com.bean.Users&quot;&gt;&lt;/bean&gt;
&lt;bean id=&quot;u3&quot; factory-method=&quot;createPerson1&quot; factory-bean=&quot;u2&quot;&gt;&lt;/bean&gt;
</code></pre>
<h2 id="4-springbean的生命周期重要">4、SpringBean的生命周期【重要】</h2>
<figure data-type="image" tabindex="2"><img src="https://Vinci-Ma.github.io/post-images/1600674093500.png" alt="生命周期" loading="lazy"></figure>
<h1 id="三-di注入值">三、DI注入值</h1>
<p>分类:一种是调取属性的set方法赋值，第二种使用构造方法赋值</p>
<h3 id="1-set注入值">1、set注入值</h3>
<pre><code class="language-java">1、基本属性类型值注入
    &lt;property name=&quot;name&quot; value=&quot;jeck&quot; /&gt;
2、引用属性类型值注入
    &lt;property name=&quot;car&quot; ref=&quot;car&quot;&gt;&lt;/property&gt;
</code></pre>
<h3 id="2-构造注入">2、构造注入</h3>
<pre><code class="language-java">1、通过name属性，按照参数名赋值
    public Person(String name , Car car){
        this.name = name;
        this.car = car;
        System.out.println(&quot;Person的有参构造方法:&quot;+name+car);
    }
    &lt;bean name=&quot;person&quot; class=&quot;com.xzk.spring.bean.Person&quot;&gt;
        &lt;constructor-arg name=&quot;name&quot; value=&quot;rose&quot;/&gt;
        &lt;constructor-arg name=&quot;car&quot; ref=&quot;car&quot;/&gt;
    &lt;/bean&gt;
2、通过index属性，按照参数索引注入
        &lt;bean name=&quot;person2&quot; class=&quot;com.xzk.spring.bean.Person&quot;&gt;
    &lt;constructor-arg name=&quot;name&quot; value=&quot;helen&quot; index=&quot;0&quot;&gt;&lt;/constructor-arg&gt;
    &lt;constructor-arg name=&quot;car&quot; ref=&quot;car&quot; index=&quot;1&quot;&gt;&lt;/constructor-arg&gt;
    &lt;/bean&gt;
3、使用type注入（一般不使用）
     public Person(Car car, String name) {
            super();
            System.out.println(&quot;Person(Car car, String name)&quot;);
            this.name = name;
            this.car = car;
        }
        public Person(Car car, Integer name) {
            super();
            System.out.println(&quot;Person(Car car, Integer name)&quot;);
            this.name = name + &quot;&quot;;
            this.car = car;
        }
      &lt;bean name=&quot;person2&quot; class=&quot;com.xzk.spring.bean.Person&quot;&gt;
        &lt;constructor-arg name=&quot;name&quot; value=&quot;988&quot; type=&quot;java.lang.Integer&quot;&gt;
        &lt;/constructor-arg&gt;
        &lt;constructor-arg name=&quot;car&quot; ref=&quot;car&quot; &gt;&lt;/constructor-arg&gt;
      &lt;/bean&gt;   
</code></pre>
<h3 id="3-spel-spring表达式">3、spel spring表达式</h3>
<pre><code class="language-java">&lt;bean name=&quot;car&quot; class=&quot;com.xzk.spring.bean.Car&quot; &gt;
    &lt;property name=&quot;name&quot; value=&quot;mime&quot; /&gt;
    &lt;property name=&quot;color&quot; value=&quot;白色&quot;/&gt;
&lt;/bean&gt;
&lt;!--利用spel引入car的属性 --&gt;
&lt;bean name=&quot;person1&quot; class=&quot;com.xzk.spring.bean.Person&quot; p:car-ref=&quot;car&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;#{car.name}&quot;/&gt;
    &lt;property name=&quot;age&quot; value=&quot;#{person.age}&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<h3 id="4-p命名空间注入值">4、p命名空间注入值</h3>
<pre><code class="language-java">1、首先引用p命名空间【配置文件中 添加命名空间p】
    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
2、进行操作
    &lt;bean id=&quot;u6&quot; class=&quot;com.entity.Users&quot; p:age=&quot;30&quot; p:name=&quot;李四&quot; p:student-ref=&quot;stu1&quot;&gt;&lt;/bean&gt;
   基本类型值: p:属性名=&quot;值&quot;
   引用类型值: P:属性名-ref=&quot;bean名称&quot;
</code></pre>
<h3 id="5-复杂类型注入objectlistsetmapjavautilproperties">5、复杂类型注入（Object[]，list，set，map，java.util.Properties）</h3>
<pre><code class="language-java">&lt;!-- 数组变量注入 --&gt;
    &lt;property name=&quot;arrs&quot;&gt;
        &lt;list&gt;
            &lt;value&gt;数组1&lt;/value&gt;
            &lt;!--引入其他类型--&gt;
            &lt;ref bean=&quot;car&quot;/&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;!-- 集合变量赋值--&gt;
    &lt;property name=&quot;list&quot;&gt;
        &lt;list&gt;
            &lt;value&gt;集合1&lt;/value&gt;
            &lt;!--集合变量内部包含集合--&gt;
            &lt;list&gt;
            &lt;value&gt;集合中的集合1&lt;/value&gt;
            &lt;value&gt;集合中的集合2&lt;/value&gt;
            &lt;value&gt;集合中的集合3&lt;/value&gt;
            &lt;/list&gt;
            &lt;ref bean=&quot;car&quot; /&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;!-- set赋值--&gt;
     &lt;property name=&quot;set&quot;&gt;
        &lt;set&gt;
            &lt;value&gt;set&lt;/value&gt;
            &lt;!--引入其他类型--&gt;
            &lt;ref bean=&quot;car&quot;/&gt;
        &lt;/set&gt;
    &lt;/property&gt;
&lt;!--map赋值 --&gt;
    &lt;property name=&quot;map&quot;&gt;
        &lt;map&gt;
            &lt;entry key=&quot;car&quot; value-ref=&quot;car&quot; /&gt;（有ref是对象类型的引用）
            &lt;entry key=&quot;name&quot; value=&quot;保时捷&quot; /&gt;
            &lt;entry key=&quot;age&quot; value=&quot;11&quot;/&gt;
        &lt;/map&gt;
    &lt;/property&gt;
&lt;!-- properties赋值 --&gt;
    &lt;property name=&quot;properties&quot;&gt;
        &lt;props&gt;
            &lt;prop key=&quot;name&quot;&gt;pro1&lt;/prop&gt;
            &lt;prop key=&quot;age&quot;&gt;111&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
</code></pre>
<h3 id="6-自动注入由程序自动给属性赋值">6、自动注入（由程序自动给属性赋值）</h3>
<p>autowire：</p>
<ul>
<li>
<p>no 不自动装配(默认值)</p>
</li>
<li>
<p>byName 属性名=id名 ，调取set方法赋值</p>
</li>
<li>
<p>byType 属性的类型和id对象的类型相同，当找到多个同类型的对象时报错，调取set方法赋值</p>
</li>
<li>
<p>constructor 构造方法的参数类型和id对象的类型相同,当没有找到时，报错。调取构造方法赋值</p>
</li>
</ul>
<pre><code class="language-java">&lt;bean id=&quot;service&quot; class=&quot;service.impl.UserServiceImpl&quot; autowire=&quot;constructor&quot;&gt;
&lt;/bean&gt;
配置全局自动装配:
	&lt;beans default-autowire=&quot;constructor/byName/byType/no&quot;&gt;
</code></pre>
<h1 id="四-注解实现ioc">四、注解实现IOC</h1>
<h3 id="1-配置文件中添加约束">1、配置文件中添加约束</h3>
<pre><code class="language-java">xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
http://www.springframework.org/schema/context
http://www.springframework.org/schema/context/spring-context.xsd
</code></pre>
<h3 id="3-配置注解扫描指定扫描包下所有类中的注解扫描包时会扫描包所有的子孙包">3、配置注解扫描:指定扫描包下所有类中的注解,扫描包时,会扫描包所有的子孙包</h3>
<pre><code class="language-java">&lt;!--扫描包设置--&gt;
&lt;context:component-scan base-package=&quot;com.vinci.spring.bean&quot;&gt;&lt;/context:component-scan&gt;
</code></pre>
<h3 id="3-注解">3、注解</h3>
<pre><code class="language-java">1、添加在类名上
    @Component(&quot;对象名&quot;)
    @Service(&quot;person&quot;) // service层
    @Controller(&quot;person&quot;) // controller层
    @Repository(&quot;person&quot;) // dao层
    @Scope(scopeName=&quot;singleton&quot;) //单例对象
    @Scope(scopeName=&quot;prototype&quot;) //多例对象
</code></pre>
<pre><code class="language-java">2、添加在属性上
    @Value(&quot;属性值&quot;)
    private String name;
   
	@Autowired //默认使用byType，如果一个接口类型，同时有两个实现类，则报错，此时可以借助@Qualifier(&quot;beanname&quot;)    
	@Qualifier(&quot;bean name&quot;)
    private Car car;
    
	//说明:@Resource 是java的注释,但是Spring框架支持,@Resource指定注入哪个名称的对象
    //@Resource(name=&quot;对象名&quot;) == @Autowired + @Qualifier(&quot;name&quot;)   
	@Resource(name=&quot;baoma&quot;)
	private Car car;
</code></pre>
<pre><code class="language-java">3、添加在方法上
   @PostConstruct //等价于init-method属性
    public void init(){
   	 	System.out.println(&quot;初始化方法&quot;);
    }

    @PreDestroy //等价于destroy-method属性
    public void destroy(){
    	System.out.println(&quot;销毁方法&quot;);
    } 
</code></pre>
<h1 id="五-aop介绍">五、Aop介绍</h1>
<p>AOP（Aspect Oriented Programming)即面向切面编程。即在不改变原程序的基础上为代码段增加新的功能。应用在权限认证、日志、事务。</p>
<p>作用：<strong>分离</strong>系统中的各种关注点，将核心关注点和横切关注点分离开来。</p>
<figure data-type="image" tabindex="3"><img src="https://Vinci-Ma.github.io/post-images/1600674132700.png" alt="aop" loading="lazy"></figure>
<h1 id="六-aop的实现机制">六、AOP的实现机制</h1>
<ul>
<li>JDK 的动态代理：针对实现了接口的类产生代理。InvocationHandler接口</li>
<li>CGlib 的动态代理：针对没有实现接口的类产生代理，应用的是底层的字节码增强的技术 生成当前类的子类对象，MethodInterceptor接口</li>
</ul>
<h2 id="1-jdk动态代理实现">1、JDK动态代理实现</h2>
<pre><code class="language-java">1、创建接口和对应实现类
    public interface UserService {
    	public void login();
    }
	//实现类
    public class UserServiceImpl implements UserService {
    	public void login(){}
    }
2、创建动态代理类，实现InvocationHandler接口
    public class agency implements InvocationHandler {
            private UserService target; //目标对象
            public agency(UserService target){
             this.target = target;
            }
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
            //本方法中的其他输出输入增强
            //proxy 代理方法被调用的代理实例
            System.out.println(&quot;方法触发了&quot;);
            //执行被代理类 原方法
            Object invoke = method.invoke(target, args);
            System.out.println(&quot;执行完毕了&quot;);
            return invoke;
        }
    }
3、创建测试
    @Test
    public void test1(){
        //测试JDK动态代理技术
        UserService us = new UserServiceImpl();
        agency ag = new agency(us);
        //这里不能转换成一个实际的类，必须是接口类型
        UserService uservice = (UserService)     Proxy.newProxyInstance(us.getClass().getClassLoader(),us.getClass().getInterfaces(),ag);
        uservice.login();
    }

测试结果: 在调用接口方法的前后都会添加代理类的方法!
</code></pre>
<h2 id="2-cglib实现代理">2、CGlib实现代理</h2>
<ul>
<li>使用JDK创建代理有一个限制,它只能为接口创建代理实例.这一点可以从Proxy的接口方法newProxyInstance(ClassLoader loader,Class [] interfaces,InvocarionHandler h)中看的很清楚</li>
</ul>
<h2 id="两种代理方式的区别">两种代理方式的区别:</h2>
<ul>
<li>1、jdk动态代理生成的代理类和委托类实现了相同的接口；</li>
<li>2、cglib动态代理中生成的字节码更加复杂，生成的代理类是委托类的子类，且不能处理被final关键字修饰的方法；</li>
<li>3、jdk采用反射机制调用委托类的方法，cglib采用类似索引的方式直接调用委托类方法；</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Redis]]></title>
        <id>https://Vinci-Ma.github.io/post/redis/</id>
        <link href="https://Vinci-Ma.github.io/post/redis/">
        </link>
        <updated>2020-09-08T11:52:28.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#redis">Redis</a>
<ul>
<li><a href="#1-%E6%A6%82%E5%BF%B5">1、概念</a></li>
<li><a href="#2-redis%E4%BC%98%E5%8A%BF">2、Redis优势</a></li>
<li><a href="#3-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">3、应用场景</a></li>
<li><a href="#4-redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">4、Redis数据结构</a></li>
<li><a href="#5-redis%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4">5、Redis常用指令</a>
<ul>
<li><a href="#1-string">1、String</a></li>
<li><a href="#2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E5%AD%97%E7%9A%84%E9%80%92%E5%A2%9E%E4%B8%8E%E9%80%92%E5%87%8F">2、字符串数字的递增与递减</a></li>
<li><a href="#3-hash%E6%95%A3%E5%88%97">3、Hash散列</a></li>
<li><a href="#4-%E9%98%9F%E5%88%97list">4、队列List</a></li>
<li><a href="#5-set%E9%9B%86%E5%90%88">5、Set集合</a></li>
<li><a href="#6-zset%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88">6、Zset有序集合</a></li>
<li><a href="#7-hyoperloglog%E5%91%BD%E4%BB%A4">7、HyoperLogLog命令</a></li>
<li><a href="#8-%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4">8、其他命令</a></li>
<li><a href="#9-redis%E5%A4%9A%E6%95%B0%E6%8D%AE%E5%BA%93">9、Redis多数据库</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<h1 id="redis">Redis</h1>
<h2 id="1-概念">1、概念</h2>
<p>Redis：REmote DIctionary Server（远程字典服务器）。是完全开源免费的，用C语言编写的， 遵守BCD协议。是一个高性能的(key/value)分布式内存数据库，基于内存运行并支持持久化的NoSQL数据库，是当前最热门的NoSql数据库之一,也被人们称为数据结构服务器。</p>
<p>特点：</p>
<ul>
<li>Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用</li>
<li>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储</li>
<li>Redis支持数据的备份，即master-slave(主从)模式的数据备份</li>
</ul>
<h2 id="2-redis优势">2、Redis优势</h2>
<ul>
<li>1、<strong>性能极高</strong>： Redis能读的速度是110000次/s,写的速度是81000次/s 。</li>
<li>2、<strong>丰富的数据类型</strong>：Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</li>
<li>3、<strong>原子</strong>： Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。</li>
<li>4、**丰富的特性 **： Redis还支持 publish/subscribe, 通知, key 过期等等特性</li>
<li>5、采用<strong>单线程</strong>，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</li>
<li>6、使用<strong>多路I/O复用模型</strong>，非阻塞IO；</li>
</ul>
<h2 id="3-应用场景">3、应用场景</h2>
<p>（1） 缓存(数据查询，短连接，新闻内容，商品内容等)，使用最多</p>
<p>（2)）聊天室在线好友列表</p>
<p>（3）任务队列(秒杀，抢购，12306等)</p>
<p>（4） 应用排行榜</p>
<p>（5）网站访问统计</p>
<p>（6）数据过期处理(可以精确到毫秒)</p>
<p>（7）分布式集群架构中的session问题</p>
<h2 id="4-redis数据结构">4、Redis数据结构</h2>
<p>Redis是一种基于内存的数据库，并且提供一定的持久化功能，它是一种键值（key-value）数据库，使用 key 作为索引找到当前缓存的数据，并且返回给程序调用者。</p>
<p>当前的 Redis 支持 6 种数据类型，它们分别是字符串（String）、列表（List）、集合（set）、哈希结构（hash）、有序集合（zset）和基数（HyperLogLog）<br>
<img src="https://Vinci-Ma.github.io/post-images/1599306794527.png" alt="Redis的6种数据结构" loading="lazy"></p>
<h2 id="5-redis常用指令">5、Redis常用指令</h2>
<h3 id="1-string">1、String</h3>
<pre><code class="language-java">赋值语法：SET key value【set k1 zhangsan】
取值语法：GET key【get k1】
设置多个键语法：MSET key value [key value …]【mset k2 lisi k3 wangwu】
获得多个键值语法：MGET key [key …]【mget k2 k3】
删除语法：DEL key【del k3】
</code></pre>
<h3 id="2-字符串数字的递增与递减">2、字符串数字的递增与递减</h3>
<pre><code class="language-java">递增：INCR key【incr num】
递减：DECR key【decr num】
增加指定的整数：INCRBY key increment【incrby num2 2】
减少指定的整数：DECRBY key decrement【decrby num2 1】
</code></pre>
<h3 id="3-hash散列">3、Hash散列</h3>
<p>hash叫散列类型，它提供了字段和字段值的映射。字段值只能是字符串类型，不支持散列类型、集合类型等其它类型。相当于是对象格式的存储</p>
<pre><code class="language-java">赋值：HSET key field value【hset user1 username zhangsan】
取值：HGET key field【hget user1 username】
设置多个字段：HMSET key field value [field value ...]【hmset user1 password 123 age 20】
取多个值：HMGET key field [field ...]【hmget user1 password age】
获取所有字段值：HGETALL key【hgetall user1】
删除字段：HDEL key field [field ...]【hdel user1 username】
</code></pre>
<h3 id="4-队列list">4、队列List</h3>
<p>Redis的list是采用来链表来存储,双向链表存储数据，特点：增删快、查询慢(Linkedlist).这个队列是有序的。</p>
<pre><code class="language-java">向列表左边增加元素: LPUSH key value [value ...]
从列表左边弹出元素： LPOP key(临时存储，弹出后,从队列中清除)
向列表右边增加元素 : RPUSH key value [value ...]
从列表右边弹出元素： RPOP key
获取列表中元素的个数: LLEN key
查看列表语法：LRANGE key start stop
</code></pre>
<h3 id="5-set集合">5、Set集合</h3>
<p>Set集合类型：无序、不可重复</p>
<pre><code class="language-java">增加元素语法：SADD key member [member ...]
删除元素语法： SREM key member [member ...]
获得集合中的所有元素 ： smembers key
判断元素是否在集合中： SISMEMBER key member
</code></pre>
<h3 id="6-zset有序集合">6、Zset有序集合</h3>
<p>Sortedset又叫zset,是有序集合，可排序的，但是唯一。 Sortedset和set的不同之处，是会给set中的元素添加一个分数，然后通过这个分数进行排序。</p>
<pre><code class="language-java">增加元素：ZADD key score member [score member ...]
向有序集合中加入一个元素和该元素的分数(score)，如果该元素已经存在则会用新的分数替换原有的分数。
添加带分数(可用学生成绩，销售数量等来做分数,方便计算排序)：获得排名在某个范围的元素列表,并按照元素分数降序返回：ZREVRANGE key start stop [WITHSCORES]
获取元素的分数 :ZSCORE key member
删除元素ZREM key member [member ...]
获得元素的分数的可以在命令尾部加上WITHSCORES参数【zrevrange num1 0 4 withscores】
</code></pre>
<h3 id="7-hyoperloglog命令">7、HyoperLogLog命令</h3>
<p>HyperLogLog是一种使用随机化的算法，以少量内存提供集合中唯一元素数量的近似值。</p>
<p>HyperLogLog 可以接受多个元素作为输入，并给出输入元素的基数估算值：</p>
<ul>
<li>
<p>基数：集合中不同元素的数量。比如 {‘apple’, ‘banana’, ‘cherry’, ‘banana’, ‘apple’} 的基数就是 3 。</p>
</li>
<li>
<p>估算值：算法给出的基数并不是精确的，可能会比实际稍微多一些或者稍微少一些，但会控制在合理的范围之内。</p>
</li>
</ul>
<p>HyperLogLog 的优点是，即使输入元素的数量或者体积非常非常大，计算基数所需的空间总是固定的、并且是很小的。</p>
<p>HyperLogLog 相关的一些基本命令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>PFADD key element [element …]</td>
<td>将指定的元素添加到指定的HyperLogLog 中</td>
</tr>
<tr>
<td>PFCOUNT key [key …]</td>
<td>返回给定 HyperLogLog 的基数估算值</td>
</tr>
<tr>
<td>PFMERGE destkey sourcekey [sourcekey …]</td>
<td>将多个 HyperLogLog 合并为一个 HyperLogLog</td>
</tr>
</tbody>
</table>
<h3 id="8-其他命令">8、其他命令</h3>
<pre><code class="language-java">keys返回满足给定pattern 的所有key
    keys user* //查询以user开头的key
	keys * //查询所有的key
exists确认一个key 是否存在,存在返回1
    exists key
del删除一个key
    del key 删除存在的key返回1，不存在的key返回0
rename重命名key
    rename oldkey newkey
type返回值的类型
     type key
设置key的生存时间（单位：秒）key在多少秒后会自动删除
    EXPIRE key seconds
查看key剩余的生存时间
    TTL key 
清除生存时间
    PERSIST key 
获取服务器信息和统计:
    info
删除当前选择数据库中的所有key：
    flushdb
删除所有数据库中的所有key:
    flushall
</code></pre>
<h3 id="9-redis多数据库">9、Redis多数据库</h3>
<p>一个redis实例key包括多个数据库，客户端可以指定连接某个redis实例的哪个数据库，就好比一个mysql中创建多个数据库，客户端连接时指定连接哪个数据库。</p>
<pre><code class="language-java">切换数据库
    select 1【切换到1号数据库】
将key的值移动到其他数据库
    move key 数据库编号【eg：move username 1：把username移动到数据库1】   
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Maven]]></title>
        <id>https://Vinci-Ma.github.io/post/maven/</id>
        <link href="https://Vinci-Ma.github.io/post/maven/">
        </link>
        <updated>2020-09-04T12:35:39.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#1-maven%E6%A8%A1%E5%9E%8B%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86">1、Maven模型及其原理</a>
<ul>
<li><a href="#1-maven%E4%BB%8B%E7%BB%8D">1、Maven介绍</a></li>
<li><a href="#2-maven%E5%8A%9F%E8%83%BD">2、Maven功能</a></li>
<li><a href="#3-maven%E6%A8%A1%E5%9E%8B%E4%BB%8B%E7%BB%8D">3、Maven模型介绍</a></li>
<li><a href="#4-maven%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E5%8E%9F%E7%90%86">4、Maven依赖管理原理</a></li>
<li><a href="#5-maven%E6%A0%B8%E5%BF%83%E6%96%87%E4%BB%B6pomxml">5、Maven核心文件Pom.xml</a></li>
<li><a href="#6-%E6%90%AD%E5%BB%BA%E5%8E%9F%E7%94%9F%E7%9A%84maven%E9%A1%B9%E7%9B%AE">6、搭建原生的Maven项目</a>
<ul>
<li><a href="#1-%E9%80%9A%E8%BF%87%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E6%96%B9%E5%BC%8F%E5%88%9B%E5%BB%BAjava%E9%A1%B9%E7%9B%AE">1、通过文件夹的方式创建java项目</a></li>
</ul>
</li>
<li><a href="#7-maven%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4">7、Maven常用指令</a></li>
</ul>
</li>
</ul>
</p>
<h1 id="1-maven模型及其原理">1、Maven模型及其原理</h1>
<h2 id="1-maven介绍">1、Maven介绍</h2>
<p>Maven(麦文)项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的项目管理工具软件。</p>
<h2 id="2-maven功能">2、Maven功能</h2>
<ul>
<li>1、依赖管理——jar包管理</li>
<li>2、项目管理——代码编译</li>
</ul>
<h2 id="3-maven模型介绍">3、Maven模型介绍</h2>
<figure data-type="image" tabindex="1"><img src="https://Vinci-Ma.github.io/post-images/1599223045646.png" alt="" loading="lazy"></figure>
<h2 id="4-maven依赖管理原理">4、Maven依赖管理原理</h2>
<figure data-type="image" tabindex="2"><img src="https://Vinci-Ma.github.io/post-images/1599223063856.png" alt="" loading="lazy"></figure>
<h2 id="5-maven核心文件pomxml">5、Maven核心文件Pom.xml</h2>
<pre><code class="language-java">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0
http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;!-- 版本：4.0.0 --&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;!-- 组织名称：暂时使用 组织名称+项目名称 作为组织名称 --&gt;
    &lt;!-- 组织名称：实际名称 按照访问路径规范设置，通常以功能作为名称：
    eg: junit spring --&gt;
    &lt;groupId&gt;com.kkb.maven&lt;/groupId&gt;
    &lt;!-- 项目名称 --&gt;
    &lt;artifactId&gt;HelloWorld&lt;/artifactId&gt;
    &lt;!-- 当前项目版本号：同一个项目开发过程中可以发布多个版本，此处标示0.0.1版 --&gt;
    &lt;!-- 当前项目版本号：每个工程发布后可以发布多个版本，依赖时调取不同的版本，使用不同的版本号 --&gt;
    &lt;version&gt;0.0.1&lt;/version&gt;
    &lt;!-- 名称：可省略 --&gt;
    &lt;name&gt;Hello&lt;/name&gt;
    &lt;!-- 依赖关系 --&gt;
     &lt;dependencies&gt;
        &lt;!-- 依赖设置 --&gt;
        &lt;dependency&gt;
            &lt;!-- 依赖组织名称 --&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;!-- 依赖项目名称 --&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;!-- 依赖版本名称 --&gt;
            &lt;version&gt;4.12&lt;/version&gt;
            &lt;!-- 依赖范围：test包下依赖该设置 --&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<h2 id="6-搭建原生的maven项目">6、搭建原生的Maven项目</h2>
<h3 id="1-通过文件夹的方式创建java项目">1、通过文件夹的方式创建java项目</h3>
<p>在某个磁盘的根目录按照下面结构创建文件夹</p>
<p>projectName（项目名称）</p>
<ul>
<li>src
<ul>
<li>main
<ul>
<li>java【存放项目的.java文件】</li>
<li>resources【存放项目资源文件】</li>
</ul>
</li>
<li>test
<ul>
<li>java【存放所有测试.java文件，如JUnit测试类】</li>
</ul>
</li>
</ul>
</li>
<li>target【目标文件输出位置例如.class、.jar、.war文件（不需要创建，会自动生成）】</li>
<li>pom.xml【maven项目核心配置文件】</li>
</ul>
<h2 id="7-maven常用指令">7、Maven常用指令</h2>
<ul>
<li>
<p>mvn compile：完成编译操作，执行完毕后，会生成target目录，该目录中存放了编译后的字节码文件。</p>
</li>
<li>
<p>mvn clean：执行完毕后，会将target目录删除。</p>
</li>
<li>
<p>mvn test：执行 mvn test命令，完成单元测试操作。执行完毕后，会在target目录中生成三个文件夹：surefire、 surefire-reports（测试报告）、test-classes（测试的字节码文件）</p>
</li>
<li>
<p>maven package：完成打包操作，执行完毕后，会在target目录中生成一个文件，该文件可能是jar、war。</p>
</li>
<li>
<p>mvn install：完成将打好的jar包安装到本地仓库的操作， 执行完毕后，会在本地仓库中出现安装后的jar包，方便其他工程引用。</p>
</li>
<li>
<p>mvn clean compile：组合指令，先执行clean，再执行compile，通常应用于上线前执行，清除测试类。</p>
</li>
<li>
<p>mvn clean test：组合指令，先执行clean，再执行test，通常应用于测试环节。</p>
</li>
<li>
<p>mvn clean package：组合指令，先执行clean，再执行package，将项目打包，通常应用于发布前。</p>
<p>执行过程：<br>
清理————清空环境<br>
编译————编译源码<br>
测试————测试源码<br>
打包————将编译的非测试类打包</p>
</li>
<li>
<p>mvn clean install ：组合指令，先执行clean，再执行install，将项目打包，通常应用于发布前。<br>
执行过程：<br>
清理————清空环境<br>
编译————编译源码<br>
测试————测试源码<br>
打包————将编译的非测试类打包<br>
部署————将打好的包发布到资源仓库中</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[枚举、注解和反射]]></title>
        <id>https://Vinci-Ma.github.io/post/mei-ju-zhu-jie-he-fan-she/</id>
        <link href="https://Vinci-Ma.github.io/post/mei-ju-zhu-jie-he-fan-she/">
        </link>
        <updated>2020-09-02T17:00:02.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E6%9E%9A%E4%B8%BE">枚举</a>
<ul>
<li><a href="#1-%E7%AE%80%E4%BB%8B">1、简介</a></li>
<li><a href="#2-%E5%AE%9A%E4%B9%89%E6%A0%BC%E5%BC%8F">2、定义格式</a></li>
<li><a href="#3-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E7%9A%84%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95">3、枚举类的主要方法</a></li>
<li><a href="#4-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">4、注意事项</a></li>
</ul>
</li>
<li><a href="#%E6%B3%A8%E8%A7%A3">注解</a>
<ul>
<li><a href="#1-%E7%AE%80%E4%BB%8B-2">1、简介</a></li>
<li><a href="#2-%E5%86%85%E7%BD%AE%E6%B3%A8%E8%A7%A3">2、内置注解</a></li>
</ul>
</li>
<li><a href="#%E5%8F%8D%E5%B0%84">反射</a>
<ul>
<li><a href="#1-%E6%A6%82%E8%BF%B0">1、概述</a></li>
<li><a href="#2-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8">2、类加载器</a></li>
<li><a href="#3-%E6%89%80%E6%9C%89%E7%B1%BB%E5%9E%8B%E7%9A%84class%E5%AF%B9%E8%B1%A1">3、所有类型的Class对象</a></li>
<li><a href="#4-%E5%BE%97%E5%88%B0class%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F">4、得到Class的几种方式</a></li>
<li><a href="#5-%E8%8E%B7%E5%8F%96constructor">5、获取Constructor</a></li>
<li><a href="#%E8%8E%B7%E5%8F%96method">获取Method</a></li>
<li><a href="#1-%E9%80%9A%E8%BF%87class%E5%AF%B9%E8%B1%A1%E8%8E%B7%E5%8F%96%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95">1、通过class对象，获取一个类的方法</a></li>
<li><a href="#2-method%E6%89%A7%E8%A1%8C%E6%96%B9%E6%B3%95">2、Method执行方法</a></li>
<li><a href="#7-%E8%8E%B7%E5%8F%96field">7、获取Field</a>
<ul>
<li><a href="#1-%E9%80%9A%E8%BF%87class%E5%AF%B9%E8%B1%A1%E8%8E%B7%E5%8F%96%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E5%B1%9E%E6%80%A7">1、通过class对象，获取一个类的属性</a></li>
<li><a href="#2-field%E5%B1%9E%E6%80%A7%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B">2、Field属性的对象类型</a></li>
</ul>
</li>
<li><a href="#8-%E8%8E%B7%E5%8F%96%E6%B3%A8%E8%A7%A3%E4%BF%A1%E6%81%AF">8、获取注解信息</a>
<ul>
<li><a href="#1-%E8%8E%B7%E5%8F%96%E7%B1%BB%E5%B1%9E%E6%80%A7%E6%96%B9%E6%B3%95%E7%9A%84%E5%85%A8%E9%83%A8%E6%B3%A8%E8%A7%A3%E5%AF%B9%E8%B1%A1">1、获取类/属性/方法的全部注解对象</a></li>
<li><a href="#2-%E6%A0%B9%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%8E%B7%E5%8F%96%E7%B1%BB%E5%B1%9E%E6%80%A7%E6%96%B9%E6%B3%95%E7%9A%84%E6%B3%A8%E8%A7%A3%E5%AF%B9%E8%B1%A1">2、根据类型获取类/属性/方法的注解对象</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%86%85%E7%9C%81">内省</a>
<ul>
<li><a href="#1-%E7%AE%80%E4%BB%8B-3">1、简介</a></li>
<li><a href="#2-introspector">2、Introspector</a></li>
<li><a href="#3-beaninfo">3、BeanInfo</a></li>
<li><a href="#4-methoddescriptor">4、MethodDescriptor</a></li>
</ul>
</li>
</ul>
</p>
<h1 id="枚举">枚举</h1>
<h2 id="1-简介">1、简介</h2>
<p>JDK1.5引入了新的类型——枚举。在JDK1.5 之前，我们定义常量都是： public static fianl.... 。很难管理。<br>
<strong>枚举</strong>，可以把相关的常量分组到一个枚举类型里，而且枚举提供了比常量更多的方法。<br>
用于定义有限数量的一组同类常量，</p>
<h2 id="2-定义格式">2、定义格式</h2>
<pre><code class="language-java">权限修饰符 enum 枚举名称 {
	实例1,实例2，实例3，实例4;
}
public enum Level {
    LOW(30), MEDIUM(15), HIGH(7), URGENT(1);
    private int levelValue;
    private Level(int levelValue) {
    	this.levelValue = levelValue;
    }
    public int getLevelValue() {
    	return levelValue;
    }
}
</code></pre>
<h2 id="3-枚举类的主要方法">3、枚举类的主要方法</h2>
<figure data-type="image" tabindex="1"><img src="https://Vinci-Ma.github.io/post-images/1599066198769.png" alt="" loading="lazy"></figure>
<h2 id="4-注意事项">4、注意事项</h2>
<ul>
<li>一旦定义了枚举，最好不要妄图修改里面的值，除非修改是必要的。</li>
<li>枚举类默认继承的是java.lang.Enum类而不是Object类</li>
<li>枚举类不能有子类，因为其枚举类默认被final修饰</li>
<li>只能有private构造方法</li>
<li>switch中使用枚举时，直接使用常量名，不用携带类名</li>
<li>不能定义name属性，因为自带name属性</li>
<li>不要为枚举类中的属性提供set方法，不符合枚举最初设计初衷。</li>
</ul>
<h1 id="注解">注解</h1>
<p>学习步骤：1、概念</p>
<p>2、怎么使用内置注解</p>
<p>3、怎么自定义注解</p>
<p>4、反射中怎么获取注解内容</p>
<h2 id="1-简介-2">1、简介</h2>
<p>Java 注解（Annotation）又称 Java 标注，是 JDK5.0 引入的一种注释机制。</p>
<p>Java 语言中的类、方法、变量、参数和包等都可以被标注。和注释不同，Java 标注可以通过反射获取标注内容。在编译器生成类文件时，【标注可以被嵌入到字节码中】。Java 虚拟机可以保留标注内容，在运行时可以获取到标注内容 。 当然它也支持自定义 Java 标注。</p>
<p><strong>注解相当于给机器看的注释</strong></p>
<ul>
<li>主要用于：
<ul>
<li>编译格式检查</li>
<li>反射中解析</li>
<li>生成帮助文档</li>
<li>跟踪代码依赖</li>
</ul>
</li>
</ul>
<h2 id="2-内置注解">2、内置注解</h2>
<p>系统已经存在的注解</p>
<ul>
<li>@Override：重写*
<ul>
<li>定义在java.lang.Override</li>
</ul>
</li>
<li>@Deprecated：废弃 *
<ul>
<li>定义在java.lang.Deprecated</li>
</ul>
</li>
<li>@SafeVarargs
<ul>
<li>Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。</li>
</ul>
</li>
<li>@FunctionalInterface： 函数式接口 *
<ul>
<li>Java 8 开始支持，标识一个匿名函数或函数式接口。</li>
</ul>
</li>
<li>@Repeatable：标识某注解可以在同一个声明上使用多次
<ul>
<li>Java 8 开始支持，标识某注解可以在同一个声明上使用多次。</li>
</ul>
</li>
<li>SuppressWarnings：抑制编译时的警告信息。*
<ul>
<li>定义在java.lang.SuppressWarnings</li>
<li>三种使用方式
<ul>
<li>1、@SuppressWarnings(&quot;unchecked&quot;) 【抑制单类型的警告】</li>
<li>2、@SuppressWarnings(&quot;unchecked&quot;,&quot;rawtypes&quot;) 【 抑制多类型的警告】</li>
<li>3、@SuppressWarnings(&quot;all&quot;) 【抑制所有类型的警告】</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="反射">反射</h1>
<h2 id="1-概述">1、概述</h2>
<p>JAVA反射机制是在运行状态中，获取任意一个类的结构 , 创建对象 , 得到方法，执行方法 , 属性 !；这种在运行状态动态获取信息以及动态调用对象方法的功能被称为java语言的反射机制。</p>
<h2 id="2-类加载器">2、类加载器</h2>
<p>作用：Java类加载器（Java Classloader）是Java运行时环境（Java Runtime Environment）的一部分，负责动态加载Java类到Java虚拟机的内存空间中。</p>
<p>种类（3种）：</p>
<ul>
<li>BootstrapClassLoader（引导启动类加载器）：嵌在JVM内核中的加载器，该加载器是用C++语言写的，主要负载加载JAVA_HOME/lib下的类库，引<br>
导启动类加载器无法被应用程序直接使用。</li>
<li>ExtensionClassLoader（扩展类加载器）：ExtensionClassLoader是用JAVA编写，且它的父类加载器是Bootstrap。是由sun.misc.Launcher$ExtClassLoader实现的，主要加载JAVA_HOME/lib/ext目录中的类库。它的父加载器是BootstrapClassLoader</li>
<li>App ClassLoader（应用类加载器）：App ClassLoader是应用程序类加载器，负责加载应用程序classpath目录下的所有jar和class文件。它的父加载器为Ext ClassLoader</li>
</ul>
<h2 id="3-所有类型的class对象">3、所有类型的Class对象</h2>
<p>要想了解一个类,必须先要获取到该类的字节码文件对象.<br>
在Java中，每一个字节码文件，被加载到内存后，都存在一个对应的Class类型的对象</p>
<h2 id="4-得到class的几种方式">4、得到Class的几种方式</h2>
<pre><code class="language-java">1. 如果在编写代码时, 指导类的名称, 且类已经存在, 可以通过
    包名.类名.class 得到一个类的 类对象
2. 如果拥有类的对象, 可以通过
        Class 对象.getClass() 得到一个类的 类对象
3. 如果在编写代码时, 知道类的名称 , 可以通过
        Class.forName(包名+类名): 得到一个类的 类对象
上述的三种方式, 在调用时, 如果类在内存中不存在, 则会加载到内存 ! 如果类已经在内存中存在, 不会重复加载, 而是重复利用 !
(一个class文件 在内存中不会存在两个类对象 )
</code></pre>
<h2 id="5-获取constructor">5、获取Constructor</h2>
<ul>
<li>1、通过class对象，获取一个类的构造方法</li>
</ul>
<pre><code class="language-java">1. 通过指定的参数类型, 获取指定的单个构造方法
	getConstructor(参数类型的class对象数组)
    例如:
    构造方法如下: Person(String name,int age)
    得到这个构造方法的代码如下:
    Constructor c = p.getClass().getConstructor(String.class,int.class);
2. 获取构造方法数组
	getConstructors();
3. 获取所有权限的单个构造方法
	getDeclaredConstructor(参数类型的class对象数组)
4. 获取所有权限的构造方法数组
	getDeclaredConstructors();
</code></pre>
<ul>
<li>2、Construction创建对象</li>
</ul>
<pre><code class="language-java">常用方法:
	newInstance(Object... para)
		调用这个构造方法, 把对应的对象创建出来
		参数: 是一个Object类型可变参数, 传递的参数顺序 必须匹配构造方法中形式参数列表的顺序!
	setAccessible(boolean flag)
		如果flag为true 则表示忽略访问权限检查 !(可以访问任何权限的方法)
</code></pre>
<h2 id="获取method">获取Method</h2>
<h2 id="1-通过class对象获取一个类的方法">1、通过class对象，获取一个类的方法</h2>
<pre><code class="language-java">1. getMethod(String methodName , class.. clss)
	根据参数列表的类型和方法名, 得到一个方法(public修饰的)
2. getMethods();
	得到一个类的所有方法 (public修饰的)
3. getDeclaredMethod(String methodName , class.. clss)
	根据参数列表的类型和方法名, 得到一个方法(除继承以外所有的:包含私有, 共有, 保护, 默认)
4. getDeclaredMethods();
	得到一个类的所有方法 (除继承以外所有的:包含私有, 共有, 保护, 默认)
</code></pre>
<h2 id="2-method执行方法">2、Method执行方法</h2>
<pre><code class="language-java">invoke(Object o,Object... para) :
    调用方法 ,
    参数1. 要调用方法的对象
    参数2. 要传递的参数列表
getName()
	获取方法的方法名称
setAccessible(boolean flag)
	如果flag为true 则表示忽略访问权限检查 !(可以访问任何权限的方法)
</code></pre>
<h2 id="7-获取field">7、获取Field</h2>
<h3 id="1-通过class对象获取一个类的属性">1、通过class对象，获取一个类的属性</h3>
<pre><code class="language-java">1. getDeclaredField(String filedName)
	根据属性的名称, 获取一个属性对象 (所有属性)
2. getDeclaredFields()
	获取所有属性
3. getField(String filedName)
	根据属性的名称, 获取一个属性对象 (public属性)
4. getFields()
	获取所有属性 (public)
</code></pre>
<h3 id="2-field属性的对象类型">2、Field属性的对象类型</h3>
<pre><code class="language-java">常用方法:
1. get(Object o );
    参数: 要获取属性的对象
    获取指定对象的此属性值
2. set(Object o , Object value);
    参数1. 要设置属性值的 对象
    参数2. 要设置的值
    设置指定对象的属性的值
3. getName()
	获取属性的名称
4. setAccessible(boolean flag)
	如果flag为true 则表示忽略访问权限检查 !(可以访问任何权限的属性)
</code></pre>
<h2 id="8-获取注解信息">8、获取注解信息</h2>
<h3 id="1-获取类属性方法的全部注解对象">1、获取类/属性/方法的全部注解对象</h3>
<pre><code class="language-java">Annotation[] annotations01 = Class/Field/Method.getAnnotations();
for (Annotation annotation : annotations01) {
	System.out.println(annotation);
}
</code></pre>
<h3 id="2-根据类型获取类属性方法的注解对象">2、根据类型获取类/属性/方法的注解对象</h3>
<pre><code class="language-java">注解类型 对象名 = (注解类型) c.getAnnotation(注解类型.class);
</code></pre>
<h1 id="内省">内省</h1>
<h2 id="1-简介-3">1、简介</h2>
<p>基于反射 , java所提供的一套应用到JavaBean的API</p>
<p>一个定义在包中的类 ，拥有无参构造器所有属性私有，所有属性提供get/set方法，实现了序列化接口，这种类, 我们称其为 bean类 。</p>
<p>Java提供了一套java.beans包的api , 对于反射的操作, 进行了封装</p>
<h2 id="2-introspector">2、Introspector</h2>
<pre><code class="language-java">获取Bean类信息
方法:
    BeanInfo getBeanInfo(Class cls)
    通过传入的类信息, 得到这个Bean类的封装对象 .
</code></pre>
<h2 id="3-beaninfo">3、BeanInfo</h2>
<pre><code class="language-java">常用的方法:
    MethodDescriptor[] getPropertyDescriptors():
    获取bean类的 get/set方法 数组
</code></pre>
<h2 id="4-methoddescriptor">4、MethodDescriptor</h2>
<pre><code class="language-java">常用方法:
    1. Method getReadMethod();
    	获取一个get方法
    2. Method getWriteMethod();
    	获取一个set方法
    	有可能返回null 注意 ,加判断 !
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux常用指令]]></title>
        <id>https://Vinci-Ma.github.io/post/linux-chang-yong-zhi-ling/</id>
        <link href="https://Vinci-Ma.github.io/post/linux-chang-yong-zhi-ling/">
        </link>
        <updated>2020-09-01T08:11:44.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E6%9F%A5%E7%9C%8B%E7%9B%AE%E5%BD%95">查看目录</a></li>
<li><a href="#%E5%88%9B%E5%BB%BA%E7%9B%AE%E5%BD%95">创建目录</a></li>
<li><a href="#%E5%88%87%E6%8D%A2%E7%9B%AE%E5%BD%95">切换目录</a></li>
<li><a href="#%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6">创建文件</a></li>
<li><a href="#%E5%86%99%E5%85%A5%E5%86%85%E5%AE%B9">写入内容</a></li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9">查看文件内容</a></li>
<li><a href="#%E5%A4%8D%E5%88%B6">复制</a></li>
<li><a href="#%E5%89%AA%E5%88%87">剪切</a></li>
<li><a href="#%E5%88%A0%E9%99%A4">删除</a></li>
<li><a href="#%E7%BB%9F%E8%AE%A1%E8%A1%8C">统计行</a></li>
<li><a href="#%E5%BD%93%E5%89%8D%E8%B7%AF%E5%BE%84">当前路径</a></li>
<li><a href="#%E6%98%BE%E7%A4%BA%E4%B8%BB%E6%9C%BA">显示主机</a></li>
<li><a href="#%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF">系统信息</a></li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E8%80%97%E6%97%B6%E4%B8%8E%E5%8D%A0%E7%94%A8">查看进程耗时与占用</a></li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E5%BF%AB%E7%85%A7">查看进程快照</a></li>
<li><a href="#%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F">文件大小</a></li>
<li><a href="#%E7%A3%81%E7%9B%98%E5%8D%A0%E7%94%A8">磁盘占用</a></li>
<li><a href="#%E7%BD%91%E5%8D%A1">网卡</a></li>
<li><a href="#%E5%BC%BA%E5%88%B6%E7%BB%93%E6%9D%9F">强制结束</a></li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E7%AB%AF%E5%8F%A3">查看端口</a></li>
<li><a href="#%E6%89%93%E5%8C%85%E4%B8%8E%E6%8A%98%E5%8C%85%E5%8E%8B%E7%BC%A9%E4%B8%8E%E8%A7%A3%E5%8E%8B%E7%BC%A9">打包与折包（压缩与解压缩）</a></li>
<li><a href="#%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8">文本编辑器</a></li>
</ul>
</p>
<h1 id="查看目录">查看目录</h1>
<p>ll：查看详细信息<br>
ls：查看目录内容</p>
<h1 id="创建目录">创建目录</h1>
<p>mkdir：创建目录<br>
mkdir -p：创建目录以及其子目录，同时创建多个目录【eg：mkdir -p a/b（创建a目录里面包含b目录）】</p>
<h1 id="切换目录">切换目录</h1>
<p>cd （需要切换的目录）：切换目录</p>
<h1 id="创建文件">创建文件</h1>
<p>touch：创建文件【eg：touch a.txt（在当前目录下创建a.txt）】</p>
<h1 id="写入内容">写入内容</h1>
<p>echo：把内容重定向到指定的文件夹中，有则打开，无则创建<br>
覆盖模式&gt;: echo “ww”&gt;aa.txt【清除aa.txt的内容，再写入ww】<br>
追加模式&gt;&gt;: echo &quot;ww&quot;&gt;&gt;aa.txt【在aa.txt末尾添加ww】</p>
<h1 id="查看文件内容">查看文件内容</h1>
<p>cat：查看文件内容<br>
more：分页查看文件内容，按空格键换页</p>
<h1 id="复制">复制</h1>
<p>cp：复制文件【eg：cp a.txt b.txt（复制a的内容到b）】</p>
<h1 id="剪切">剪切</h1>
<p>mv：剪切、重命名（剪切的文件 放在同一个目录中是重命名）【eg：mv b.txt c.txt（将b的名字改为c）】</p>
<h1 id="删除">删除</h1>
<p>rm：删除文件或者文件夹（有提示） -r 递归删除<br>
rm -fr：直接彻底删除，没有提示</p>
<h1 id="统计行">统计行</h1>
<p>wc -l：统计行数</p>
<h1 id="当前路径">当前路径</h1>
<p>pwd：查看当前目录的绝对路径</p>
<h1 id="显示主机">显示主机</h1>
<p>hostname：显示主机名</p>
<h1 id="系统信息">系统信息</h1>
<p>uname -a：显示完整的系统信息</p>
<h1 id="查看进程耗时与占用">查看进程耗时与占用</h1>
<p>top：显示当前耗时的进程信息 ,每3秒刷新一次 cltr+c 中断</p>
<h1 id="查看进程快照">查看进程快照</h1>
<p>ps -aux：显示当前进程的快照（全部显示）<br>
ps -aux |qrep java：查看java进程<br>
ps -aux |qrep mysql：查看mysql进程</p>
<h1 id="文件大小">文件大小</h1>
<p>du -sh：显示文件的大小信息</p>
<h1 id="磁盘占用">磁盘占用</h1>
<p>df -lh：磁盘使用情况</p>
<h1 id="网卡">网卡</h1>
<p>ifconfig：查看或者配置网卡信息</p>
<h1 id="强制结束">强制结束</h1>
<p>kill pid：杀死进程<br>
kill -9 （编号）：强制杀死</p>
<h1 id="查看端口">查看端口</h1>
<p>netstat （参数）<br>
-a或--all：显示所有连线中的Socket；<br>
-l或--listening：显示监控中的服务器的Socket；<br>
-n或--numeric：直接使用ip地址，而不通过域名服务器；<br>
-p或--programs：显示正在使用Socket的程序识别码和程序名称；<br>
-t或--tcp：显示TCP传输协议的连线状况；<br>
netstat -tlnp：找出运行在指定端口的进程：【eg：netstat -tlnp | grep ':22'】</p>
<h1 id="打包与折包压缩与解压缩">打包与折包（压缩与解压缩）</h1>
<p>tar -czvf （打包后的文件）（需要打包的目录）<br>
c ：创建的一个归档文件<br>
x ：拆包<br>
z ：以gzip 格式压缩 j ：以bzip2格式压缩<br>
v ：显示打包或者拆包的文件信息<br>
f ： 后面紧接一个 归档文件<br>
打包及压缩：tar -czvf yhp.tar.gz ./yhp/<br>
拆包及解压缩: tar -xzvf yhp.tar.gz</p>
<h1 id="文本编辑器">文本编辑器</h1>
<p>vim （需要编辑的文本）<br>
i：进入编辑模式<br>
esc：退出编辑模式<br>
命令模式：<br>
一般模式中按：进入命令模式【yy复制一行, dd剪切一行,p粘贴】<br>
:q 安全退出，当没有操作该文档<br>
:q！修改了内容，但不想保存，强制退出<br>
:wq 保存退出<br>
:set number 显示行号set nonumber 取消行号显示</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JSP学习]]></title>
        <id>https://Vinci-Ma.github.io/post/jsp-xue-xi/</id>
        <link href="https://Vinci-Ma.github.io/post/jsp-xue-xi/">
        </link>
        <updated>2020-08-14T14:56:20.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#jsp">JSP</a></li>
<li><a href="#jsp%E5%87%BA%E7%8E%B0%E5%8E%9F%E5%9B%A0">JSP出现原因</a></li>
<li><a href="#jsp%E4%B8%AD%E5%A6%82%E4%BD%95%E5%B5%8C%E5%A5%97java%E4%BB%A3%E7%A0%81">JSP中如何嵌套Java代码</a></li>
<li><a href="#jsp%E5%8E%9F%E7%90%86">JSP原理</a></li>
<li><a href="#jsp%E7%9A%849%E4%B8%AA%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E9%87%8D%E7%82%B9">JSP的9个内置对象【重点】</a>
<ul>
<li><a href="#1-request%E5%AF%B9%E8%B1%A1">1、request对象！</a></li>
<li><a href="#2-response%E5%AF%B9%E8%B1%A1">2、response对象！</a></li>
<li><a href="#3-session%E5%AF%B9%E8%B1%A1">3、session对象！</a></li>
<li><a href="#4-application%E5%AF%B9%E8%B1%A1">4、application对象！</a></li>
<li><a href="#5-out-%E5%AF%B9%E8%B1%A1">5、out 对象</a></li>
<li><a href="#6-pagecontext-%E5%AF%B9%E8%B1%A1">6、pageContext 对象</a></li>
<li><a href="#7-config-%E5%AF%B9%E8%B1%A1">7、config 对象</a></li>
<li><a href="#8-page-%E5%AF%B9%E8%B1%A1">8、page 对象</a></li>
<li><a href="#9-exception-%E5%AF%B9%E8%B1%A1">9、exception 对象</a></li>
</ul>
</li>
<li><a href="#jsp%E7%9A%84%E4%B8%89%E5%A4%A7%E6%8C%87%E4%BB%A4">JSP的三大指令</a>
<ul>
<li><a href="#page-%E6%8C%87%E4%BB%A4">Page 指令</a></li>
<li><a href="#include%E6%8C%87%E4%BB%A4">include指令</a></li>
<li><a href="#taglib%E6%8C%87%E4%BB%A4">Taglib指令</a></li>
</ul>
</li>
<li><a href="#jsp%E5%87%BA%E7%8E%B0%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81">JSP出现的状态码</a></li>
<li><a href="#el%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%B8%B8%E7%94%A8">EL表达式【常用】</a></li>
<li><a href="#jstl">JSTL</a>
<ul>
<li><a href="#%E7%AE%80%E4%BB%8B">简介：</a></li>
<li><a href="#jatl%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F">JATL的作用和语法格式</a></li>
<li><a href="#%E6%A0%B8%E5%BF%83%E6%A0%87%E7%AD%BE">核心标签</a></li>
<li><a href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%A0%87%E7%AD%BE">格式化标签</a></li>
</ul>
</li>
</ul>
</p>
<h1 id="jsp">JSP</h1>
<p>JSP全名为Java Server Pages，中文名叫java服务器页面，其根本是一个简化的Servlet设计，它 是由Sun Microsystems公司倡导、许多公司参与一起建立的一种动态网页技术标准。JSP技术有点类似ASP技术，它是在传统的网页HTML文件(<em>.htm,</em>.html)中插入Java程序段(Scriptlet)和JSP标记(tag)，从而形成JSP文件，后缀名为(*.jsp)。 用JSP开发的Web应用是跨平台的，既能在Linux下运行，也能在其他操作系统上运行。</p>
<p>JSP将网页逻辑与网页设计的显示分离，支持可重用的基于组件的设计，使基于Web的应用程序的开发变得迅速和容易。</p>
<p>*.html 静态页面(包含固定的页面内容)</p>
<p>*.jsp 动态页面(页面数据可以动态更新,支持嵌套java代码和html代码)</p>
<h1 id="jsp出现原因">JSP出现原因</h1>
<ol>
<li>servlet显示信息不方便，引入了JSP</li>
<li>JSP本质上也是一个servlet</li>
<li>JSP就是在HTML页面中嵌套了java代码</li>
</ol>
<h1 id="jsp中如何嵌套java代码">JSP中如何嵌套Java代码</h1>
<pre><code class="language-java">声明标签 &lt;%!变量或者方法声明%&gt;
表达式标签 &lt;%= 表达式%&gt; 在页面上显示的效果
程序代码标签 &lt;%java代码%&gt; 页面上动态展示内容

page指令:(用于设置当前代码中的一些编码方式、语言、导的包……)
	&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot;pageEncoding=&quot;UTF-8&quot;%&gt;
    
&lt;body&gt;
&lt;%! int i=10;%&gt;&lt;!--成员变量--&gt;
&lt;%! public void show(){}%&gt; &lt;!--成员方法--&gt;
&lt;%=i%&gt; &lt;!--输出变量值--&gt;
&lt;/body&gt;
 
注释：
    &lt;!-- html注释内容,查看源码时能看到 --&gt;
    &lt;%-- jsp注释,查看页面源码时看不到 --%&gt;
</code></pre>
<h1 id="jsp原理">JSP原理</h1>
<p>当浏览器访问http://localhost:8080/day9_1/index.jsp。服务器发现后缀为.jsp，它会根据路径找到index.jsp文件，会将index.jsp翻译成index_jsp.java文件，对这个java文件进行编译，产生一个index_jsp.class文件，将class文件加载运行。</p>
<p>将JSP翻译成java文件，它是将JSP中的所有的HTML代码通过流进行输出，也就是说最终翻译成class，被虚拟机加载，它本质是servlet，它就会往回响应，响应回去就是把JSP中的HTML代码以流的方式写回浏览器。所以在JSP中展示出了HTML代码。</p>
<h1 id="jsp的9个内置对象重点">JSP的9个内置对象【重点】</h1>
<p>JSP中一共预先定义了9个这样的对象，分别为：request、response、session、application、out、pagecontext、config、page、exception</p>
<h2 id="1-request对象">1、request对象！</h2>
<p>request 对象是 javax.servlet.httpServletRequest类型的对象。 该对象代表了<strong>客户端的请求信息</strong>，主要用于接受通过HTTP协议传送到服务器的数据。（包括头信息、系统信息、请求方式以及请求参数等）。<strong>request对象的作用域为一次请求。</strong></p>
<h2 id="2-response对象">2、response对象！</h2>
<p>response 代表的是<strong>对客户端的响应</strong>，主要是将JSP容器处理过的对象传回到客户端。response对象也具有作用域，它只在JSP页面内有效。所属类型: HttpServletResponse。</p>
<h2 id="3-session对象">3、session对象！</h2>
<p>session 对象是由服务器自动创建的与用户请求相关的对象。服务器为每个用户都生成一个session对象，用于保存该用户的信息，跟踪用户的操作状态。session对象内部使用Map类来保存数据，因此保存数据的格式为“Key/value”。 session对象的value可以使复杂的对象类型，而不仅仅局限于字符串类型。<strong>作用域为会话期间</strong>，所属类型: HttpSession。</p>
<h2 id="4-application对象">4、application对象！</h2>
<p><strong>application 对象可将信息保存在服务器中，直到服务器关闭，否则application对象中保存的信息会在整个应用中都有效</strong>。<br>
与session对象相比，application对象生命周期更长，类似于系统的“全局变量” ServletContext。<br>
<strong><mark>区别：</mark></strong><br>
request:单次请求<br>
session:浏览器访问期间(会话期间)<br>
application:服务器启动期间,所存的数据可以跨浏览器</p>
<h2 id="5-out-对象">5、out 对象</h2>
<p><strong>out 对象用于在Web浏览器内输出信息</strong>，并且管理应用服务器上的输出缓冲区。在使用 out 对象输出数据时，可以对数据缓冲区进行操作，及时清除缓冲区中的残余数据，为其他的输出让出缓冲空间。待数据输出完毕后，要及时关闭输出流。</p>
<pre><code class="language-java">//可以用于弹出弹窗
out.print(&quot;&lt;script type='text/javascript'&gt;alert('用户名不存在');location.href='index.jsp'&lt;/script&gt;&quot;);
</code></pre>
<h2 id="6-pagecontext-对象">6、pageContext 对象</h2>
<p><strong>pageContext 对象的作用是取得任何范围的参数</strong>，通过它可以获取 JSP页面的out、request、reponse、session、application 等对象。pageContext对象的创建和初始化都是由容器来完成的，在JSP页面中可以直接使用pageContext对象。</p>
<h2 id="7-config-对象">7、config 对象</h2>
<p>config 对象的主要作用是<strong>取得服务器的配置信息</strong>。通过 pageConext对象的 getServletConfig() 方法可以获取一个config对象。当一个Servlet 初始化时，容器把某些信息通过config对象传递给这个 Servlet。 开发者可以在web.xml 文件中为应用程序环境中的Servlet程序和JSP页面提供初始化参数。</p>
<pre><code class="language-java">//将image路径转换成服务器端的路径
String url= config.getServletContext().getRealPath(&quot;/image&quot;);
&lt;h1&gt;url=&lt;%=url %&gt;&lt;/h1&gt;
</code></pre>
<h2 id="8-page-对象">8、page 对象</h2>
<p>page 对象代表JSP本身，只有在JSP页面内才是合法的。 page隐含对象本质上包含当前 Servlet接口引用的变量，<strong>类似于Java编程中的 this 指针</strong>。</p>
<h2 id="9-exception-对象">9、exception 对象</h2>
<p>exception 对象的作用是<strong>显示异常信息</strong>，只有在包含 isErrorPage=&quot;true&quot; 的页面中才可以被使用，在一般的JSP页面中使用该对象将无法编译JSP文件。excepation对象和Java的所有对象一样，都具有系统提供的继承结构。<br>
exception 对象几乎定义了所有异常情况。在Java程序中，可以使用try/catch关键字来处理异常情况； 如果在JSP页面中出现没有捕获到的异常，就会生成exception 对象，并把 exception 对象传送到在page指令中设定的错误页面中，然后在错误页面中处理相应的 exception 对象。</p>
<p>(1)先在可能发生错误的页面中添加errorPage属性:</p>
<pre><code class="language-java">&lt;%@ page pageEncoding=&quot;utf-8&quot;
errorPage=&quot;error.jsp&quot;
contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
</code></pre>
<p>(2) 在error.jsp页面中设置isErrorPage=&quot;true&quot; 的属性<br>
(使用exception对象之前，需要先将当前页面设置成错误页面）</p>
<pre><code class="language-java">&lt;%@ page language=&quot;java&quot; isErrorPage=&quot;true&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt;
</code></pre>
<p>jsp存值的作用域:<br>
pageContext   -&gt;  request     -&gt; session       -&gt; application<br>
当前页面       单次请求有效  当前会话期间     服务器运行期间有效</p>
<h1 id="jsp的三大指令">JSP的三大指令</h1>
<p>JSP指令用来设置整个JSP页面相关的属性，如网页的编码方式和脚本语言。</p>
<pre><code class="language-java">语法格式如下：
    &lt;%@ directive attribute=&quot;value&quot; %&gt;
	directive：指令名称 attribute 属性名 value:属性值
</code></pre>
<table>
<thead>
<tr>
<th>指令名称</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>page</td>
<td style="text-align:left">定义网路依赖性，比如脚本语言、error页面、缓存需求等</td>
</tr>
<tr>
<td>include</td>
<td style="text-align:left">包含其他文件</td>
</tr>
<tr>
<td>include</td>
<td style="text-align:left">引入标签库的定义</td>
</tr>
</tbody>
</table>
<h2 id="page-指令">Page 指令</h2>
<pre><code class="language-java">Page指令为容器提供当前页面的使用说明
一个JSP页面可以包含多个page指令
Page指令的语法格式：
	&lt;%@ page attribute=&quot;value&quot; %&gt;
</code></pre>
<table>
<thead>
<tr>
<th>属性名</th>
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>language</td>
<td>java</td>
<td>解释该JSP文件时采用的语言，一般为java语言，默认为java</td>
</tr>
<tr>
<td>extends</td>
<td>任何类的全名</td>
<td>编译该JSP文件时继承哪个类，JSP为Servlet，因此当指明继承普通类时需要实现Servlet的init、destroy等方法</td>
</tr>
<tr>
<td>import</td>
<td>任何包名、类名</td>
<td>引入该JSP中用到的类、包等，import是唯一可以声明多次的page指令属性，一个import可以引用uogelei，中间用英文逗号隔开&lt;%@ page import=包名.类名，包名.类名%&gt;</td>
</tr>
<tr>
<td>session</td>
<td>true、false</td>
<td>该JSP内是否内置Session对象，如果为true，则内置Session对象，可直接使用，否则反之，默认为true</td>
</tr>
<tr>
<td>autoFlush</td>
<td>true、false</td>
<td>是否运行缓存，如果为true，则使用out.println()等方法输出的字符串并不是立刻到达客户端服务器的，而是暂时存到缓存里，缓存满了或者程序行完毕或者执行out.flush()操作时才到客户端，默认为true。</td>
</tr>
<tr>
<td>buffer</td>
<td>none或者数字KB</td>
<td>指定缓存大小，当autoFlush设为true时有效，例如&lt;%@ page buffer=10kb%&gt;</td>
</tr>
<tr>
<td>isThreadSafe</td>
<td>true、false</td>
<td>是否线程安全，如果为true，则运行多个线程同时运行该jsp程序，否则只运行一个线程，其余线程等待，默认为false</td>
</tr>
<tr>
<td>isErrorPage</td>
<td>true、false</td>
<td>指定该页面是否为错误显示页面，如果为true，则该JSP内置有一个Exception对象exception，可直接使用，否则没有，默认为false</td>
</tr>
<tr>
<td>errorPage</td>
<td>某个JSP页面的相对路径</td>
<td>指明一个错误页面，如果该JSP程序抛出一个未捕捉的异常，则转到errorPage指定的页面，errorPage指定的页面通</td>
</tr>
<tr>
<td>contentType</td>
<td>有效的文档类型</td>
<td>客户端浏览器根据该属性判断文档类型，例如 HTML格式为text/html、纯文本格式为text/plain、JPG图像为image/jpeg、GIF图像为image/gifWORD文档为application/msword，该属性常跟着charset设置编码一起，作用是通知服务器和浏览器都使用同一个码表</td>
</tr>
<tr>
<td>contentType</td>
<td>UTF-8,ISO-8859-</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="include指令">include指令</h2>
<p>JSP可以通过include指令来包含其他文件。被包含的文件可以是JSP文件、HTML文件或文本文件。包含的文件就好像是该JSP文件的一部分，会被同时编译执行。</p>
<pre><code class="language-java">Include指令的语法格式如下：
   &lt;%@ include file=&quot;文件相对 url 地址&quot; %&gt; 
</code></pre>
<p>include 指令中的文件名实际上是一个相对的 URL 地址。<br>
如果您没有给文件关联一个路径，JSP编译器默认在当前路径下寻找。</p>
<h2 id="taglib指令">Taglib指令</h2>
<p>JSP API允许<strong>用户自定义标签</strong>，一个自定义标签库就是自定义标签的集合。<br>
Taglib指令引入一个自定义标签集合的定义，包括库路径、自定义标签。</p>
<pre><code class="language-java">&lt;%@ taglib uri=&quot;uri&quot; prefix=&quot;&quot; %&gt;
uri属性确定标签库的位置，prefix属性指定标签库的前缀(可自定义)
</code></pre>
<h1 id="jsp出现的状态码">JSP出现的状态码</h1>
<figure data-type="image" tabindex="1"><img src="https://Vinci-Ma.github.io/post-images/1597417114112.png" alt="" loading="lazy"></figure>
<h1 id="el表达式常用">EL表达式【常用】</h1>
<p>EL表达式定义：Expression Language，表示语言，只负责取值</p>
<p>EL表达式语法：</p>
<ul>
<li>语法格式：<strong>${需要展示信息的名字}</strong></li>
<li>语法（想要跳过默认顺序获取时）: <strong>${requestScope.key}</strong></li>
</ul>
<p><strong><mark>注意：</mark></strong></p>
<p>当表达式没有指定变量或者对象的范围时，</p>
<p>那么容器会依次从pageContext—&gt;request—&gt;session—&gt;application中查找该变量或对象,我们可以通过隐含对象获得指定作用域的值:</p>
<p>pageScope对象，用于获取当前页面的属性值<br>
requestScope对象，用于获取请求范围的属性值<br>
sessionScope对象，用于获取会话范围的属性值<br>
applicationScope对象，用于获取程序范围的属性值</p>
<p><strong>EL中基础操作符：</strong><br>
<img src="https://Vinci-Ma.github.io/post-images/1597417100590.png" alt="" loading="lazy"></p>
<h1 id="jstl">JSTL</h1>
<h2 id="简介">简介：</h2>
<p>JSP标准标签库（JSTL）是一个JSP标签集合，它封装了JSP应用的通用核心功能。</p>
<p>JSTL支持通用的、结构化的任务，比如迭代，条件判断，XML文档操作，国际化标签，SQL标签。 除了这些，它还提供了一个框架来使用集成JSTL的自定义标签。</p>
<p>根据JSTL标签所提供的功能，可以将其分为5个类别。核心标签 格式化标签 sql标签 xml标签 jstl函数。</p>
<h2 id="jatl的作用和语法格式">JATL的作用和语法格式</h2>
<p><strong>作用：简化jsp页面编写代码</strong></p>
<p>语法格式：1、配置standard.jar 和 jstl.jar 到 /WEB-INF/lib/ 下</p>
<p>2、在JSP页面中引入&lt;%@ taglib prefix=”页面使用的名称” uri=”功能范围的路径”%&gt;</p>
<table>
<thead>
<tr>
<th>功能范围</th>
<th>url</th>
<th>前缀</th>
</tr>
</thead>
<tbody>
<tr>
<td>core</td>
<td>http://java.sun.com/jsp/jstl/core</td>
<td>c</td>
</tr>
<tr>
<td>i18n</td>
<td>http://java.sun.com/jsp/jstl/fmt</td>
<td>fmt</td>
</tr>
<tr>
<td>sql</td>
<td>http://java.sun.com/jsp/jstl/sql</td>
<td>sql</td>
</tr>
<tr>
<td>xml</td>
<td>http://java.sun.com/jsp/jstl/xml</td>
<td>x</td>
</tr>
<tr>
<td>functions</td>
<td>http://java.sun.com/jsp/jstl/function</td>
<td>fn</td>
</tr>
</tbody>
</table>
<h2 id="核心标签">核心标签</h2>
<p>核心标签是最常用的 JSTL标签。引用核心标签库的语法如下：</p>
<pre><code class="language-java">&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;
</code></pre>
<p>核心标签的分类：</p>
<p>表达式操作 ：out、set、remove、catch</p>
<p>流程控制 ：if、choose、when、otherwise</p>
<p>迭代操作： forEach、forTokens</p>
<p>URL操作： import、param、url、redirect</p>
<p><strong>Set标签</strong><br>
<img src="https://Vinci-Ma.github.io/post-images/1597417065005.png" alt="" loading="lazy"><br>
<img src="https://Vinci-Ma.github.io/post-images/1597417073508.png" alt="" loading="lazy"></p>
<h2 id="格式化标签">格式化标签</h2>
<p><strong>1、fmt:formatDate 作用：将日期类型格式化为指定模式的字符串</strong></p>
<p>属性</p>
<p>value：将要被格式化的数据</p>
<p>pattern：格式化的模式，与SimpleDateFormat的参数设置一样</p>
<p>var：格式化后的字符串所要存放的变量，若不指定var，则会将格式化的结果直接显示在页面</p>
<p>scope：变量存放的域属性空间，默认page</p>
<p>type：其取值为date、time、both，表示给出的value是日期、时间、还是两者都包含，默认是date</p>
<p><strong>2、fmt:parseDate 作用：用于将指定字符串转化为日期类型</strong></p>
<p>&lt;fmt:parseDate value=&quot;$(now)&quot; pattern=&quot;yyyy-MM-dd&quot; var=&quot;today&quot;/&gt;</p>
<p>Value：服务器获取的时间</p>
<p>Pattern：转换的格式</p>
<p>Var：页面显示的变量</p>
<p><strong>3、fmt:formatNumber 按照指定格式对数字进行格式化</strong></p>
<p>属性</p>
<p>maxIntegerDigits：整数部分最多的位数</p>
<p>minIntegerDigits：整数部分最少的位数</p>
<p>maxFrctionDigits：小数部分最多的位数</p>
<p>minFrctionDigits：小数部分最少的位数</p>
<p>var：存储格式化结果的变量</p>
<p>scope：var属性的作用域</p>
<p>integerOnly：是否只解析整型数true或者浮点数false</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Servlet学习]]></title>
        <id>https://Vinci-Ma.github.io/post/servlet-xue-xi/</id>
        <link href="https://Vinci-Ma.github.io/post/servlet-xue-xi/">
        </link>
        <updated>2020-08-14T14:54:35.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#servlet%E4%BB%8B%E7%BB%8D">Servlet介绍</a></li>
<li><a href="#servlet-api">Servlet API</a></li>
<li><a href="#servlet%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">Servlet工作原理</a></li>
<li><a href="#servlet%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">Servlet的生命周期</a></li>
<li><a href="#%E8%AF%B7%E6%B1%82">请求</a>
<ul>
<li><a href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95">常用方法</a></li>
</ul>
</li>
<li><a href="#%E5%93%8D%E5%BA%94">响应</a></li>
<li><a href="#%E4%BC%9A%E8%AF%9D">会话</a></li>
<li><a href="#%E8%8E%B7%E5%BE%97%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%82%E6%95%B0">获得初始化参数</a></li>
<li><a href="#servlet30">servlet3.0</a></li>
</ul>
</p>
<h1 id="servlet介绍">Servlet介绍</h1>
<ul>
<li>
<p>1、Servlet（Server Applet），全称Java Servlet。==是用Java编写的服务器端程序，其主要功能在于交互式地浏览和修改数据，生成动态Web内容。==狭义的Servlet是指Java语言实现的一个接口，广义的Servlet是指任何实现了这个Servlet接口的类，一般情况下，人们将Servlet理解为后者。</p>
</li>
<li>
<p>2、 Servlet运行于支持Java的应用服务器中。从实现上讲，Servlet可以响应任何类型的请求，但绝大多数情况下Servlet只用来<mark>扩展基于HTTP协议的Web服务器</mark>。</p>
</li>
<li>
<p>3、Servlet工作模式：</p>
<ul>
<li>客户端发送请求至服务器。</li>
<li>服务器启动大概并调用Servlet，Servlet根据客户端请求生成响应内容并将其传给服务器。</li>
<li>服务器将响应并返回客户端。</li>
</ul>
</li>
</ul>
<h1 id="servlet-api">Servlet API</h1>
<ul>
<li>javax.serv letinterface Servlet
<ul>
<li>1.init()</li>
<li>2.service()</li>
<li>3.destroy()</li>
<li>4.getServletConfig()</li>
<li>5.getServletInfo()</li>
</ul>
</li>
<li>javax.servlet abstract GenericServlet（除了实现或继承Servlet接口中的五个方法外还提供了额外方法）
<ul>
<li>1.getInitParameter()</li>
<li>2.getServletName()</li>
<li>3.getServletContext()</li>
</ul>
</li>
<li>javax.servlet.http abstract HttpServlet（重载service()方法）
<ul>
<li>1.doGet()</li>
<li>2.doPost()</li>
</ul>
</li>
</ul>
<h1 id="servlet工作原理">Servlet工作原理</h1>
<p>(1) Servlet接口定义了Servlet与servlet容器之间的契约。这个契约是：Servlet容器将Servlet类载入内存，并产生<br>
Servlet实例和调用它具体的方法。但是要注意的是，在一个应用程序中，每种Servlet类型只能有一个实例。<br>
(2)用户请求致使Servlet容器调用Servlet的Service（）方法，并传入一个ServletRequest对象和一个<br>
ServletResponse对象。ServletRequest对象和ServletResponse对象都是由Servlet容器（例如TomCat）封<br>
装好的，并不需要程序员去实现，程序员可以直接使用这两个对象。<br>
(3)ServletRequest中封装了当前的Http请求，因此，开发人员不必解析和操作原始的Http数据。ServletResponse<br>
表示当前用户的Http响应，程序员只需直接操作ServletResponse对象就能把响应轻松的发回给用户。<br>
(4)对于每一个应用程序，Servlet容器还会创建一个ServletContext对象。这个对象中封装了上下文（应用程序）<br>
的环境详情。每个应用程序只有一个ServletContext。每个Servlet对象也都有一个封装Servlet配置的<br>
ServletConfig对象。</p>
<h1 id="servlet的生命周期">Servlet的生命周期</h1>
<p>当客户端首次发送第一次请求后，由容器(web服务器(tomcat))去解析请求, 根据请求找到对应的servlet,判断该类的对象是否存在，不存在则创建servlet实例，调取init()方法 进行初始化操作,初始化完成后调取service()方法,由service()判断客户端的请求方式，如果是get，则执行doGet(),如果是post则执行doPost().处理方法完成后,作出相应结果给客户端.单次请求处理完毕。<br>
当用户发送第二次以后的请求时,会判断对象是否存在,但是不再执行init()，而直接执行service方法,调取doGet()/doPost()方法。<br>
当服务器关闭时调取destroy()方法进行销毁。<br>
四个过程:<br>
(1)实例化 --先创建servlet实例<br>
(2)初始化 --init()<br>
(3)处理请求 ---service()<br>
(4)服务终止 --destory()</p>
<h1 id="请求">请求</h1>
<p>HttpServletRequest表示Http环境中的Servlet请求。它扩展于javax.servlet.ServletRequest接口)</p>
<h2 id="常用方法">常用方法</h2>
<ul>
<li>1、String getParameter(String name) 根据表单组件名称获取提交数据，返回值是String<br>
注：服务器在接收数据时使用字符串统一接收</li>
<li>2、String[ ] getParameterValues(String name) 获取表单组件对应多个值时的请求数据</li>
<li>3、void setCharacterEncoding(String charset) 指定每个请求的编码(针对post请求才起作用)</li>
<li>4、RequestDispatcher getRequestDispatcher(String path) --跳转页面</li>
</ul>
<p>返回一个RequestDispatcher对象，该对象的forward( )方法用于转发请求</p>
<pre><code class="language-java">示例：request.getRequestDispatcher(&quot;../success.jsp&quot;).forward(request,response);
</code></pre>
<ul>
<li>5、存值 request.setAttribute(&quot;key&quot;,value);</li>
<li>6、取值 request.getAttribute(&quot;key&quot;);//取值后需要向下转型</li>
</ul>
<h1 id="响应">响应</h1>
<p>在Service API中，定义了一个HttpServletResponse接口，它继承自ServletResponse接口，专门用来封装HTTP响应消息。 在HttpServletResponse接口中定义了向客户端发送响应状态码，响应消息头，响应消息体的方法。</p>
<p><strong>常用方法：</strong></p>
<p>void addCookie(Cookie var1)：给这个响应添加一个cookie</p>
<p>void sendRedirect(String var1) ：发送一条响应码，将浏览器跳转到指定的位置</p>
<p>PrintWriter getWriter() ：获得字符流，通过字符流的write(String s)方法可以将字符串设置到response 缓冲区中，随后Tomcat会将response缓冲区中的内容组装成Http响应返回给浏览器端。</p>
<p>setContentType() ：设置响应内容的类型。</p>
<p><strong>重定向和转发的对比：</strong></p>
<p>重定向:response.sendRedirect()</p>
<p>转发:request.getRequestDispatcher(&quot;../success.jsp&quot;).forward(request,response);</p>
<p>相同点:都用来跳转页面。</p>
<p>不同点:</p>
<ul>
<li>重定向时地址栏会改变,request中存储的数据会丢失.转发时地址栏显示的是请求页面的地址,request数据可以保存。</li>
<li>转发属于一次请求一次响应,重定向属于两次请求(地址栏修改了两次)两次响应。</li>
</ul>
<p>补充:使用out对象往页面中输出js或html,css</p>
<pre><code class="language-java">out.print(&quot;&lt;script type='text/javascript'&gt;alert('登录失败');location='../login.jsp'&lt;/script&gt;&quot;);
</code></pre>
<p>注:使用js跳转页面，也会丢失request中的数据</p>
<h1 id="会话">会话</h1>
<p>**会话（session）的概念:**从打开浏览器到关闭浏览器,期间访问服务器就称为一次会话</p>
<p><strong>request &amp; session区别和联系：</strong></p>
<ul>
<li>
<p>request存的值只能在单次请求中保存，保存的数据不能跨页面,当重定向时,request存的值会丢失。</p>
</li>
<li>
<p>session的数据可以在多个页面中共享,即使重定向页面,数据不会丢失。</p>
</li>
<li>
<p>session中可以包含n个request。</p>
</li>
</ul>
<p><strong>常用方法：</strong></p>
<ul>
<li>
<p>void setAttribute(String key,Object value) ：以key/value的形式保存对象值,将数据存储在服务器端</p>
</li>
<li>
<p>Object getAttribute(String key) ：通过key获取对象值</p>
</li>
<li>
<p>void invalidate() ：设置session对象失效</p>
</li>
<li>
<p>String getId() ：获取sessionid,当第一次登录成功后，session会产生一个唯一的id，浏览器之后访问时如果发现id值还是之前id，那么说明当前访问的属于同一个会话</p>
</li>
<li>
<p>void setMaxInactiveInterval(int interval) ：设定session的非活动时间</p>
<ul>
<li>方式一：</li>
</ul>
<pre><code class="language-java">session.setMaxInactiveInterval(10*60);//设置有效时间为10分钟
</code></pre>
<ul>
<li>方式二：</li>
</ul>
<pre><code class="language-java">&lt;session-config&gt;
&lt;session-timeout&gt;10&lt;/session-timeout&gt;//单位:分钟
&lt;/session-config&gt;
</code></pre>
</li>
<li>
<p>int getMaxInactiveInterval() ：获取session的有效非活动时间(以秒为单位)，默认的有效时间:30分钟.</p>
</li>
<li>
<p>void removeAttribute(String key)：从session中删除指定名称(key)所对应的对象</p>
</li>
<li>
<p>小结 :让session失效的方式<br>
（1）invalidate() （2）removeAttribute(&quot;key&quot;) （3）直接关闭浏览器。<br>
示例:使用session验证用户是否登录<br>
补充:<br>
自动刷新到某页面:<br>
注:在head标签中添加该标签，单位:秒</p>
</li>
</ul>
<h1 id="获得初始化参数">获得初始化参数</h1>
<p>request.setCharacterEncoding(&quot;utf-8&quot;);代码的耦合度太高，不便于后期维护修改。可以通过初始化参数实现。</p>
<p><strong>实现方式:</strong></p>
<p><strong>一、方式一</strong>：</p>
<ul>
<li>1、web.xml中先定义初始化参数</li>
</ul>
<pre><code class="language-java">&lt;servlet&gt;
&lt;servlet-name&gt;&lt;/servlet-name&gt;
&lt;servlet-class&gt;&lt;/servlet-class&gt;
&lt;init-param&gt;
&lt;param-name&gt;encoding&lt;/param-name&gt;
&lt;param-value&gt;utf-8&lt;/param-value&gt;
&lt;/init-param&gt;
&lt;/servlet&gt;
</code></pre>
<ul>
<li>2、servlet中获得初始化参数，重写init()方法</li>
</ul>
<pre><code class="language-jav">public void init(ServletConfig config) throws ServletException {
encoding= config.getInitParameter(&quot;encoding&quot;);
}
</code></pre>
<p>注意:这种方式的初始化参数仅限于当前servlet中使用。</p>
<p><strong>二、方式二全局初始化参数</strong></p>
<ul>
<li>1、定义，context-param是和servlet标签同级别</li>
</ul>
<pre><code class="language-java">&lt;context-param&gt;
&lt;param-name&gt;bianma&lt;/param-name&gt;
&lt;param-value&gt;utf-8&lt;/param-value&gt;
&lt;/context-param&gt;
</code></pre>
<h1 id="servlet30">servlet3.0</h1>
<p>从Servlet3.0开始，配置Servlet支持注解方式，但还是保留了配置web.xml方式，所有使用Servlet有两种方式：</p>
<p>（1）Servlet类上使用@WebServlet注解进行配置</p>
<p>（2）web.xml文件中配置<br>
<img src="https://Vinci-Ma.github.io/post-images/1597416954401.png" alt="" loading="lazy"></p>
<p><mark>注意</mark></p>
<ul>
<li>.loadOnStartup属性：标记容器是否在启动应用时就加载Servlet，默认不配置或数值为负数时表示客户端第一次请求Servlet时再加载；0或正数表示启动应用就加载，正数情况下，数值越小，加载该Servlet的优先级越高；</li>
</ul>
<pre><code class="language-java">@WebServlet(value=&quot;/test1&quot;,loadOnStartup=1)
</code></pre>
<ul>
<li>
<p>.name属性：可以指定也可以不指定，通过getServletName()可以获取到，若不指定，则为Servlet的完整类名，如：cn.edu.njit.servlet.UserServlet</p>
</li>
<li>
<p>.urlPatterns/value属性： String[]类型，可以配置多个映射，如：urlPatterns={&quot;/user/test&quot;, &quot;/user/example&quot;}</p>
</li>
<li>
<p>.在使用注解方式时，需要注意：<br>
根元素中不能配置属性metadata-complete=&quot;true&quot;，否则无法加载Servlet。metadata-complete属性表示通知<br>
Web容器是否寻找注解，默认不写或者设置false，容器会扫描注解，为Web应用程序构建有效的元数据；metadata-complete=&quot;true&quot;，会在启动时不扫描注解（annotation）。如果不扫描注解的话，用注解进行的配置就无法生效，例如：@WebServlet</p>
</li>
<li>
<p>.urlPatterns的常用规则：</p>
<ul>
<li>/*或者/：拦截所有</li>
<li>*.do：拦截指定后缀</li>
<li>/user/test：拦截路径</li>
<li>/user/.do、/.do、test*.do都是非法的，启动时候会报错</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[AJAX学习]]></title>
        <id>https://Vinci-Ma.github.io/post/ajax-xue-xi/</id>
        <link href="https://Vinci-Ma.github.io/post/ajax-xue-xi/">
        </link>
        <updated>2020-08-14T14:49:10.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#ajax%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%8E%9F%E7%90%86">Ajax技术与原理</a>
<ul>
<li><a href="#1-ajax%E7%AE%80%E4%BB%8B">1、Ajax简介</a></li>
<li><a href="#2-ajax%E6%89%80%E5%8C%85%E5%90%AB%E7%9A%84%E6%8A%80%E6%9C%AF">2、Ajax所包含的技术</a></li>
<li><a href="#3-ajax%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">3、Ajax的工作原理</a>
<ul>
<li><a href="#1-%E6%A8%A1%E5%9E%8B">1、模型</a></li>
<li><a href="#2-%E4%BA%A4%E4%BA%92%E6%96%B9%E5%BC%8F">2、交互方式</a></li>
</ul>
</li>
<li><a href="#4-xmlhttprequest%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7">4、XMLHttpRequest常用属性</a>
<ul>
<li><a href="#1-onreadystatechange-%E5%B1%9E%E6%80%A7%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0">1、onreadystatechange 属性（回调函数）</a></li>
<li><a href="#2-readystate-%E5%B1%9E%E6%80%A7">2、readyState 属性</a></li>
<li><a href="#3-responsetext-%E5%B1%9E%E6%80%A7">3、responseText 属性</a></li>
</ul>
</li>
<li><a href="#5-xmlhttprequest%E6%96%B9%E6%B3%95">5、XMLHttpRequest方法</a>
<ul>
<li><a href="#1-open-%E6%96%B9%E6%B3%95">1、open() 方法</a></li>
<li><a href="#2-send-%E6%96%B9%E6%B3%95">2、send() 方法</a></li>
<li><a href="#3-%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95">3、其他方法</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#ajax%E7%BC%96%E7%A8%8B%E6%AD%A5%E9%AA%A4%E5%9F%BA%E4%BA%8Ejs%E5%AE%9E%E7%8E%B0ajax">Ajax编程步骤（基于js实现ajax）</a>
<ul>
<li><a href="#1-%E5%88%9B%E5%BB%BAxmlhttprequest%E5%AF%B9%E8%B1%A1">1、创建XMLHttpRequest对象</a></li>
<li><a href="#2-%E8%AE%BE%E7%BD%AE%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F">2、设置请求方式</a></li>
<li><a href="#3-%E8%B0%83%E7%94%A8%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0">3、调用回调函数</a></li>
<li><a href="#4-%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82">4、发送请求</a></li>
</ul>
</li>
<li><a href="#jquery%E7%9A%84ajax%E6%93%8D%E4%BD%9C">jquery的ajax操作*</a><br>
*
<ul>
<li><a href="#1-%E4%BC%A0%E7%BB%9F%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0ajax%E7%9A%84%E4%B8%8D%E8%B6%B3">1、传统方式实现Ajax的不足</a></li>
<li><a href="#2-ajax%E6%96%B9%E6%B3%95">2、ajax()方法</a></li>
<li><a href="#3-get-%E6%96%B9%E6%B3%95%E9%80%9A%E8%BF%87%E8%BF%9C%E7%A8%8B-http-get-%E8%AF%B7%E6%B1%82%E8%BD%BD%E5%85%A5%E4%BF%A1%E6%81%AF">3、get() 方法通过远程 HTTP GET 请求载入信息</a></li>
<li><a href="#4-post-%E6%96%B9%E6%B3%95%E9%80%9A%E8%BF%87%E8%BF%9C%E7%A8%8B-http-get-%E8%AF%B7%E6%B1%82%E8%BD%BD%E5%85%A5%E4%BF%A1%E6%81%AF">4、post() 方法通过远程 HTTP GET 请求载入信息</a></li>
</ul>
</li>
<li><a href="#json">JSON</a>
<ul>
<li><a href="#1-json%E6%A6%82%E5%BF%B5">1、JSON概念</a></li>
<li><a href="#2-json%E5%AF%B9%E8%B1%A1%E5%AE%9A%E4%B9%89%E5%92%8C%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8">2、JSON对象定义和基本使用</a>
<ul>
<li><a href="#1-%E5%AE%9A%E4%B9%89">1、定义</a></li>
<li><a href="#2-json%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE">2、JSON对象的访问</a></li>
</ul>
</li>
<li><a href="#3-json%E5%9C%A8java%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8">3、JSON在java中的使用*</a>
<ul>
<li><a href="#java%E5%AF%B9%E8%B1%A1%E5%92%8Cjson%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2">java对象和json之间的转换</a>
<ul>
<li><a href="#1-%E5%8D%95%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%88%96map%E9%9B%86%E5%90%88">1、单个对象或map集合</a></li>
<li><a href="#2-%E5%AF%B9%E8%B1%A1%E9%9B%86%E5%90%88%E5%92%8Cjson%E7%9A%84%E8%BD%AC%E6%8D%A2">2、对象集合和json的转换</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<h1 id="ajax技术与原理">Ajax技术与原理</h1>
<h2 id="1-ajax简介">1、Ajax简介</h2>
<p>AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。</p>
<p>AJAX 不是新的编程语言，而是一种使用现有标准的新方法。</p>
<p>AJAX 是与服务器交换数据并更新部分网页的艺术，在不重新加载整个页面的情况下。</p>
<h2 id="2-ajax所包含的技术">2、Ajax所包含的技术</h2>
<p>Ajax并非一种新的技术，而是几种原有技术的结合体。它由下列技术组合而成。</p>
<pre><code class="language-java">1.使用CSS和XHTML来表示。
2.使用DOM模型来交互和动态显示。
3.使用XMLHttpRequest来和服务器进行异步通信。
4.使用javascript来绑定和调用。
</code></pre>
<p>AJAX 的核心是 XMLHttpRequest 对象</p>
<p>不同的浏览器创建 XMLHttpRequest 对象的方法是有差异的。</p>
<p><strong>IE 浏览器使用 ActiveXObject，而其他的浏览器使用名为 XMLHttpRequest 的 JavaScript 内建对象</strong></p>
<h2 id="3-ajax的工作原理">3、Ajax的工作原理</h2>
<p>Ajax的工作原理相当于在用户和服务器之间加了—个<strong>中间层(AJAX引擎)</strong>，使用户操作与服务器响应<strong>异步化</strong>。</p>
<p>并不是所有的用户请求都提交给服务器。像—些数据验证和数据处理等都交给Ajax引擎自己来做,，只有确定需要从服务器读取新数据时再由Ajax引擎代为向服务器提交请求。</p>
<p><strong>两者区别：</strong></p>
<h3 id="1-模型">1、模型</h3>
<p>1、传统的Web模型<br>
<img src="https://Vinci-Ma.github.io/post-images/1597416658095.png" alt="" loading="lazy"><br>
2、Ajax模型<br>
<img src="https://Vinci-Ma.github.io/post-images/1597416689051.png" alt="" loading="lazy"></p>
<h3 id="2-交互方式">2、交互方式</h3>
<p>1、浏览器的普通交互方式</p>
<figure data-type="image" tabindex="1"><img src="https://Vinci-Ma.github.io/post-images/1597416712107.jpg" alt="" loading="lazy"></figure>
<p>2、浏览器的Ajax交互方式</p>
<figure data-type="image" tabindex="2"><img src="https://Vinci-Ma.github.io/post-images/1597416723665.jpg" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://Vinci-Ma.github.io/post-images/1597416744223.png" alt="" loading="lazy"></figure>
<h2 id="4-xmlhttprequest常用属性">4、XMLHttpRequest常用属性</h2>
<h3 id="1-onreadystatechange-属性回调函数">1、onreadystatechange 属性（回调函数）</h3>
<p>onreadystatechange 属性存有处理服务器响应的函数。 下面的代码定义一个空的函数，可同时对onreadystatechange 属性进行设置：</p>
<pre><code class="language-java">xmlHttp.onreadystatechange = function() { //我们需要在这写一些代码}
</code></pre>
<h3 id="2-readystate-属性">2、readyState 属性</h3>
<p>readyState 属性<strong>存有服务器响应的状态信息</strong>。每当 readyState 改变时，onreadystatechange 函数就会被执行。<br>
readyState 属性可能的值：</p>
<h3 id="3-responsetext-属性">3、responseText 属性</h3>
<p>可以通过 responseText 属性来取回由服务器返回的数据。 在我们的代码中，我们将把时间文本框的值设置为等于responseText：</p>
<pre><code class="language-java">xmlHttp.onreadystatechange = function() {
if (xmlHttp.readyState == 4) {
document.myForm.time.value = xmlHttp.responseText;
}
}
</code></pre>
<h2 id="5-xmlhttprequest方法">5、XMLHttpRequest方法</h2>
<h3 id="1-open-方法">1、open() 方法</h3>
<p>open() 有三个参数。第一个参数定义发送请求所使用的方法，第二个参数规定服务器端脚本的URL，第三个参数规定应当对请求进行异步地处理。</p>
<pre><code class="language-java">xmlHttp.open(&quot;GET&quot;,&quot;test.php&quot;,true);
</code></pre>
<h3 id="2-send-方法">2、send() 方法</h3>
<p>send() 方法将请求送往服务器。如果我们假设 HTML 文件和 PHP 文件位于相同的目录，那么代码是这样的：</p>
<pre><code class="language-java">xmlHttp.send(null);
</code></pre>
<h3 id="3-其他方法">3、其他方法</h3>
<figure data-type="image" tabindex="4"><img src="https://Vinci-Ma.github.io/post-images/1597416761579.png" alt="" loading="lazy"></figure>
<h1 id="ajax编程步骤基于js实现ajax">Ajax编程步骤（基于js实现ajax）</h1>
<pre><code class="language-java">1. 创建XMLHttpRequest对象。
2. 设置请求方式。
3. 调用回调函数。
4. 发送请求。
</code></pre>
<h2 id="1-创建xmlhttprequest对象">1、创建XMLHttpRequest对象</h2>
<pre><code class="language-java">var xmlHttp=new XMLHttpRequest();
如果是IE5或者IE6浏览器，则使用ActiveX对象，创建方法是：
var xmlHttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
一般我们手写AJAX的时候，首先要判断该浏览器是否支持XMLHttpRequest对象，如果支持则创建该对象，如果不支持则创建ActiveX对象。JS代码如下：
    //第一步：创建XMLHttpRequest对象
var xmlHttp;
if (window.XMLHttpRequest) {
    //非IE
    xmlHttp = new XMLHttpRequest();
} else if (window.ActiveXObject) {
    //IE
    xmlHttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;)
}
</code></pre>
<h2 id="2-设置请求方式">2、设置请求方式</h2>
<pre><code class="language-java">//第二步：设置和服务器端交互的相应参数，向路径http://localhost:8080/JsLearning3/getAjax准备发送数据
var url = &quot;http://localhost:8080/JsLearning3/getAjax&quot;;
xmlHttp.open(&quot;POST&quot;, url, true);
</code></pre>
<h2 id="3-调用回调函数">3、调用回调函数</h2>
<pre><code class="language-java">//第三步：注册回调函数
xmlHttp.onreadystatechange = function() {
    //判断状态
    if (xmlHttp.readyState == 4) {
        //接收返回的内容
        if (xmlHttp.status == 200) {
            var obj = document.getElementById(id);
            obj.innerHTML = xmlHttp.responseText;
        } else {
        	alert(&quot;AJAX服务器返回错误！&quot;);
        }
    }
}
</code></pre>
<h2 id="4-发送请求">4、发送请求</h2>
<pre><code class="language-java">//第四步：设置发送请求的内容和发送报送。然后发送请求
var uname= document.getElementsByName(&quot;userName&quot;)[0].value;
var upass= document.getElementsByName(&quot;userPass&quot;)[0].value ;
var params = &quot;userName=&quot; + uname+ &quot;&amp;userPass=&quot; +upass+ &quot;&amp;time=&quot; + Math.random();
// 增加time随机参数，防止读取缓存
xmlHttp.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded;charset=UTF-8&quot;);

// 向请求添加 HTTP 头，POST如果有数据一定加加！！！！
xmlHttp.send(params);
</code></pre>
<h1 id="jquery的ajax操作">jquery的ajax操作*</h1>
<h3 id="1-传统方式实现ajax的不足">1、传统方式实现Ajax的不足</h3>
<p>步骤繁琐，方法、属性、常用值较多不好记忆</p>
<h3 id="2-ajax方法">2、ajax()方法</h3>
<p>可以通过发送 HTTP请求加载远程数据，是 jQuery 最底层的 Ajax 实现，具有较高灵活性。</p>
<p>$.ajax([settings]);//参数settings是方法的参数列表，用于配置Ajax请求的键值对集合；</p>
<pre><code class="language-java">$.ajax({
    url:请求地址
    type:&quot;get | post | put | delete &quot; 默认是get,
    data:请求参数 {&quot;id&quot;:&quot;123&quot;,&quot;pwd&quot;:&quot;123456&quot;},
    dataType:请求数据类型&quot;html | text | json | xml | script | jsonp &quot;,
    success:function(data,dataTextStatus,jqxhr){ },//请求成功时
error:function(jqxhr,textStatus,error)//请求失败时
})
</code></pre>
<h3 id="3-get-方法通过远程-http-get-请求载入信息">3、get() 方法通过远程 HTTP GET 请求载入信息</h3>
<p>这是一个简单的 GET 请求功能以取代复杂 $.ajax</p>
<pre><code class="language-java">$.get(url,data,function(result) {
//省略将服务器返回的数据显示到页面的代码
});
url:请求的路径
data:发送的数据
success:成功函数
datatype 返回的数据
</code></pre>
<h3 id="4-post-方法通过远程-http-get-请求载入信息">4、post() 方法通过远程 HTTP GET 请求载入信息</h3>
<pre><code class="language-java">$.post(url,data,function(result) {
//省略将服务器返回的数据显示到页面的代码
});
url:请求的路径
data:发送的数据
success:成功函数
datatype 返回的数据
</code></pre>
<h1 id="json">JSON</h1>
<h2 id="1-json概念">1、JSON概念</h2>
<p>JSON (JavaScript Object Notation) 是一种轻量级的数据交换格式。 易于人阅读和编写。同时也易于机器解析和生成。</p>
<h2 id="2-json对象定义和基本使用">2、JSON对象定义和基本使用</h2>
<h3 id="1-定义">1、定义</h3>
<pre><code class="language-java">var 变量名 = {
“key” : value , // Number类型
“key2” : “value” , // 字符串类型
“key3” : [] , // 数组类型
“key4” : {}, // json 对象类型
“key5” : [{},{}] // json 数组
};
</code></pre>
<h3 id="2-json对象的访问">2、JSON对象的访问</h3>
<p>son对象，顾名思义，就知道它是一个对象。里面的key就是对象的属性。我们要访问一个对象的属性，只需要使用【对象名.属性名】的方式访问即可</p>
<pre><code class="language-java">&lt;script type=&quot;text/javascript&quot;&gt;
// json的定义
var jsons = {
&quot;key1&quot;:&quot;abc&quot;, // 字符串类型
&quot;key2&quot;:1234, // Number
&quot;key3&quot;:[1234,&quot;21341&quot;,&quot;53&quot;], // 数组
&quot;key4&quot;:{ // json类型
    &quot;key4_1&quot; : 12,
    &quot;key4_2&quot; : &quot;kkk&quot;
    },
&quot;key5&quot;:[{ // json数组
    &quot;key5_1_1&quot; : 12,
    &quot;key5_1_2&quot; : &quot;abc&quot;
    },{
        &quot;key5_2_1&quot; : 41,
            &quot;key5_2_2&quot; : &quot;bbj&quot;
        }]
};
// 访问json的属性
alert(jsons.key1); // &quot;abc&quot;
// 访问json的数组属性
alert(jsons.key3[1]); // &quot;21341&quot;
// 访问json的json属性
alert(jsons.key4.key4_1);//12
// 访问json的json数组
alert(jsons.key5[0].key5_1_2);//&quot;abc&quot;
&lt;/script&gt;
</code></pre>
<h2 id="3-json在java中的使用">3、JSON在java中的使用*</h2>
<figure data-type="image" tabindex="5"><img src="https://Vinci-Ma.github.io/post-images/1597416788349.png" alt="" loading="lazy"></figure>
<h3 id="java对象和json之间的转换">java对象和json之间的转换</h3>
<h4 id="1-单个对象或map集合">1、单个对象或map集合</h4>
<pre><code class="language-java">java-&gt;json：
    Users user2=new Users();
    user2.setUsername(&quot;李四&quot;);
    user2.setPassword(&quot;abc&quot;);
    user2.setAge(20);
    JSONObject obj=JSONObject.fromObject(user);//obj就是json格式的

json-&gt;java
    String str=&quot;{'username':'李四','password':'admin','age':19}&quot;;
    JSONObject json=JSONObject.fromObject(str);
    Users user=(Users)JSONObject.toBean(json,Users.class);
</code></pre>
<h4 id="2-对象集合和json的转换">2、对象集合和json的转换</h4>
<pre><code class="language-java">java集合-&gt;json数组:
    List list=new ArrayList();
    list.add(&quot;dd&quot;);
    list.add(&quot;aa&quot;);
    JSONArray obj=JSONArray.fromObject(list);//set也是这么转
json数组-&gt;java集合:
	Key1:
	String str2=&quot;[{'age':20,'password':'abc','username':'李四'},{'age':10,'password':'adb','username':'张三'}]&quot;;
	JSONArray json2=JSONArray.fromObject(str2);
	Object[] obj=(Object[])JSONArray.toArray(json2,Users.class);

	Key2:
	String str3=&quot;[{'age':20,'password':'abc','username':'李四'},{'age':10,'password':'adb','username':'展示干'}]&quot;;
	JSONArray json3=JSONArray.fromObject(str3);
	//默认转换成ArrayList
	List&lt;Users&gt; list=(List&lt;Users&gt;) 				JSONArray.toCollection(json3,Users.class);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MVC学习]]></title>
        <id>https://Vinci-Ma.github.io/post/mvc-xue-xi/</id>
        <link href="https://Vinci-Ma.github.io/post/mvc-xue-xi/">
        </link>
        <updated>2020-08-14T14:44:15.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#mvc">MVC</a>
<ul>
<li><a href="#1mvc%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">1.MVC设计模式</a></li>
<li><a href="#2%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84%E5%86%99%E4%BB%A3%E7%A0%81%E6%97%B6%E9%9C%80%E8%A6%81%E9%81%B5%E5%BE%AA%E7%9A%84">2.三层架构（写代码时需要遵循的）</a></li>
<li><a href="#3%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84%E4%B8%8Emvc%E7%9A%84%E5%8C%BA%E5%88%AB">3.三层架构与MVC的区别</a></li>
</ul>
</li>
<li><a href="#%E4%B8%80%E8%88%AC%E7%9A%84%E5%8C%85%E7%BB%93%E6%9E%84">一般的包结构</a></li>
</ul>
</p>
<h1 id="mvc">MVC</h1>
<p>随着项目中代码的增多，需要一个模式去规范</p>
<h2 id="1mvc设计模式">1.MVC设计模式</h2>
<p>MVC中的M(模型)-V(视图)-C(控制器)概念和标准MVC概念一样</p>
<p>在Web MVC模式下，模型无法主动推数据给视图，如果用户想要视图更新，需要再发送一次请求（即请求-响应模型）。</p>
<figure data-type="image" tabindex="1"><img src="https://Vinci-Ma.github.io/post-images/1597416425620.jpeg" alt="" loading="lazy"></figure>
<p><strong>M(Model) 模型 :</strong> 应用程序的核心功能，管理这个模块中用的数据和值（bean,dao）；</p>
<pre><code class="language-java">JavaBeans :是Java中一种特殊的类（换言之：JavaBean就是一个Java类）.
一个Java类 ，满足以下要求，则可称为一个JavaBean
    a. public修饰的类，提供public 无参构造方法
    b. 所有属性 都是private
    C. 提供getter和setter方法
从使用层面来看，JavaBean分为2大类：
    a. 封装业务逻辑的JavaBean(eg:LoginDao.java 封装了登录逻辑)
    b. 封装数据的JavaBean(实体类：eg：Student.java Vadio.java 。往往对应于数据库中的一张表，即数据库中有个Student表，项目中就有个Student.java类)通常:表名=类名，列名=属性名
JavaBean是一个可以重复使用的组件，通过编写一个组件来实现某种通用功能，“一次编写、任何地方执行、任何地方重用”。
</code></pre>
<p><strong>V(View )视图：</strong><br>
视图提供模型的展示，管理模型如何显示给用户，它是应用程序的外观；（jsp/html）<br>
<strong>C(Controller)控制器：</strong><br>
对用户的输入做出反应，管理用户和视图的交互，是连接模型和视图的枢纽。（servlet/service）<br>
MVC用于将web（UI）层进行职责解耦</p>
<p><strong>MVC设计模式并不属于23种设计模式</strong></p>
<h2 id="2三层架构写代码时需要遵循的">2.三层架构（写代码时需要遵循的）</h2>
<p>三层架构，通常意义上的三层架构就是将整个业务应用划分为：表现层（UI）、业务逻辑层（BLL）、数据访问层（DAL）。区分层次的目的即为了“高内聚，低耦合”的思想。</p>
<p><strong>1、表现层（UI）：</strong><br>
通俗讲就是展现给用户的界面，即用户在使用一个系统的时候他的所见所得。 jsp/html</p>
<p>表现层实现的代表作品是Struts,springmvc框架</p>
<p><strong>2、业务逻辑层（BLL）：</strong><br>
针对具体问题的操作，也可以说是对数据层的操作，对数据业务逻辑处理。servlet,service</p>
<p>业务层实现的代表作品是Spring</p>
<p><strong>3、数据访问层（DAL）：</strong><br>
该层所做事务直接操作数据库，针对数据的增添、删除、修改、更新、查找等。dao</p>
<p>持久层实现的代表作品是Hibernate,mybatis。</p>
<p>层就相当于一个黑盒子，我们不用知道它内部怎么实现，只需要知道如何去调用它就行了。每层只与上下相邻的两层打交道。当一层内部由于技术变迁发生变化时，只要接口不变，其他层不用做任何改变。分层之后灵活性提高，也便于团队分工开发。</p>
<h2 id="3三层架构与mvc的区别">3.三层架构与MVC的区别</h2>
<figure data-type="image" tabindex="2"><img src="https://Vinci-Ma.github.io/post-images/1597416456532.png" alt="" loading="lazy"></figure>
<p>MVC是 Model-View-Controller，严格说这三个加起来以后才是三层架构中的UI层，也就是说，MVC把三层架构中的UI层再度进行了分化，分成了控制器、视图、实体三个部分，控制器完成页面逻辑，通过实体来与界面层完成通话；而C层直接与三层中的BLL进行对话。</p>
<p>MVC可以是三层中的一个表现层框架，属于表现层。三层和mvc可以共存。</p>
<p>三层是基于业务逻辑来分的，而MVC是基于页面来分的。</p>
<p>MVC主要用于表现层，3层主要用于体系架构，3层一般是表现层、中间层、数据层，其中表现层又可以分成M、V、C，(Model View Controller)模型－视图－控制器</p>
<p>MVC是表现模式（Presentation Pattern）</p>
<p>三层架构是典型的架构模式（Architecture Pattern）</p>
<p>三层架构的分层模式是典型的上下关系，上层依赖于下层。但MVC作为表现模式是不存在上下关系的，而是相互协作关系。即使将MVC当作架构模式，也不是分层模式。MVC和三层架构基本没有可比性，是应用于不同领域的技术。</p>
<h1 id="一般的包结构">一般的包结构</h1>
<p>src中【bean+dao=M（模型层）】</p>
<p>【Servlet调取Service，Service调取Dao，Dao调取数据库】</p>
<ul>
<li>
<p>com.~</p>
<ul>
<li>bean
<ul>
<li>student【创建一个对象类，表名=类名，列名=属性名】</li>
</ul>
</li>
<li>dao（操作数据库的接口）
<ul>
<li>StudentDao【接口，定义操作数据库的方法】</li>
<li>impl.StudentDaoImpl【操作数据库。1、继承德鲁伊，实现StudentDao，得到数据源，加载驱动】</li>
</ul>
</li>
<li>service（Servlet和dao的连接）
<ul>
<li>StudentService（接口，复制StudentDao）</li>
<li>impl.StudentServiceImpl【实现StudentService】</li>
</ul>
</li>
<li>util
<ul>
<li>DruidUtil【连接池】</li>
</ul>
</li>
<li>web
<ul>
<li>studentservlet【1、接收参数，2、调取service方法，3、跳转页面（需要存值）】</li>
</ul>
</li>
<li>druid.properties【德鲁伊】</li>
</ul>
<p>web中</p>
<ul>
<li>WEB-INF
<ul>
<li>lib【驱动包，需要配置环境】</li>
</ul>
</li>
<li>show.jsp【显示页面（需要取值）】</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Tomcat学习]]></title>
        <id>https://Vinci-Ma.github.io/post/tomcat-xue-xi/</id>
        <link href="https://Vinci-Ma.github.io/post/tomcat-xue-xi/">
        </link>
        <updated>2020-08-04T00:48:10.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#tomcat%E7%9A%84%E7%9B%AE%E5%BD%95">tomcat的目录</a>
<ul>
<li><a href="#1-bin">1、bin</a></li>
<li><a href="#2-conf">2、conf</a></li>
<li><a href="#3-lib">3、lib</a></li>
<li><a href="#4-logs">4、logs</a></li>
<li><a href="#5-temp">5、temp</a></li>
<li><a href="#6-webapps">6、webapps</a></li>
<li><a href="#7-work">7、work</a></li>
<li><a href="#8-license">8、LICENSE</a></li>
<li><a href="#9-notice">9、NOTICE</a></li>
<li><a href="#%E9%80%9A%E8%BF%87url%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E5%99%A8">通过url访问服务器:</a></li>
</ul>
</li>
</ul>
</p>
<h1 id="tomcat的目录">tomcat的目录</h1>
<h2 id="1-bin">1、bin</h2>
<p>该目录下存放的是二进制可执行文件，如果是安装版，那么这个目录下会有两个exe文件：tomcat9.exe、tomcat9w.exe，前者是在控制台下启动Tomcat，后者是弹出UGI窗口启动Tomcat；如果是解压版，那么会有startup.bat和shutdown.bat文件，startup.bat用来启动Tomcat，但需要JDK的配置，shutdown.bat用来停止Tomcat；</p>
<h2 id="2-conf">2、conf</h2>
<p>这是一个非常非常重要的目录，这个目录下有四个最为重要的文件：<br>
**server.xml：**配置整个服务器信息。例如修改端口号，添加虚拟主机等；<br>
**tomcat-users.xml：**存储tomcat用户的文件，这里保存的是tomcat的用户名及密码，以及用户的角色信息。可以<br>
按着该文件中的注释信息添加tomcat用户，然后就可以在Tomcat主页中进入Tomcat Manager页面了；<br>
**web.xml：**部署描述符文件，这个文件中注册了很多MIME类型，即文档类型。这些MIME类型是客户端与服务器之间说明文档类型的，如用户请求一个html网页，那么服务器还会告诉客户端浏览器响应的文档是text/html类型<br>
的，这就是一个MIME类型。客户端浏览器通过这个MIME类型就知道如何处理它了。当然是在浏览器中显示这个<br>
html文件了。但如果服务器响应的是一个exe文件，那么浏览器就不可能显示它，而是应该弹出下载窗口才对。<br>
MIME就是用来说明文档的内容是什么类型的！<br>
**context.xml：**对所有应用的统一配置，通常我们不会去配置它。</p>
<h2 id="3-lib">3、lib</h2>
<p>Tomcat的类库，里面是一大堆jar文件。如果需要添加Tomcat依赖的jar文件，可以把它放到这个目录中，<br>
当然也可以把应用依赖的jar文件放到这个目录中，这个目录中的jar所有项目都可以共享之，但这样你的应用放到<br>
其他Tomcat下时就不能再共享这个目录下的Jar包了，所以建议只把Tomcat需要的Jar包放到这个目录下；</p>
<h2 id="4-logs">4、logs</h2>
<p>这个目录中都是日志文件，记录了Tomcat启动和关闭的信息，如果启动Tomcat时有错误，那么异常也会<br>
记录在日志文件中。</p>
<h2 id="5-temp">5、temp</h2>
<p>存放Tomcat的临时文件，这个目录下的东西可以在停止Tomcat后删除！</p>
<h2 id="6-webapps">6、webapps</h2>
<p>存放web项目的目录，其中每个文件夹都是一个项目；如果这个目录下已经存在了目录，那么都是<br>
tomcat自带的项目。其中ROOT是一个特殊的项目，在地址栏中没有给出项目目录时，对应的就是ROOT项目。<br>
http://localhost:8080/examples，进入示例项目。其中examples就是项目名，即文件夹的名字。</p>
<h2 id="7-work">7、work</h2>
<p>运行时生成的文件，最终运行的文件都在这里。通过webapps中的项目生成的！可以把这个目录下的内<br>
容删除，再次运行时会生再次生成work目录。当客户端用户访问一个JSP文件时，Tomcat会通过JSP生成Java文<br>
件，然后再编译Java文件生成class文件，生成的java和class文件都会存放到这个目录下。</p>
<h2 id="8-license">8、LICENSE</h2>
<p>许可证</p>
<h2 id="9-notice">9、NOTICE</h2>
<p>说明文件</p>
<h2 id="通过url访问服务器">通过url访问服务器:</h2>
<p>url:http://服务器的ip地址:端口号/项目名/被访问的页面<br>
示例:http://localhost:8080/test0918<br>
注: (1)启动tomcat后,tomcat会加载部署在服务器端的所有项目<br>
(2) 浏览器访问的页面是服务器端的页面,基本上服务器的项目和工作空间的项目要保持一致</p>
]]></content>
    </entry>
</feed>