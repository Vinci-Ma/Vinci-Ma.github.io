<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>MVC学习 | Vinci-Ma</title>
<link rel="shortcut icon" href="https://Vinci-Ma.github.io/favicon.ico?v=1597471630652">
<link href="https://cdn.remixicon.com/releases/v2.1.0/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://Vinci-Ma.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="MVC学习 | Vinci-Ma - Atom Feed" href="https://Vinci-Ma.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="
MVC

1.MVC设计模式
2.三层架构（写代码时需要遵循的）
3.三层架构与MVC的区别


一般的包结构


MVC
随着项目中代码的增多，需要一个模式去规范
1.MVC设计模式
MVC中的M(模型)-V(视图)-C(控制器)概念和..." />
    <meta name="keywords" content="" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://Vinci-Ma.github.io">
  <img class="avatar" src="https://Vinci-Ma.github.io/images/avatar.png?v=1597471630652" alt="">
  </a>
  <h1 class="site-title">
    Vinci-Ma
  </h1>
  <p class="site-description">
    Stay cooool!
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="https://Vinci-Ma.github.io/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
        <a href="https://github.com/Vinci-Ma" target="_blank">
          <i class="ri-github-line"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              MVC学习
            </h2>
            <div class="post-info">
              <span>
                2020-08-14
              </span>
              <span>
                5 min read
              </span>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p><ul class="markdownIt-TOC">
<li><a href="#mvc">MVC</a>
<ul>
<li><a href="#1mvc%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">1.MVC设计模式</a></li>
<li><a href="#2%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84%E5%86%99%E4%BB%A3%E7%A0%81%E6%97%B6%E9%9C%80%E8%A6%81%E9%81%B5%E5%BE%AA%E7%9A%84">2.三层架构（写代码时需要遵循的）</a></li>
<li><a href="#3%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84%E4%B8%8Emvc%E7%9A%84%E5%8C%BA%E5%88%AB">3.三层架构与MVC的区别</a></li>
</ul>
</li>
<li><a href="#%E4%B8%80%E8%88%AC%E7%9A%84%E5%8C%85%E7%BB%93%E6%9E%84">一般的包结构</a></li>
</ul>
</p>
<h1 id="mvc">MVC</h1>
<p>随着项目中代码的增多，需要一个模式去规范</p>
<h2 id="1mvc设计模式">1.MVC设计模式</h2>
<p>MVC中的M(模型)-V(视图)-C(控制器)概念和标准MVC概念一样</p>
<p>在Web MVC模式下，模型无法主动推数据给视图，如果用户想要视图更新，需要再发送一次请求（即请求-响应模型）。</p>
<figure data-type="image" tabindex="1"><img src="https://Vinci-Ma.github.io/post-images/1597416425620.jpeg" alt="" loading="lazy"></figure>
<p><strong>M(Model) 模型 :</strong> 应用程序的核心功能，管理这个模块中用的数据和值（bean,dao）；</p>
<pre><code class="language-java">JavaBeans :是Java中一种特殊的类（换言之：JavaBean就是一个Java类）.
一个Java类 ，满足以下要求，则可称为一个JavaBean
    a. public修饰的类，提供public 无参构造方法
    b. 所有属性 都是private
    C. 提供getter和setter方法
从使用层面来看，JavaBean分为2大类：
    a. 封装业务逻辑的JavaBean(eg:LoginDao.java 封装了登录逻辑)
    b. 封装数据的JavaBean(实体类：eg：Student.java Vadio.java 。往往对应于数据库中的一张表，即数据库中有个Student表，项目中就有个Student.java类)通常:表名=类名，列名=属性名
JavaBean是一个可以重复使用的组件，通过编写一个组件来实现某种通用功能，“一次编写、任何地方执行、任何地方重用”。
</code></pre>
<p><strong>V(View )视图：</strong><br>
视图提供模型的展示，管理模型如何显示给用户，它是应用程序的外观；（jsp/html）<br>
<strong>C(Controller)控制器：</strong><br>
对用户的输入做出反应，管理用户和视图的交互，是连接模型和视图的枢纽。（servlet/service）<br>
MVC用于将web（UI）层进行职责解耦</p>
<p><strong>MVC设计模式并不属于23种设计模式</strong></p>
<h2 id="2三层架构写代码时需要遵循的">2.三层架构（写代码时需要遵循的）</h2>
<p>三层架构，通常意义上的三层架构就是将整个业务应用划分为：表现层（UI）、业务逻辑层（BLL）、数据访问层（DAL）。区分层次的目的即为了“高内聚，低耦合”的思想。</p>
<p><strong>1、表现层（UI）：</strong><br>
通俗讲就是展现给用户的界面，即用户在使用一个系统的时候他的所见所得。 jsp/html</p>
<p>表现层实现的代表作品是Struts,springmvc框架</p>
<p><strong>2、业务逻辑层（BLL）：</strong><br>
针对具体问题的操作，也可以说是对数据层的操作，对数据业务逻辑处理。servlet,service</p>
<p>业务层实现的代表作品是Spring</p>
<p><strong>3、数据访问层（DAL）：</strong><br>
该层所做事务直接操作数据库，针对数据的增添、删除、修改、更新、查找等。dao</p>
<p>持久层实现的代表作品是Hibernate,mybatis。</p>
<p>层就相当于一个黑盒子，我们不用知道它内部怎么实现，只需要知道如何去调用它就行了。每层只与上下相邻的两层打交道。当一层内部由于技术变迁发生变化时，只要接口不变，其他层不用做任何改变。分层之后灵活性提高，也便于团队分工开发。</p>
<h2 id="3三层架构与mvc的区别">3.三层架构与MVC的区别</h2>
<figure data-type="image" tabindex="2"><img src="https://Vinci-Ma.github.io/post-images/1597416456532.png" alt="" loading="lazy"></figure>
<p>MVC是 Model-View-Controller，严格说这三个加起来以后才是三层架构中的UI层，也就是说，MVC把三层架构中的UI层再度进行了分化，分成了控制器、视图、实体三个部分，控制器完成页面逻辑，通过实体来与界面层完成通话；而C层直接与三层中的BLL进行对话。</p>
<p>MVC可以是三层中的一个表现层框架，属于表现层。三层和mvc可以共存。</p>
<p>三层是基于业务逻辑来分的，而MVC是基于页面来分的。</p>
<p>MVC主要用于表现层，3层主要用于体系架构，3层一般是表现层、中间层、数据层，其中表现层又可以分成M、V、C，(Model View Controller)模型－视图－控制器</p>
<p>MVC是表现模式（Presentation Pattern）</p>
<p>三层架构是典型的架构模式（Architecture Pattern）</p>
<p>三层架构的分层模式是典型的上下关系，上层依赖于下层。但MVC作为表现模式是不存在上下关系的，而是相互协作关系。即使将MVC当作架构模式，也不是分层模式。MVC和三层架构基本没有可比性，是应用于不同领域的技术。</p>
<h1 id="一般的包结构">一般的包结构</h1>
<p>src中【bean+dao=M（模型层）】</p>
<p>【Servlet调取Service，Service调取Dao，Dao调取数据库】</p>
<ul>
<li>
<p>com.~</p>
<ul>
<li>bean
<ul>
<li>student【创建一个对象类，表名=类名，列名=属性名】</li>
</ul>
</li>
<li>dao（操作数据库的接口）
<ul>
<li>StudentDao【接口，定义操作数据库的方法】</li>
<li>impl.StudentDaoImpl【操作数据库。1、继承德鲁伊，实现StudentDao，得到数据源，加载驱动】</li>
</ul>
</li>
<li>service（Servlet和dao的连接）
<ul>
<li>StudentService（接口，复制StudentDao）</li>
<li>impl.StudentServiceImpl【实现StudentService】</li>
</ul>
</li>
<li>util
<ul>
<li>DruidUtil【连接池】</li>
</ul>
</li>
<li>web
<ul>
<li>studentservlet【1、接收参数，2、调取service方法，3、跳转页面（需要存值）】</li>
</ul>
</li>
<li>druid.properties【德鲁伊】</li>
</ul>
<p>web中</p>
<ul>
<li>WEB-INF
<ul>
<li>lib【驱动包，需要配置环境】</li>
</ul>
</li>
<li>show.jsp【显示页面（需要取值）】</li>
</ul>
</li>
</ul>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#mvc">MVC</a>
<ul>
<li><a href="#1mvc%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">1.MVC设计模式</a></li>
<li><a href="#2%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84%E5%86%99%E4%BB%A3%E7%A0%81%E6%97%B6%E9%9C%80%E8%A6%81%E9%81%B5%E5%BE%AA%E7%9A%84">2.三层架构（写代码时需要遵循的）</a></li>
<li><a href="#3%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84%E4%B8%8Emvc%E7%9A%84%E5%8C%BA%E5%88%AB">3.三层架构与MVC的区别</a></li>
</ul>
</li>
<li><a href="#%E4%B8%80%E8%88%AC%E7%9A%84%E5%8C%85%E7%BB%93%E6%9E%84">一般的包结构</a></li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://Vinci-Ma.github.io/post/tomcat-xue-xi/">
              <h3 class="post-title">
                Tomcat学习
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  
  <a class="rss" href="https://Vinci-Ma.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
