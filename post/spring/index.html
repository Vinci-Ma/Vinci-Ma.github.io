<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Spring | Vinci-Ma</title>
<link rel="shortcut icon" href="https://Vinci-Ma.github.io/favicon.ico?v=1600674280000">
<link href="https://cdn.remixicon.com/releases/v2.1.0/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://Vinci-Ma.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="Spring | Vinci-Ma - Atom Feed" href="https://Vinci-Ma.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="
一、Spring介绍

1、特点
2、组织框架
3、核心模块


二、Spring中的IOC

1、实现过程
2、bean标签的属性介绍
3、Spring中对象创建的方式
4、SpringBean的生命周期【重要】


三、DI注入值
*..." />
    <meta name="keywords" content="" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://Vinci-Ma.github.io">
  <img class="avatar" src="https://Vinci-Ma.github.io/images/avatar.png?v=1600674280000" alt="">
  </a>
  <h1 class="site-title">
    Vinci-Ma
  </h1>
  <p class="site-description">
    Stay cooool!
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="https://Vinci-Ma.github.io/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
        <a href="https://github.com/Vinci-Ma" target="_blank">
          <i class="ri-github-line"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              Spring
            </h2>
            <div class="post-info">
              <span>
                2020-09-16
              </span>
              <span>
                16 min read
              </span>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p><ul class="markdownIt-TOC">
<li><a href="#%E4%B8%80-spring%E4%BB%8B%E7%BB%8D">一、Spring介绍</a>
<ul>
<li><a href="#1-%E7%89%B9%E7%82%B9">1、特点</a></li>
<li><a href="#2-%E7%BB%84%E7%BB%87%E6%A1%86%E6%9E%B6">2、组织框架</a></li>
<li><a href="#3-%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97">3、核心模块</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C-spring%E4%B8%AD%E7%9A%84ioc">二、Spring中的IOC</a>
<ul>
<li><a href="#1-%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B">1、实现过程</a></li>
<li><a href="#2-bean%E6%A0%87%E7%AD%BE%E7%9A%84%E5%B1%9E%E6%80%A7%E4%BB%8B%E7%BB%8D">2、bean标签的属性介绍</a></li>
<li><a href="#3-spring%E4%B8%AD%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E7%9A%84%E6%96%B9%E5%BC%8F">3、Spring中对象创建的方式</a></li>
<li><a href="#4-springbean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%87%8D%E8%A6%81">4、SpringBean的生命周期【重要】</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89-di%E6%B3%A8%E5%85%A5%E5%80%BC">三、DI注入值</a><br>
*
<ul>
<li><a href="#1-set%E6%B3%A8%E5%85%A5%E5%80%BC">1、set注入值</a></li>
<li><a href="#2-%E6%9E%84%E9%80%A0%E6%B3%A8%E5%85%A5">2、构造注入</a></li>
<li><a href="#3-spel-spring%E8%A1%A8%E8%BE%BE%E5%BC%8F">3、spel spring表达式</a></li>
<li><a href="#4-p%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E6%B3%A8%E5%85%A5%E5%80%BC">4、p命名空间注入值</a></li>
<li><a href="#5-%E5%A4%8D%E6%9D%82%E7%B1%BB%E5%9E%8B%E6%B3%A8%E5%85%A5objectlistsetmapjavautilproperties">5、复杂类型注入（Object[]，list，set，map，java.util.Properties）</a></li>
<li><a href="#6-%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%85%A5%E7%94%B1%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E7%BB%99%E5%B1%9E%E6%80%A7%E8%B5%8B%E5%80%BC">6、自动注入（由程序自动给属性赋值）</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9B-%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0ioc">四、注解实现IOC</a><br>
*
<ul>
<li><a href="#1-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E6%B7%BB%E5%8A%A0%E7%BA%A6%E6%9D%9F">1、配置文件中添加约束</a></li>
<li><a href="#3-%E9%85%8D%E7%BD%AE%E6%B3%A8%E8%A7%A3%E6%89%AB%E6%8F%8F%E6%8C%87%E5%AE%9A%E6%89%AB%E6%8F%8F%E5%8C%85%E4%B8%8B%E6%89%80%E6%9C%89%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3%E6%89%AB%E6%8F%8F%E5%8C%85%E6%97%B6%E4%BC%9A%E6%89%AB%E6%8F%8F%E5%8C%85%E6%89%80%E6%9C%89%E7%9A%84%E5%AD%90%E5%AD%99%E5%8C%85">3、配置注解扫描:指定扫描包下所有类中的注解,扫描包时,会扫描包所有的子孙包</a></li>
<li><a href="#3-%E6%B3%A8%E8%A7%A3">3、注解</a></li>
</ul>
</li>
<li><a href="#%E4%BA%94-aop%E4%BB%8B%E7%BB%8D">五、Aop介绍</a></li>
<li><a href="#%E5%85%AD-aop%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6">六、AOP的实现机制</a>
<ul>
<li><a href="#1-jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0">1、JDK动态代理实现</a></li>
<li><a href="#2-cglib%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%90%86">2、CGlib实现代理</a></li>
<li><a href="#%E4%B8%A4%E7%A7%8D%E4%BB%A3%E7%90%86%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB">两种代理方式的区别:</a></li>
</ul>
</li>
</ul>
</p>
<h1 id="一-spring介绍">一、Spring介绍</h1>
<blockquote>
<p>Spring是一个开放源代码的设计层面框架，他解决的是业务逻辑层和其他各层的松耦合问题，因此它将面向接口的编程思想贯穿整个系统应用。Spring是于2003 年兴起的一个轻量级的Java 开发框架，由Rod Johnson创建。简单来说，Spring是一个分层的JavaSE/EE full-stack(一站式) 轻量级开源框架。</p>
</blockquote>
<h2 id="1-特点">1、特点</h2>
<ul>
<li>1、<strong>方便解耦，简化开发</strong></li>
<li>2、<strong>AOP编程的支持</strong></li>
<li>3、<strong>声明式事务的支持</strong></li>
<li>4、<strong>方便程序的测试</strong></li>
<li>5、<strong>方便集成各种优秀框架</strong></li>
<li>6、<strong>降低Java EE API的使用难度</strong></li>
</ul>
<h2 id="2-组织框架">2、组织框架</h2>
<figure data-type="image" tabindex="1"><img src="https://Vinci-Ma.github.io/post-images/1600674050078.png" alt="组织框架" loading="lazy"></figure>
<h2 id="3-核心模块">3、核心模块</h2>
<ul>
<li>spring-core：依赖注入IOC与DI的最基本实现</li>
<li>spring-beans：Bean工厂与bean的装配</li>
<li>spring-context：spring的context上下文即IoC容器</li>
<li>spring-context-support</li>
<li>spring-expression：spring表达式语言</li>
</ul>
<h1 id="二-spring中的ioc">二、Spring中的IOC</h1>
<p>IOC是 Inverse of Control 的简写，意思是控制反转。是<strong>降低对象之间的耦合关系</strong>的设计思想。</p>
<p>DI是Dependency Injection的缩写，意思是依赖注入，说的是创建对象实例时，同时为这个对象注入它所依赖的属性。</p>
<h2 id="1-实现过程">1、实现过程</h2>
<p>1、添加对应依赖包</p>
<pre><code class="language-java">&lt;!-- Spring的核心工具包--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-core&lt;/artifactId&gt;
        &lt;version&gt;5.0.8.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
&lt;!--在基础IOC功能上提供扩展服务，还提供许多企业级服务的支持，有邮件服务、
任务调度、远程访问、缓存以及多种视图层框架的支持--&gt;
    &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;5.0.8.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
&lt;!-- Spring IOC的基础实现，包含访问配置文件、创建和管理bean等 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;
        &lt;version&gt;5.0.8.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
&lt;!-- Spring context的扩展支持，用于MVC方面 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;
        &lt;version&gt;5.0.8.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
&lt;!-- Spring表达式语言 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-expression&lt;/artifactId&gt;
        &lt;version&gt;5.0.8.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
</code></pre>
<p>2、创建配置文件applicationContext.xml</p>
<pre><code class="language-java">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
&lt;/beans&gt;
</code></pre>
<p>3、在配置文件中创建对象</p>
<pre><code class="language-java">&lt;bean id=&quot;对象名&quot; class=&quot;类的完整路径&quot;&gt;
	&lt;property name=&quot;属性名&quot; ref=&quot;对象的id值&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<p>4、加载配置文件，获得对象</p>
<pre><code class="language-java">ApplicationContext app=new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);//解析xml文件
Users users=(Users)app.getBean(&quot;u1&quot;);//通过getBean得到指定对象
</code></pre>
<h2 id="2-bean标签的属性介绍">2、bean标签的属性介绍</h2>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>class</td>
<td>指定bean对应类的全路径</td>
</tr>
<tr>
<td>name</td>
<td>name是bean对应对象的一个标识</td>
</tr>
<tr>
<td>scope</td>
<td>执行bean对象创建模式和生命周期,scope=&quot;singleton&quot;（默认单例）和scope=&quot;prototype&quot;（多例）</td>
</tr>
<tr>
<td>id</td>
<td>id是bean对象的唯一标识,不能添加特别字符</td>
</tr>
<tr>
<td>lazy-init</td>
<td>是否延时加载 默认值:false。true 延迟加载对象,当对象被调用的时候才会加载，测试的时候，通过getbean()方法获得对象。lazy-init=&quot;false&quot; 默认值，不延迟，无论对象是否被使用，都会立即创建对象,测试时只需要加载配置文件即可。注意:测试的时候只留下id,class属性</td>
</tr>
<tr>
<td>init-method</td>
<td>只需要加载配置文件即可对象初始化方法</td>
</tr>
<tr>
<td>destroy-method</td>
<td>对象销毁方法</td>
</tr>
</tbody>
</table>
<h2 id="3-spring中对象创建的方式">3、Spring中对象创建的方式</h2>
<p>1、无参构造</p>
<p>2、有参构造</p>
<pre><code class="language-java">public Person(String name , Car car){
        this.name = name;
        this.car = car;
        System.out.println(&quot;Person的有参构造方法:&quot;+name+car);
    }

	&lt;!--给属性赋值时，对象类型选择ref，非对象类型选择value--&gt;
    &lt;bean name=&quot;person&quot; class=&quot;com.vinci.spring.bean.Person&quot;&gt;
        &lt;constructor-arg name=&quot;name&quot; value=&quot;rose&quot;/&gt;
        &lt;constructor-arg name=&quot;car&quot; ref=&quot;car&quot;/&gt;
    &lt;/bean&gt;
</code></pre>
<p>3、静态方法创建对象</p>
<pre><code class="language-java">//静态工厂模式
public class PersonFactory {
    public static Person createPerson(){
        System.out.println(&quot;静态工厂创建Person&quot;);
        return new Person();
    }
}

&lt;bean name=&quot;pf&quot; class=&quot;com.xzk.PersonFactory&quot; factory-method=&quot;createPerson&quot; /&gt;
</code></pre>
<p>4、非静态工厂方法</p>
<pre><code class="language-java">public class Users{
    public Person createPerson1(){
        System.out.println(&quot;非静态工厂创建Person&quot;);
        return new Person();
    }
}

&lt;bean id=&quot;u2&quot; class=&quot;com.bean.Users&quot;&gt;&lt;/bean&gt;
&lt;bean id=&quot;u3&quot; factory-method=&quot;createPerson1&quot; factory-bean=&quot;u2&quot;&gt;&lt;/bean&gt;
</code></pre>
<h2 id="4-springbean的生命周期重要">4、SpringBean的生命周期【重要】</h2>
<figure data-type="image" tabindex="2"><img src="https://Vinci-Ma.github.io/post-images/1600674093500.png" alt="生命周期" loading="lazy"></figure>
<h1 id="三-di注入值">三、DI注入值</h1>
<p>分类:一种是调取属性的set方法赋值，第二种使用构造方法赋值</p>
<h3 id="1-set注入值">1、set注入值</h3>
<pre><code class="language-java">1、基本属性类型值注入
    &lt;property name=&quot;name&quot; value=&quot;jeck&quot; /&gt;
2、引用属性类型值注入
    &lt;property name=&quot;car&quot; ref=&quot;car&quot;&gt;&lt;/property&gt;
</code></pre>
<h3 id="2-构造注入">2、构造注入</h3>
<pre><code class="language-java">1、通过name属性，按照参数名赋值
    public Person(String name , Car car){
        this.name = name;
        this.car = car;
        System.out.println(&quot;Person的有参构造方法:&quot;+name+car);
    }
    &lt;bean name=&quot;person&quot; class=&quot;com.xzk.spring.bean.Person&quot;&gt;
        &lt;constructor-arg name=&quot;name&quot; value=&quot;rose&quot;/&gt;
        &lt;constructor-arg name=&quot;car&quot; ref=&quot;car&quot;/&gt;
    &lt;/bean&gt;
2、通过index属性，按照参数索引注入
        &lt;bean name=&quot;person2&quot; class=&quot;com.xzk.spring.bean.Person&quot;&gt;
    &lt;constructor-arg name=&quot;name&quot; value=&quot;helen&quot; index=&quot;0&quot;&gt;&lt;/constructor-arg&gt;
    &lt;constructor-arg name=&quot;car&quot; ref=&quot;car&quot; index=&quot;1&quot;&gt;&lt;/constructor-arg&gt;
    &lt;/bean&gt;
3、使用type注入（一般不使用）
     public Person(Car car, String name) {
            super();
            System.out.println(&quot;Person(Car car, String name)&quot;);
            this.name = name;
            this.car = car;
        }
        public Person(Car car, Integer name) {
            super();
            System.out.println(&quot;Person(Car car, Integer name)&quot;);
            this.name = name + &quot;&quot;;
            this.car = car;
        }
      &lt;bean name=&quot;person2&quot; class=&quot;com.xzk.spring.bean.Person&quot;&gt;
        &lt;constructor-arg name=&quot;name&quot; value=&quot;988&quot; type=&quot;java.lang.Integer&quot;&gt;
        &lt;/constructor-arg&gt;
        &lt;constructor-arg name=&quot;car&quot; ref=&quot;car&quot; &gt;&lt;/constructor-arg&gt;
      &lt;/bean&gt;   
</code></pre>
<h3 id="3-spel-spring表达式">3、spel spring表达式</h3>
<pre><code class="language-java">&lt;bean name=&quot;car&quot; class=&quot;com.xzk.spring.bean.Car&quot; &gt;
    &lt;property name=&quot;name&quot; value=&quot;mime&quot; /&gt;
    &lt;property name=&quot;color&quot; value=&quot;白色&quot;/&gt;
&lt;/bean&gt;
&lt;!--利用spel引入car的属性 --&gt;
&lt;bean name=&quot;person1&quot; class=&quot;com.xzk.spring.bean.Person&quot; p:car-ref=&quot;car&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;#{car.name}&quot;/&gt;
    &lt;property name=&quot;age&quot; value=&quot;#{person.age}&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<h3 id="4-p命名空间注入值">4、p命名空间注入值</h3>
<pre><code class="language-java">1、首先引用p命名空间【配置文件中 添加命名空间p】
    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
2、进行操作
    &lt;bean id=&quot;u6&quot; class=&quot;com.entity.Users&quot; p:age=&quot;30&quot; p:name=&quot;李四&quot; p:student-ref=&quot;stu1&quot;&gt;&lt;/bean&gt;
   基本类型值: p:属性名=&quot;值&quot;
   引用类型值: P:属性名-ref=&quot;bean名称&quot;
</code></pre>
<h3 id="5-复杂类型注入objectlistsetmapjavautilproperties">5、复杂类型注入（Object[]，list，set，map，java.util.Properties）</h3>
<pre><code class="language-java">&lt;!-- 数组变量注入 --&gt;
    &lt;property name=&quot;arrs&quot;&gt;
        &lt;list&gt;
            &lt;value&gt;数组1&lt;/value&gt;
            &lt;!--引入其他类型--&gt;
            &lt;ref bean=&quot;car&quot;/&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;!-- 集合变量赋值--&gt;
    &lt;property name=&quot;list&quot;&gt;
        &lt;list&gt;
            &lt;value&gt;集合1&lt;/value&gt;
            &lt;!--集合变量内部包含集合--&gt;
            &lt;list&gt;
            &lt;value&gt;集合中的集合1&lt;/value&gt;
            &lt;value&gt;集合中的集合2&lt;/value&gt;
            &lt;value&gt;集合中的集合3&lt;/value&gt;
            &lt;/list&gt;
            &lt;ref bean=&quot;car&quot; /&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;!-- set赋值--&gt;
     &lt;property name=&quot;set&quot;&gt;
        &lt;set&gt;
            &lt;value&gt;set&lt;/value&gt;
            &lt;!--引入其他类型--&gt;
            &lt;ref bean=&quot;car&quot;/&gt;
        &lt;/set&gt;
    &lt;/property&gt;
&lt;!--map赋值 --&gt;
    &lt;property name=&quot;map&quot;&gt;
        &lt;map&gt;
            &lt;entry key=&quot;car&quot; value-ref=&quot;car&quot; /&gt;（有ref是对象类型的引用）
            &lt;entry key=&quot;name&quot; value=&quot;保时捷&quot; /&gt;
            &lt;entry key=&quot;age&quot; value=&quot;11&quot;/&gt;
        &lt;/map&gt;
    &lt;/property&gt;
&lt;!-- properties赋值 --&gt;
    &lt;property name=&quot;properties&quot;&gt;
        &lt;props&gt;
            &lt;prop key=&quot;name&quot;&gt;pro1&lt;/prop&gt;
            &lt;prop key=&quot;age&quot;&gt;111&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
</code></pre>
<h3 id="6-自动注入由程序自动给属性赋值">6、自动注入（由程序自动给属性赋值）</h3>
<p>autowire：</p>
<ul>
<li>
<p>no 不自动装配(默认值)</p>
</li>
<li>
<p>byName 属性名=id名 ，调取set方法赋值</p>
</li>
<li>
<p>byType 属性的类型和id对象的类型相同，当找到多个同类型的对象时报错，调取set方法赋值</p>
</li>
<li>
<p>constructor 构造方法的参数类型和id对象的类型相同,当没有找到时，报错。调取构造方法赋值</p>
</li>
</ul>
<pre><code class="language-java">&lt;bean id=&quot;service&quot; class=&quot;service.impl.UserServiceImpl&quot; autowire=&quot;constructor&quot;&gt;
&lt;/bean&gt;
配置全局自动装配:
	&lt;beans default-autowire=&quot;constructor/byName/byType/no&quot;&gt;
</code></pre>
<h1 id="四-注解实现ioc">四、注解实现IOC</h1>
<h3 id="1-配置文件中添加约束">1、配置文件中添加约束</h3>
<pre><code class="language-java">xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
http://www.springframework.org/schema/context
http://www.springframework.org/schema/context/spring-context.xsd
</code></pre>
<h3 id="3-配置注解扫描指定扫描包下所有类中的注解扫描包时会扫描包所有的子孙包">3、配置注解扫描:指定扫描包下所有类中的注解,扫描包时,会扫描包所有的子孙包</h3>
<pre><code class="language-java">&lt;!--扫描包设置--&gt;
&lt;context:component-scan base-package=&quot;com.vinci.spring.bean&quot;&gt;&lt;/context:component-scan&gt;
</code></pre>
<h3 id="3-注解">3、注解</h3>
<pre><code class="language-java">1、添加在类名上
    @Component(&quot;对象名&quot;)
    @Service(&quot;person&quot;) // service层
    @Controller(&quot;person&quot;) // controller层
    @Repository(&quot;person&quot;) // dao层
    @Scope(scopeName=&quot;singleton&quot;) //单例对象
    @Scope(scopeName=&quot;prototype&quot;) //多例对象
</code></pre>
<pre><code class="language-java">2、添加在属性上
    @Value(&quot;属性值&quot;)
    private String name;
   
	@Autowired //默认使用byType，如果一个接口类型，同时有两个实现类，则报错，此时可以借助@Qualifier(&quot;beanname&quot;)    
	@Qualifier(&quot;bean name&quot;)
    private Car car;
    
	//说明:@Resource 是java的注释,但是Spring框架支持,@Resource指定注入哪个名称的对象
    //@Resource(name=&quot;对象名&quot;) == @Autowired + @Qualifier(&quot;name&quot;)   
	@Resource(name=&quot;baoma&quot;)
	private Car car;
</code></pre>
<pre><code class="language-java">3、添加在方法上
   @PostConstruct //等价于init-method属性
    public void init(){
   	 	System.out.println(&quot;初始化方法&quot;);
    }

    @PreDestroy //等价于destroy-method属性
    public void destroy(){
    	System.out.println(&quot;销毁方法&quot;);
    } 
</code></pre>
<h1 id="五-aop介绍">五、Aop介绍</h1>
<p>AOP（Aspect Oriented Programming)即面向切面编程。即在不改变原程序的基础上为代码段增加新的功能。应用在权限认证、日志、事务。</p>
<p>作用：<strong>分离</strong>系统中的各种关注点，将核心关注点和横切关注点分离开来。</p>
<figure data-type="image" tabindex="3"><img src="https://Vinci-Ma.github.io/post-images/1600674132700.png" alt="aop" loading="lazy"></figure>
<h1 id="六-aop的实现机制">六、AOP的实现机制</h1>
<ul>
<li>JDK 的动态代理：针对实现了接口的类产生代理。InvocationHandler接口</li>
<li>CGlib 的动态代理：针对没有实现接口的类产生代理，应用的是底层的字节码增强的技术 生成当前类的子类对象，MethodInterceptor接口</li>
</ul>
<h2 id="1-jdk动态代理实现">1、JDK动态代理实现</h2>
<pre><code class="language-java">1、创建接口和对应实现类
    public interface UserService {
    	public void login();
    }
	//实现类
    public class UserServiceImpl implements UserService {
    	public void login(){}
    }
2、创建动态代理类，实现InvocationHandler接口
    public class agency implements InvocationHandler {
            private UserService target; //目标对象
            public agency(UserService target){
             this.target = target;
            }
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
            //本方法中的其他输出输入增强
            //proxy 代理方法被调用的代理实例
            System.out.println(&quot;方法触发了&quot;);
            //执行被代理类 原方法
            Object invoke = method.invoke(target, args);
            System.out.println(&quot;执行完毕了&quot;);
            return invoke;
        }
    }
3、创建测试
    @Test
    public void test1(){
        //测试JDK动态代理技术
        UserService us = new UserServiceImpl();
        agency ag = new agency(us);
        //这里不能转换成一个实际的类，必须是接口类型
        UserService uservice = (UserService)     Proxy.newProxyInstance(us.getClass().getClassLoader(),us.getClass().getInterfaces(),ag);
        uservice.login();
    }

测试结果: 在调用接口方法的前后都会添加代理类的方法!
</code></pre>
<h2 id="2-cglib实现代理">2、CGlib实现代理</h2>
<ul>
<li>使用JDK创建代理有一个限制,它只能为接口创建代理实例.这一点可以从Proxy的接口方法newProxyInstance(ClassLoader loader,Class [] interfaces,InvocarionHandler h)中看的很清楚</li>
</ul>
<h2 id="两种代理方式的区别">两种代理方式的区别:</h2>
<ul>
<li>1、jdk动态代理生成的代理类和委托类实现了相同的接口；</li>
<li>2、cglib动态代理中生成的字节码更加复杂，生成的代理类是委托类的子类，且不能处理被final关键字修饰的方法；</li>
<li>3、jdk采用反射机制调用委托类的方法，cglib采用类似索引的方式直接调用委托类方法；</li>
</ul>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#%E4%B8%80-spring%E4%BB%8B%E7%BB%8D">一、Spring介绍</a>
<ul>
<li><a href="#1-%E7%89%B9%E7%82%B9">1、特点</a></li>
<li><a href="#2-%E7%BB%84%E7%BB%87%E6%A1%86%E6%9E%B6">2、组织框架</a></li>
<li><a href="#3-%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97">3、核心模块</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C-spring%E4%B8%AD%E7%9A%84ioc">二、Spring中的IOC</a>
<ul>
<li><a href="#1-%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B">1、实现过程</a></li>
<li><a href="#2-bean%E6%A0%87%E7%AD%BE%E7%9A%84%E5%B1%9E%E6%80%A7%E4%BB%8B%E7%BB%8D">2、bean标签的属性介绍</a></li>
<li><a href="#3-spring%E4%B8%AD%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E7%9A%84%E6%96%B9%E5%BC%8F">3、Spring中对象创建的方式</a></li>
<li><a href="#4-springbean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%87%8D%E8%A6%81">4、SpringBean的生命周期【重要】</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89-di%E6%B3%A8%E5%85%A5%E5%80%BC">三、DI注入值</a><br>
*
<ul>
<li><a href="#1-set%E6%B3%A8%E5%85%A5%E5%80%BC">1、set注入值</a></li>
<li><a href="#2-%E6%9E%84%E9%80%A0%E6%B3%A8%E5%85%A5">2、构造注入</a></li>
<li><a href="#3-spel-spring%E8%A1%A8%E8%BE%BE%E5%BC%8F">3、spel spring表达式</a></li>
<li><a href="#4-p%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E6%B3%A8%E5%85%A5%E5%80%BC">4、p命名空间注入值</a></li>
<li><a href="#5-%E5%A4%8D%E6%9D%82%E7%B1%BB%E5%9E%8B%E6%B3%A8%E5%85%A5objectlistsetmapjavautilproperties">5、复杂类型注入（Object[]，list，set，map，java.util.Properties）</a></li>
<li><a href="#6-%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%85%A5%E7%94%B1%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E7%BB%99%E5%B1%9E%E6%80%A7%E8%B5%8B%E5%80%BC">6、自动注入（由程序自动给属性赋值）</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9B-%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0ioc">四、注解实现IOC</a><br>
*
<ul>
<li><a href="#1-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E6%B7%BB%E5%8A%A0%E7%BA%A6%E6%9D%9F">1、配置文件中添加约束</a></li>
<li><a href="#3-%E9%85%8D%E7%BD%AE%E6%B3%A8%E8%A7%A3%E6%89%AB%E6%8F%8F%E6%8C%87%E5%AE%9A%E6%89%AB%E6%8F%8F%E5%8C%85%E4%B8%8B%E6%89%80%E6%9C%89%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3%E6%89%AB%E6%8F%8F%E5%8C%85%E6%97%B6%E4%BC%9A%E6%89%AB%E6%8F%8F%E5%8C%85%E6%89%80%E6%9C%89%E7%9A%84%E5%AD%90%E5%AD%99%E5%8C%85">3、配置注解扫描:指定扫描包下所有类中的注解,扫描包时,会扫描包所有的子孙包</a></li>
<li><a href="#3-%E6%B3%A8%E8%A7%A3">3、注解</a></li>
</ul>
</li>
<li><a href="#%E4%BA%94-aop%E4%BB%8B%E7%BB%8D">五、Aop介绍</a></li>
<li><a href="#%E5%85%AD-aop%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6">六、AOP的实现机制</a>
<ul>
<li><a href="#1-jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0">1、JDK动态代理实现</a></li>
<li><a href="#2-cglib%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%90%86">2、CGlib实现代理</a></li>
<li><a href="#%E4%B8%A4%E7%A7%8D%E4%BB%A3%E7%90%86%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB">两种代理方式的区别:</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://Vinci-Ma.github.io/post/redis/">
              <h3 class="post-title">
                Redis
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  
  <a class="rss" href="https://Vinci-Ma.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
