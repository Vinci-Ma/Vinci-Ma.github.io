<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>TCP连接的”三次握手“和”四次挥手“ | Vinci-Ma</title>
<link rel="shortcut icon" href="https://Vinci-Ma.github.io/favicon.ico?v=1594642713008">
<link href="https://cdn.remixicon.com/releases/v2.1.0/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://Vinci-Ma.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="TCP连接的”三次握手“和”四次挥手“ | Vinci-Ma - Atom Feed" href="https://Vinci-Ma.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="
TCP连接的”三次握手“

TCP连接”三次握手“的异常情况

1、客户端第一个【SYN】包丢了
2、服务器端收到【SYN】回复，但是回复的【SYN，ACK】包丢了
3、客户端收到【SYN，ACK】包，在回复时丢失【ACK】包
4、客户端..." />
    <meta name="keywords" content="Java" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://Vinci-Ma.github.io">
  <img class="avatar" src="https://Vinci-Ma.github.io/images/avatar.png?v=1594642713008" alt="">
  </a>
  <h1 class="site-title">
    Vinci-Ma
  </h1>
  <p class="site-description">
    Stay cooool!
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="https://Vinci-Ma.github.io/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
      
        <a href="https://Vinci-Ma.github.io/tag/773fpMCOj" class="menu">
          Java学习
        </a>
      
    
      
        <a href="https://Vinci-Ma.github.io/tag/3SFSDg5ks" class="menu">
          读书
        </a>
      
    
  </div>
  <div class="social-container">
    
      
        <a href="https://github.com/Vinci-Ma" target="_blank">
          <i class="ri-github-line"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              TCP连接的”三次握手“和”四次挥手“
            </h2>
            <div class="post-info">
              <span>
                2020-07-07
              </span>
              <span>
                6 min read
              </span>
              
                <a href="https://Vinci-Ma.github.io/tag/773fpMCOj/" class="post-tag">
                  # Java
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p><ul class="markdownIt-TOC">
<li><a href="#tcp%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B">TCP连接的”三次握手“</a>
<ul>
<li><a href="#tcp%E8%BF%9E%E6%8E%A5%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E5%BC%82%E5%B8%B8%E6%83%85%E5%86%B5">TCP连接”三次握手“的异常情况</a>
<ul>
<li><a href="#1-%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%AC%AC%E4%B8%80%E4%B8%AAsyn%E5%8C%85%E4%B8%A2%E4%BA%86"><strong>1、客户端第一个【SYN】包丢了</strong></a></li>
<li><a href="#2-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%94%B6%E5%88%B0syn%E5%9B%9E%E5%A4%8D%E4%BD%86%E6%98%AF%E5%9B%9E%E5%A4%8D%E7%9A%84synack%E5%8C%85%E4%B8%A2%E4%BA%86"><strong>2、服务器端收到【SYN】回复，但是回复的【SYN，ACK】包丢了</strong></a></li>
<li><a href="#3-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%94%B6%E5%88%B0synack%E5%8C%85%E5%9C%A8%E5%9B%9E%E5%A4%8D%E6%97%B6%E4%B8%A2%E5%A4%B1ack%E5%8C%85"><strong>3、客户端收到【SYN，ACK】包，在回复时丢失【ACK】包</strong></a></li>
<li><a href="#4-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%95%85%E6%84%8F%E4%B8%8D%E5%8F%91%E6%9C%80%E5%90%8E%E4%B8%80%E6%AC%A1syn%E5%8C%85"><strong>4、客户端故意不发最后一次【SYN】包</strong></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#tcp%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B">TCP连接的”四次挥手“</a>
<ul>
<li><a href="#tcp%E8%BF%9E%E6%8E%A5%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%9A%84%E5%BC%82%E5%B8%B8%E6%83%85%E5%86%B5">TCP连接“四次挥手”的异常情况</a>
<ul>
<li><a href="#1">1、</a></li>
</ul>
</li>
</ul>
</li>
</ul>
(TCP连接的”三次握手“和”四次挥手“)<br>
<img src="https://Vinci-Ma.github.io/post-images/1594630185256.png" alt="TCP连接的”三次握手“和”四次挥手“图示" loading="lazy"></p>
<h1 id="tcp连接的三次握手">TCP连接的”三次握手“</h1>
<figure data-type="image" tabindex="1"><img src="https://Vinci-Ma.github.io/post-images/1594640308254.png" alt="三次握手" loading="lazy"></figure>
<ol>
<li>开始时，客户端和服务器端都处于CLOSE状态，【服务器为了提供服务，会主动监听某个端口，进入LISTEN状态】？？？？？？</li>
<li>客户端主动发送连接的 【SYN】 包，之后进入SYN-SENT状态，服务端在收到客户端发来的 【SYN】包后，回复 【SYN , ACK】包，之后进入 SYN-RCVD 状态。</li>
<li>客户端收到服务端发来的【SYN ,ACK】包后，可以确认对方的的存在，回复 【ACK】包，进入ESTABLISHED状态</li>
<li>服务端收到最后一个[ACK]包后，也进入ESTABLISHED状态</li>
</ol>
<p>正常的三次握手之后，双端都进入ESTABLISHED状态，然后开始传输数据。</p>
<h2 id="tcp连接三次握手的异常情况">TCP连接”三次握手“的异常情况</h2>
<h3 id="1-客户端第一个syn包丢了"><strong>1、客户端第一个【SYN】包丢了</strong></h3>
<ol>
<li>如果在TCP连接中，客户端的第一个【SYN】包丢了，而此时跟服务器端并无联系，所以处理办法在客户端。</li>
<li>在TCP协议中，任何一端的【请求——应答】过程中，在一定时间范围内没哟接收到对方的回应的【ACK】包，就会认为是丢包，此时触发超时重传机制。</li>
<li>此时会重传【SYN】包，会重传3次，时间间隔分别是： 5.8s、24s、48s，三次时间大约是 76s 左右，而大多数伯克利系统将建立一个新连接的最长时间，限制为 75s。</li>
</ol>
<p><mark>总结：</mark><br>
<mark>客户端第一个【SYN】包丢了：客户端会进行三次重传【SYN】包，总的尝试时间大约在75s左右。</mark></p>
<h3 id="2-服务器端收到syn回复但是回复的synack包丢了"><strong>2、服务器端收到【SYN】回复，但是回复的【SYN，ACK】包丢了</strong></h3>
<ol>
<li>对于客户端来说，在规定时间内没有接收到来自服务器端的回复，会认为是自己丢包了，会进行重传【SYN】包。</li>
<li>对于服务器端来说，发出的【SYN，SCK】迟迟没有客户端的【ACK】回复，会触发重传，此时服务端处于 SYN_RCVD 状态，会依次等待 3s、6s、12s 后，重新发送【SYN，ACK】包；而【SYN，ACK】的重传次数，不同操作系统有不同的配置，例如在 Linux 下可以通过 tcp_synack_retries 进行配置，默认值为 5。如果这个重试次数内，仍未收到【ACK】应答包，那么服务端会自动关闭这个连接。</li>
<li>同时由于客户端在没有收到【SYN，ACK】时，也会进行重传，当客户端重传的【SYN】收到后，会立即重新发送【SYN，ACK】包。</li>
</ol>
<p><mark>总结：</mark><br>
<mark>服务器端收到【SYN】回复，但是回复的【SYN，ACK】包丢了：客户端会进行如上的重传；服务器端也会进行重传。</mark></p>
<h3 id="3-客户端收到synack包在回复时丢失ack包"><strong>3、客户端收到【SYN，ACK】包，在回复时丢失【ACK】包</strong></h3>
<ol>
<li>对于客户端，在发送【ACK】包后进入 ESTABLISHED 状态。多数情况下，客户端进入ESTABLISHED 状态后，认为连接已建立，会立即发送数据。</li>
<li>对于服务端，因为没有收到【ACK】会走重传机制，但是服务端因为没有收到最后一个【ACK】包，依然处于 SYN-RCVD 状态。</li>
<li>当服务端处于 SYN-RCVD 状态下时，接收到客户端真实发送来的数据包时，会认为连接已建立，并进入ESTABLISHED状态。<br>
原因：<br>
当客户端在 ESTABLISHED 状态下，开始发送数据包时，会携带上一个【ACK】的确认序号，所以哪怕客户端响应的【ACK】包丢了，服务端在收到这个数据包时，能够通过包内 ACK 的确认序号，正常进入 ESTABLISHED 状态。<br>
<mark>总结：</mark><br>
<mark>客户端收到【SYN，ACK】包，在回复时丢失【ACK】包：客户端会进入 ESTABLISHED状态，向服务器端发送数据；服务器端虽然没有接收到客户端最后发来【ACK】包，但是因为数据包携带ACK的确认序号，所以在接收到数据包时，会认为连接已经建立，变为ESTABLISHED状态。</mark></li>
</ol>
<h3 id="4-客户端故意不发最后一次syn包"><strong>4、客户端故意不发最后一次【SYN】包</strong></h3>
<p>如果客户端是恶意的，在发送【SYN】包后，并收到【SYN,ACK】后就不回复了，那么服务端此时处于一种半连接的状态，虽然服务端会通过 tcp_synack_retries 配置重试的次数，不会无限等待下去，但是这也是有一个时间周期的。<br>
如果短时间内存在大量的这种恶意连接，对服务端来说压力就会很大，这就是所谓的 SYN FLOOD 攻击。</p>
<h1 id="tcp连接的四次挥手">TCP连接的”四次挥手“</h1>
<figure data-type="image" tabindex="2"><img src="https://Vinci-Ma.github.io/post-images/1594640340361.jpg" alt="四次挥手" loading="lazy"></figure>
<ol>
<li>开始客户端和服务器端都处于ESTABLISHED状态，两端任意一端都可以发送【FIN】包准备断开，图中为客户端发送【FIN】包，请求与服务器断开连接，在发出【FIN】后，客户端进入 FIN-WAIT-1 状态。</li>
<li>服务器端收到【FIN】，回复【ACK】表示接收到了信息，并从 ESTABLISHED 状态进入 CLOSED-WAIT 状态，开始做一些断开连接前的准备工作。</li>
<li>客户端收到服务器端回复的【ACK】消息后，进入 FIN-WAIT-2 状态。而当服务器端做好断开前的准备工作后，也会发送一个【FIN,ACK】的消息給客户端，表示服务器端已经准备好了，请求断开连接，并在发送消息后，服务器端进入 LAST-ACK 状态。</li>
<li>客户端在收到【FIN,ACK】消息后，会立即回复【ACK】，表示收到了消息，并进入 TIME_WAIT 状态，为了稳定和安全考虑，客户端会在 TIME-WAIT 状态等待 2MSL 的时长，最终进入 CLOSED 状态；服务器端收到客户端回复的【ACK】消息后，直接从 LAST-ACK 状态进入 CLOSED 状态。</li>
</ol>
<p>经过了“四次挥手”之后，双端都为CLOSED 状态，双端正式断开了连接。</p>
<h2 id="tcp连接四次挥手的异常情况">TCP连接“四次挥手”的异常情况</h2>
<h3 id="1">1、</h3>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#tcp%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B">TCP连接的”三次握手“</a>
<ul>
<li><a href="#tcp%E8%BF%9E%E6%8E%A5%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E5%BC%82%E5%B8%B8%E6%83%85%E5%86%B5">TCP连接”三次握手“的异常情况</a>
<ul>
<li><a href="#1-%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%AC%AC%E4%B8%80%E4%B8%AAsyn%E5%8C%85%E4%B8%A2%E4%BA%86"><strong>1、客户端第一个【SYN】包丢了</strong></a></li>
<li><a href="#2-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%94%B6%E5%88%B0syn%E5%9B%9E%E5%A4%8D%E4%BD%86%E6%98%AF%E5%9B%9E%E5%A4%8D%E7%9A%84synack%E5%8C%85%E4%B8%A2%E4%BA%86"><strong>2、服务器端收到【SYN】回复，但是回复的【SYN，ACK】包丢了</strong></a></li>
<li><a href="#3-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%94%B6%E5%88%B0synack%E5%8C%85%E5%9C%A8%E5%9B%9E%E5%A4%8D%E6%97%B6%E4%B8%A2%E5%A4%B1ack%E5%8C%85"><strong>3、客户端收到【SYN，ACK】包，在回复时丢失【ACK】包</strong></a></li>
<li><a href="#4-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%95%85%E6%84%8F%E4%B8%8D%E5%8F%91%E6%9C%80%E5%90%8E%E4%B8%80%E6%AC%A1syn%E5%8C%85"><strong>4、客户端故意不发最后一次【SYN】包</strong></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#tcp%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B">TCP连接的”四次挥手“</a>
<ul>
<li><a href="#tcp%E8%BF%9E%E6%8E%A5%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%9A%84%E5%BC%82%E5%B8%B8%E6%83%85%E5%86%B5">TCP连接“四次挥手”的异常情况</a>
<ul>
<li><a href="#1">1、</a></li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://Vinci-Ma.github.io/post/java-zhong-de-di-gui-suan-fa/">
              <h3 class="post-title">
                Java中的递归算法
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  
  <a class="rss" href="https://Vinci-Ma.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
